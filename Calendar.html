<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Hyper Modern Calendar - ARNOMA Design</title>
    
    <!-- Supabase Configuration -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.45.1"></script>
    <script>
      // Supabase Client Initialization
      const SUPABASE_URL = 'https://zlvnxvrzotamhpezqedr.supabase.co';
      const SUPABASE_ANON_KEY =
        'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Inpsdm54dnJ6b3RhbWhwZXpxZWRyIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjI4MTEzMTcsImV4cCI6MjA3ODM4NzMxN30.-IoSqKhDrA9NuG4j3GufIbfmodWqCoppEklE1nTmw38';
      const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
      
      // Global data caches
      window.studentsCache = [];
      window.groupsCache = [];
      window.paymentsCache = [];
      
      // ============================================================
      // ⚡ PERFORMANCE UTILITIES
      // ============================================================
      
      // Production mode - set to false to disable debug logging
      const DEBUG_MODE = false;
      
      // Debug logging wrapper (only logs when DEBUG_MODE is true)
      function debugLog(...args) {
        if (DEBUG_MODE) debugLog(...args);
      }
      
      // DOM Cache to eliminate repeated getElementById calls
      const DOMCache = {
        calendar: null,
        monthYear: null,
        prevBtn: null,
        nextBtn: null,
        todayBtn: null,
        eventSidebar: null,
        eventsList: null,
        countdown: null,
        modals: {},
        
        init() {
          this.calendar = document.getElementById('calendar');
          this.monthYear = document.getElementById('monthYear');
          this.prevBtn = document.getElementById('prevMonth');
          this.nextBtn = document.getElementById('nextMonth');
          this.todayBtn = document.getElementById('todayBtn');
          this.eventSidebar = document.getElementById('eventSidebar');
          this.eventsList = document.getElementById('eventsList');
          this.countdown = document.getElementById('countdown');
          
          debugLog('✅ Calendar DOM Cache initialized');
        },
        
        get(key) {
          return this[key] || document.getElementById(key);
        },
        
        invalidate(key) {
          if (key) {
            this[key] = null;
          } else {
            Object.keys(this).forEach(k => {
              if (typeof this[k] !== 'function') this[k] = null;
            });
          }
        }
      };
      
      // Data Cache for expensive computations (month data, events, etc.)
      const DataCache = {
        monthData: new Map(), // Cache computed month data
        events: null,
        students: null,
        lastFetch: {},
        
        TTL: 5 * 60 * 1000, // 5 minutes
        
        set(key, value) {
          this[key] = value;
          this.lastFetch[key] = Date.now();
        },
        
        get(key) {
          const age = Date.now() - (this.lastFetch[key] || 0);
          if (age > this.TTL) {
            this[key] = null;
            delete this.lastFetch[key];
            return null;
          }
          return this[key];
        },
        
        invalidate(key) {
          if (key) {
            this[key] = null;
            delete this.lastFetch[key];
          } else {
            Object.keys(this).forEach(k => {
              if (typeof this[k] !== 'function' && k !== 'monthData') this[k] = null;
            });
            this.lastFetch = {};
          }
        },
        
        // Month-specific caching
        getMonth(year, month) {
          const key = `${year}-${month}`;
          return this.monthData.get(key);
        },
        
        setMonth(year, month, data) {
          const key = `${year}-${month}`;
          this.monthData.set(key, data);
        },
        
        invalidateMonth(year, month) {
          const key = `${year}-${month}`;
          this.monthData.delete(key);
        }
      };
      
      // RequestAnimationFrame wrapper for smooth updates
      let rafCallbacks = {};
      function scheduleRAF(key, callback) {
        if (rafCallbacks[key]) {
          cancelAnimationFrame(rafCallbacks[key]);
        }
        rafCallbacks[key] = requestAnimationFrame(callback);
      }
    </script>
    
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      html {
        background: #05060a;
        color-scheme: dark;
      }

      :root {
        /* ARNOMA Glassmorphism + Neon Prism Hybrid */
        --glass-bg: rgba(255, 255, 255, 0.08);
        --glass-border: rgba(255, 255, 255, 0.2);
        --neon-cyan: #26ffe6;
        --neon-purple: #8a4dff;
        --primary-gradient: linear-gradient(135deg, var(--neon-cyan), var(--neon-purple));
        --secondary-gradient: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        --accent-gradient: linear-gradient(135deg, var(--neon-cyan), var(--neon-purple));
        --dark-bg: radial-gradient(circle at 20% 20%, #0f1120, #05060a 80%);
        --card-bg: var(--glass-bg);
        --card-border: var(--glass-border);
        --text-primary: #e8e8e8;
        --text-secondary: #9a9a9a;
        --text-light: #e8e8e8;
        --text-dim: #9a9a9a;
        --shadow-glow:
          0 0 35px rgba(0, 0, 0, 0.4), 0 0 12px rgba(30, 255, 230, 0.25), inset 0 0 25px rgba(255, 255, 255, 0.05);
        --shadow-soft: 0 4px 16px rgba(0, 0, 0, 0.2);
        --radius: 22px;
        --transition: 0.25s ease;
        --blur: 18px;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, 'Inter', 'Poppins', sans-serif;
        background: radial-gradient(circle at 20% 20%, #0f1120, #05060a 80%) fixed;
        min-height: 100vh;
        padding: 40px 20px;
        overflow-x: hidden;
        position: relative;
        color: var(--text-primary);
      }

      /* Floating Neon Orbs - ARNOMA Style */
      body::before {
        content: '';
        position: fixed;
        top: -120px;
        left: -80px;
        width: 380px;
        height: 380px;
        border-radius: 50%;
        background: radial-gradient(circle, rgba(38, 255, 230, 0.45), transparent 70%);
        filter: blur(55px);
        animation: float 8s ease-in-out infinite alternate;
        opacity: 0.6;
        z-index: -1;
      }

      body::after {
        content: '';
        position: fixed;
        bottom: -140px;
        right: -100px;
        width: 400px;
        height: 400px;
        border-radius: 50%;
        background: radial-gradient(circle, rgba(138, 77, 255, 0.35), transparent 70%);
        filter: blur(65px);
        animation: float2 10s ease-in-out infinite alternate;
        opacity: 0.5;
        z-index: -1;
      }

      @keyframes float {
        from {
          transform: translateY(0);
        }
        to {
          transform: translateY(30px);
        }
      }

      @keyframes float2 {
        from {
          transform: translateY(0);
        }
        to {
          transform: translateY(-30px);
        }
      }

      .container {
        max-width: 1600px;
        margin: 0 auto;
        display: grid;
        grid-template-columns: 1fr;
        gap: 30px;
        transition: grid-template-columns 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .container.sidebar-expanded {
        grid-template-columns: 1fr 320px;
      } /* Sidebar */
      .sidebar {
        background: transparent;
        backdrop-filter: none;
        -webkit-backdrop-filter: none;
        border: none;
        border-radius: var(--radius);
        padding: 20px 15px;
        box-shadow: none;
        max-height: calc(100vh - 80px);
        overflow-y: auto;
        overflow-x: hidden;
        position: fixed;
        top: 20px;
        right: -80px;
        transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        width: 60px;
        opacity: 0;
        pointer-events: none;
      }

      .sidebar.expanded {
        background: var(--glass-bg);
        backdrop-filter: blur(var(--blur));
        -webkit-backdrop-filter: blur(var(--blur));
        border: 1px solid var(--glass-border);
        box-shadow: var(--shadow-glow);
        padding: 30px;
        width: 320px;
        right: 20px;
        opacity: 1;
        pointer-events: all;
      }

      .sidebar .sidebar-content {
        opacity: 0;
        visibility: hidden;
        transform: translateX(20px);
      }

      .sidebar.expanded .sidebar-content {
        opacity: 1;
        visibility: visible;
        transform: translateX(0);
      }

      .sidebar-content {
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .sidebar-toggle {
        width: 40px;
        height: 40px;
        border-radius: 12px;
        border: 1px solid var(--card-border);
        background: var(--card-bg);
        backdrop-filter: blur(10px);
        color: var(--text-primary);
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1.3rem;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        margin-bottom: 0;
        position: relative;
        overflow: hidden;
      }

      .sidebar.expanded .sidebar-toggle {
        margin-bottom: 20px;
      }

      .sidebar-toggle::before {
        content: '';
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: var(--primary-gradient);
        transition: left 0.4s ease;
        z-index: -1;
      }

      .sidebar-toggle:hover::before {
        left: 0;
      }

      .sidebar-toggle:hover {
        transform: translateY(-2px);
        box-shadow: 0 0 18px rgba(38, 255, 230, 0.4);
        border-color: var(--neon-cyan);
      }

      .toggle-icon {
        transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .sidebar.expanded .toggle-icon {
        transform: rotate(180deg);
      }

      /* Floating toggle button when sidebar is collapsed */
      .floating-toggle {
        position: fixed;
        bottom: 40px;
        right: 40px;
        width: 50px;
        height: 50px;
        border-radius: 50%;
        border: 1px solid var(--card-border);
        background: var(--card-bg);
        backdrop-filter: blur(10px);
        color: var(--text-primary);
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1.5rem;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        z-index: 1000;
        opacity: 1;
        pointer-events: all;
      }

      .floating-toggle.hidden {
        opacity: 0;
        pointer-events: none;
        transform: scale(0.8);
      }

      .floating-toggle:hover {
        transform: translateY(-2px) scale(1.05);
        box-shadow: 0 0 25px rgba(38, 255, 230, 0.5);
        border-color: var(--neon-cyan);
      }

      .sidebar::-webkit-scrollbar {
        width: 8px;
      }

      .sidebar::-webkit-scrollbar-track {
        background: rgba(255, 255, 255, 0.05);
        border-radius: 10px;
        margin: 10px 0;
      }

      .sidebar::-webkit-scrollbar-thumb {
        background: var(--primary-gradient);
        border-radius: 10px;
        transition: background 0.3s ease;
      }

      .sidebar::-webkit-scrollbar-thumb:hover {
        background: var(--primary-gradient);
        filter: brightness(1.2);
      }

      .sidebar-section {
        margin-bottom: 30px;
      }

      .sidebar-section:last-child {
        margin-bottom: 0;
      }

      .sidebar-title {
        font-size: 0.85rem;
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 1.5px;
        color: var(--text-secondary);
        margin-bottom: 15px;
        background: var(--primary-gradient);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
      }

      .filter-group {
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .filter-item {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 12px 16px;
        background: rgba(255, 255, 255, 0.03);
        border: 1px solid var(--card-border);
        border-radius: 12px;
        cursor: pointer;
        transition: all 0.3s ease;
        position: relative;
        overflow: hidden;
      }

      .filter-item::before {
        content: '';
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: var(--primary-gradient);
        opacity: 0.1;
        transition: left 0.3s ease;
      }

      .filter-item:hover::before {
        left: 0;
      }

      .filter-item:hover {
        border-color: var(--neon-cyan);
        transform: translateX(4px);
      }

      .filter-item.active {
        background: rgba(38, 255, 230, 0.15);
        border-color: var(--neon-cyan);
      }

      .filter-label {
        display: flex;
        align-items: center;
        gap: 10px;
        font-size: 0.9rem;
        color: var(--text-primary);
      }

      .filter-checkbox {
        width: 20px;
        height: 20px;
        border-radius: 6px;
        border: 2px solid var(--card-border);
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.3s ease;
      }

      .filter-item.active .filter-checkbox {
        background: var(--primary-gradient);
        border-color: transparent;
      }

      .filter-checkbox::after {
        content: '✓';
        color: white;
        font-size: 0.75rem;
        font-weight: 700;
        opacity: 0;
        transform: scale(0);
        transition: all 0.2s ease;
      }

      .filter-item.active .filter-checkbox::after {
        opacity: 1;
        transform: scale(1);
      }

      .filter-count {
        background: rgba(255, 255, 255, 0.1);
        padding: 4px 10px;
        border-radius: 8px;
        font-size: 0.8rem;
        font-weight: 600;
        color: var(--text-secondary);
      }

      .stats-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 12px;
      }

      .stat-card {
        background: rgba(255, 255, 255, 0.03);
        border: 1px solid var(--card-border);
        border-radius: 12px;
        padding: 16px;
        text-align: center;
        transition: all 0.3s ease;
      }

      .stat-card:hover {
        transform: translateY(-2px);
        border-color: var(--neon-cyan);
      }

      .stat-number {
        font-size: 1.8rem;
        font-weight: 700;
        background: var(--primary-gradient);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        display: block;
        margin-bottom: 4px;
      }

      .stat-label {
        font-size: 0.75rem;
        color: var(--text-secondary);
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      .quick-actions {
        display: flex;
        flex-direction: column;
        gap: 10px;
      }

      .action-btn {
        width: 100%;
        padding: 12px 20px;
        border-radius: 12px;
        border: 1px solid var(--glass-border);
        background: var(--glass-bg);
        color: var(--text-primary);
        font-weight: 600;
        cursor: pointer;
        transition: var(--transition);
        position: relative;
        overflow: hidden;
        font-size: 0.9rem;
      }

      .insight-list {
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .insight-card {
        padding: 12px 14px;
        border-radius: 14px;
        border: 1px solid var(--card-border);
        background: rgba(5, 6, 10, 0.3);
        box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.02);
        display: flex;
        flex-direction: column;
        gap: 6px;
      }

      .insight-title {
        font-size: 0.95rem;
        font-weight: 600;
        color: var(--text-primary);
      }

      .insight-meta {
        display: flex;
        align-items: center;
        justify-content: space-between;
        font-size: 0.8rem;
        color: var(--text-secondary);
        gap: 8px;
      }

      .insight-meta span {
        white-space: nowrap;
      }

      .insight-badge {
        padding: 4px 10px;
        border-radius: 999px;
        font-size: 0.7rem;
        letter-spacing: 0.5px;
        text-transform: uppercase;
        font-weight: 700;
        color: #05060a;
      }

      .insight-badge.upcoming {
        background: var(--primary-gradient);
      }

      .insight-badge.unpaid {
        background: linear-gradient(135deg, #f97316, #ef4444);
        color: #fff;
      }

      .insight-empty {
        padding: 14px;
        border-radius: 12px;
        border: 1px dashed var(--card-border);
        text-align: center;
        font-size: 0.8rem;
        color: var(--text-secondary);
      }

      .action-btn::before {
        content: '';
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: var(--primary-gradient);
        transition: left 0.4s ease;
        z-index: -1;
      }

      .action-btn:hover::before {
        left: 0;
      }

      .action-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 0 18px rgba(38, 255, 230, 0.4);
      }

      .calendar-wrapper {
        display: flex;
        flex-direction: column;
        gap: 30px;
      }

      /* Header */
      .calendar-header {
        background: var(--glass-bg);
        backdrop-filter: blur(var(--blur));
        -webkit-backdrop-filter: blur(var(--blur));
        border: 1px solid var(--glass-border);
        border-radius: var(--radius);
        padding: 18px 30px;
        margin-bottom: 20px;
        box-shadow: var(--shadow-glow);
        display: flex;
        justify-content: space-between;
        align-items: center;
        position: relative;
        overflow: hidden;
      }

      .calendar-header::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 2px;
        background: var(--primary-gradient);
      }

      .month-year {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }

      .month-year h1 {
        font-size: 1.8rem;
        font-weight: 700;
        background: var(--primary-gradient);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        margin: 0;
      }

      .calendar-stats {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 10px;
        margin-top: 4px;
        font-size: 0.8rem;
        color: var(--text-secondary);
        flex-wrap: wrap;
      }

      .calendar-stats .stat-divider {
        color: rgba(255, 255, 255, 0.3);
      }

      .calendar-stats .stat-paid {
        color: #22c55e;
        font-weight: 600;
      }

      .calendar-stats .stat-pending {
        color: #ef4444;
        font-weight: 600;
      }

      .year-badge {
        background: var(--primary-gradient);
        padding: 4px 14px;
        border-radius: 10px;
        font-size: 0.85rem;
        font-weight: 600;
        color: #000;
        box-shadow: 0 0 18px rgba(38, 255, 230, 0.45);
      }

      .nav-controls {
        display: flex;
        gap: 12px;
      }

      .nav-btn {
        width: 40px;
        height: 40px;
        border-radius: 10px;
        border: 1px solid var(--glass-border);
        background: var(--glass-bg);
        backdrop-filter: blur(10px);
        color: var(--text-primary);
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1.3rem;
        transition: var(--transition);
        position: relative;
        overflow: hidden;
      }

      .nav-btn::before {
        content: '';
        position: absolute;
        top: 50%;
        left: 50%;
        width: 0;
        height: 0;
        border-radius: 50%;
        background: var(--primary-gradient);
        transition:
          width 0.6s,
          height 0.6s,
          top 0.6s,
          left 0.6s;
        transform: translate(-50%, -50%);
        z-index: -1;
      }

      .nav-btn:hover::before {
        width: 200%;
        height: 200%;
      }

      .nav-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 0 18px rgba(38, 255, 230, 0.4);
        border-color: var(--neon-cyan);
      }

      .nav-btn:active {
        transform: translateY(0);
      }

      .today-btn {
        padding: 10px 20px;
        border-radius: 10px;
        border: none;
        background: var(--primary-gradient);
        color: #000;
        font-weight: 600;
        font-size: 0.9rem;
        cursor: pointer;
        transition: var(--transition);
        position: relative;
        overflow: hidden;
      }

      .today-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 0 18px rgba(38, 255, 230, 0.45);
      }

      /* Notification Bell */
      .notification-bell {
        position: relative;
        width: 44px;
        height: 44px;
        border-radius: 12px;
        border: 1px solid var(--glass-border);
        background: var(--glass-bg);
        color: var(--text-primary);
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1.3rem;
        transition: var(--transition);
        margin-left: 12px;
      }

      .notification-bell svg {
        width: 20px;
        height: 20px;
        fill: none;
        stroke: currentColor;
        stroke-width: 2;
        stroke-linecap: round;
        stroke-linejoin: round;
        transition: var(--transition);
      }

      .notification-bell:hover {
        background: rgba(255, 255, 255, 0.1);
        border-color: rgba(138,180,255,0.3);
        transform: translateY(-2px);
      }

      .notification-bell:active {
        transform: translateY(0);
      }

      .notification-bell.has-notifications {
        border-color: #22c55e;
        background: rgba(34, 197, 94, 0.1);
        animation: bellPulse 2s ease-in-out infinite;
      }

      .notification-bell.has-notifications svg {
        stroke: #22c55e;
      }

      @keyframes bellPulse {
        0%, 100% {
          box-shadow: 0 0 0 0 rgba(34, 197, 94, 0.4);
        }
        50% {
          box-shadow: 0 0 0 8px rgba(34, 197, 94, 0);
        }
      }

      .notification-badge {
        position: absolute;
        top: -6px;
        right: -6px;
        min-width: 20px;
        height: 20px;
        border-radius: 10px;
        background: linear-gradient(135deg, #22c55e 0%, #10b981 100%);
        color: #000;
        font-size: 0.7rem;
        font-weight: 700;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 0 6px;
        box-shadow: 0 2px 8px rgba(34, 197, 94, 0.4);
      }

      /* Calendar Grid */
      .calendar-grid {
        background: var(--glass-bg);
        backdrop-filter: blur(var(--blur));
        -webkit-backdrop-filter: blur(var(--blur));
        border: 1px solid var(--glass-border);
        border-radius: var(--radius);
        padding: 30px;
        box-shadow: var(--shadow-glow);
        position: relative;
        overflow: visible;
        animation: fadeIn 0.6s ease-out;
      }

      .calendar-grid::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 2px;
        background: var(--accent-gradient);
      }

      /* Weekday Headers */
      .weekdays {
        display: grid;
        grid-template-columns: repeat(7, 1fr);
        gap: 8px;
        margin-bottom: 15px;
      }

      .weekday {
        text-align: center;
        font-weight: 600;
        font-size: 0.85rem;
        color: var(--text-secondary);
        padding: 12px 0;
        text-transform: uppercase;
        letter-spacing: 1px;
        background: var(--primary-gradient);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
      }

      /* Days Grid */
      .days {
        display: grid;
        grid-template-columns: repeat(7, 1fr);
        gap: 8px;
        overflow: visible;
      }

      .day {
        height: 140px;
        border-radius: 14px;
        border: 1px solid var(--glass-border);
        background: var(--glass-bg);
        backdrop-filter: blur(10px);
        display: flex;
        flex-direction: column;
        align-items: flex-start;
        justify-content: flex-start;
        padding: 8px;
        cursor: pointer;
        position: relative;
        overflow: visible;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        animation: fadeIn 0.4s ease-out backwards;
      }

      .day::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: var(--primary-gradient);
        opacity: 0;
        transition: opacity 0.3s ease;
        z-index: 0;
      }

      .day:hover::before {
        opacity: 0.1;
      }

      .day:hover {
        transform: translateY(-4px) scale(1.02);
        box-shadow: 0 0 18px rgba(38, 255, 230, 0.4);
        border-color: var(--neon-cyan);
      }

      .day-header {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        width: 100%;
        z-index: 1;
        position: relative;
      }

      .day-number {
        font-size: 1.1rem;
        font-weight: 600;
        color: var(--text-primary);
        position: relative;
      }

      .day-payment-summary {
        font-size: 0.7rem;
        font-weight: 600;
        display: flex;
        flex-direction: row;
        align-items: center;
        gap: 4px;
        z-index: 1;
        white-space: nowrap;
      }

      .day-payment-paid {
        color: #22c55e;
      }

      .day-payment-unpaid {
        color: #ef4444;
      }

      .day-payment-divider {
        color: var(--text-secondary);
      }

      .day-number::after {
        display: none;
      }

      .day.today .day-number::after {
        background: white;
        opacity: 0.8;
        box-shadow: 0 0 8px rgba(255, 255, 255, 0.6);
      }

      .day.has-class .day-number::after,
      .day.has-payment .day-number::after,
      .day.has-absence .day-number::after {
        opacity: 0.6;
      }

      .day-indicator {
        display: flex;
        flex-direction: column;
        gap: 4px;
        z-index: 2;
        width: 100%;
        flex: 1;
        justify-content: center;
        align-items: flex-start;
      }

      .group-dots-row {
        display: flex;
        gap: 3px;
        flex-wrap: wrap;
        align-items: center;
        padding: 2px 0;
        border-bottom: 1px solid rgba(255, 255, 255, 0.08);
        width: 100%;
        font-size: 0.65rem;
      }

      .group-dots-row:last-child {
        border-bottom: none;
      }

      .group-label {
        font-size: 0.65rem;
        font-weight: 600;
        color: var(--neon-cyan);
        margin-right: 4px;
        min-width: 15px;
        position: relative;
      }

      /* Scratch line through canceled group labels - diagonal like dots */
      .group-label.canceled::after,
      .group-label.skipped::after {
        content: '';
        position: absolute;
        top: 80%;
        left: 0%;
        width: 70%;
        height: 1.5px;
        background: rgba(251, 191, 36, 0.9); /* Yellow scratch */
        transform: rotate(-45deg);
        transform-origin: left center;
        pointer-events: none;
      }

      .indicator-dot {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        transition: all 0.2s ease;
        cursor: pointer;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        position: relative;
      }

      .indicator-dot:hover {
        transform: scale(1.5);
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
      }

      /* Tooltip for dots - using fixed position to escape stacking context */
      .indicator-dot[data-tooltip] {
        position: relative;
      }

      /* Custom tooltip container that appears above everything */
      .custom-tooltip {
        position: fixed;
        background: rgba(0, 0, 0, 0.95);
        color: white;
        padding: 12px 16px;
        border-radius: 8px;
        font-size: 0.9375rem;
        white-space: nowrap;
        z-index: 999999;
        pointer-events: none;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        border: 1px solid rgba(255, 255, 255, 0.2);
        opacity: 0;
        transition: opacity 0.2s ease;
      }

      .custom-tooltip.visible {
        opacity: 1;
      }

      .custom-tooltip::after {
        content: '';
        position: absolute;
        top: 100%;
        left: 50%;
        transform: translateX(-50%);
        border: 5px solid transparent;
        border-top-color: rgba(0, 0, 0, 0.95);
      }

      .dot-class {
        background: #94a3b8; /* Gray - Class Scheduled */
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
      }

      .dot-payment {
        background: #22c55e; /* Green - Paid */
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
      }

      .dot-credit {
        background: #0ea5e9; /* Cyan - Paid via credit */
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
      }

      .dot-absent {
        background: #ffffff; /* White - Absent */
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
      }

      .dot-unpaid {
        background: #ef4444; /* Red - Unpaid */
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
      }

      .dot-partial {
        background: #f97316; /* Orange - Partial payment */
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        border: 1px solid #fb923c;
      }

      .dot-pending {
        background: #3b82f6; /* Blue - Future class with balance */
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
      }

      .dot-future {
        background: rgba(255, 255, 255, 0.15); /* Very light transparent - Future unpaid */
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
      }

      .dot-canceled {
        background: rgba(150, 150, 150, 0.4); /* Gray for canceled */
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        position: relative;
        border: 1px solid rgba(200, 200, 200, 0.5);
      }

      /* Scratch line for canceled classes */
      .dot-canceled::after {
        content: '';
        position: absolute;
        top: 50%;
        left: -2px;
        right: -2px;
        height: 1.5px;
        background: rgba(255, 255, 255, 0.9);
        transform: translateY(-50%) rotate(-45deg);
        pointer-events: none;
      }

      .dot-skipped {
        background: rgba(251, 146, 60, 0.6); /* Orange for skipped */
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        border: 1px solid rgba(251, 146, 60, 0.8);
      }

      /* Special Day States */
      .day.other-month {
        opacity: 0.3;
      }

      .day.today {
        background: var(--primary-gradient);
        border-color: transparent;
        box-shadow:
          0 0 25px rgba(38, 255, 230, 0.6),
          0 0 40px rgba(138, 77, 255, 0.4);
        transform: scale(1.05);
      }

      .day.today .day-number {
        color: #ffffff;
        font-weight: 800;
        font-size: 1.3rem;
        text-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
      }

      .day.today::before {
        opacity: 0;
      }

      .day.has-class {
        border-color: rgba(38, 255, 230, 0.4);
        background: rgba(38, 255, 230, 0.05);
      }

      .day.has-payment {
        border-color: rgba(16, 185, 129, 0.4);
        background: rgba(16, 185, 129, 0.05);
      }

      .day.skipped {
        background: rgba(100, 100, 100, 0.1);
        border-color: rgba(100, 100, 100, 0.3);
      }

      /* Legend */
      .legend {
        display: flex;
        justify-content: center;
        gap: 30px;
        margin-top: 30px;
        padding: 25px;
        background: var(--glass-bg);
        backdrop-filter: blur(var(--blur));
        border: 1px solid var(--glass-border);
        border-radius: var(--radius);
        flex-wrap: wrap;
        box-shadow: var(--shadow-glow);
      }

      .legend-item {
        display: flex;
        align-items: center;
        gap: 10px;
        font-size: 0.9rem;
        color: var(--text-secondary);
      }

      .legend-dot {
        width: 12px;
        height: 12px;
        border-radius: 50%;
      }

      /* Modal Styles */
      .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.85);
        backdrop-filter: blur(12px);
        -webkit-backdrop-filter: blur(12px);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 1000;
        animation: fadeIn 0.2s ease-out forwards;
      }

      .modal-overlay.active {
        display: flex;
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
        }
        to {
          opacity: 1;
        }
      }

      .modal {
        background: var(--glass-bg);
        backdrop-filter: blur(30px);
        -webkit-backdrop-filter: blur(30px);
        border: 1px solid var(--glass-border);
        border-radius: var(--radius);
        max-width: 600px;
        width: 90%;
        max-height: 80vh;
        overflow: hidden;
        box-shadow: var(--shadow-glow);
        transform: scale(0.9) translateY(20px);
        transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        position: relative;
      }

      .modal-overlay.active .modal {
        transform: scale(1) translateY(0);
      }

      .modal::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 3px;
        background: var(--primary-gradient);
      }

      .modal-header {
        padding: 30px 30px 20px;
        border-bottom: 1px solid var(--card-border);
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .modal-title {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      .modal-title h2 {
        font-size: 1.8rem;
        font-weight: 700;
        background: var(--primary-gradient);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        margin: 0;
      }

      .modal-subtitle {
        font-size: 0.9rem;
        color: var(--text-secondary);
      }

      .modal-close {
        width: 40px;
        height: 40px;
        border-radius: 12px;
        border: 1px solid var(--glass-border);
        background: var(--glass-bg);
        color: var(--text-primary);
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1.5rem;
        transition: var(--transition);
        flex-shrink: 0;
      }

      .modal-close:hover {
        background: var(--primary-gradient);
        border-color: transparent;
        color: #000;
        transform: rotate(90deg);
      }

      .modal-body {
        padding: 0;
        max-height: calc(80vh - 180px);
        overflow-y: auto;
        overflow-x: hidden;
        display: flex;
        flex-direction: column;
      }

      .modal-body::-webkit-scrollbar {
        width: 8px;
      }

      .modal-body::-webkit-scrollbar-track {
        background: rgba(255, 255, 255, 0.05);
        border-radius: 10px;
      }

      .modal-body::-webkit-scrollbar-thumb {
        background: var(--primary-gradient);
        border-radius: 10px;
      }

      /* Tabs */
      .modal-tabs {
        display: flex;
        gap: 8px;
        padding: 20px 30px 0 30px;
        border-bottom: 2px solid rgba(255, 255, 255, 0.1);
        overflow-x: auto;
        flex-shrink: 0;
      }

      .modal-tabs::-webkit-scrollbar {
        height: 4px;
      }

      .modal-tabs::-webkit-scrollbar-track {
        background: rgba(255, 255, 255, 0.05);
      }

      .modal-tabs::-webkit-scrollbar-thumb {
        background: rgba(138,180,255,0.3);
        border-radius: 2px;
      }

      .modal-tab {
        padding: 12px 20px;
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 12px 12px 0 0;
        color: rgba(255, 255, 255, 0.6);
        cursor: pointer;
        transition: all 0.3s ease;
        font-size: 14px;
        font-weight: 500;
        white-space: nowrap;
        position: relative;
      }

      .modal-tab:hover {
        background: rgba(255, 255, 255, 0.08);
        color: rgba(255, 255, 255, 0.8);
        border-color: rgba(138,180,255,0.3);
      }

      .modal-tab.active {
        background: linear-gradient(135deg, rgba(138,180,255,0.15) 0%, rgba(138,180,255,0.08) 100%);
        border-color: rgba(138,180,255,0.4);
        color: #fff;
      }

      .modal-tab.active::after {
        content: '';
        position: absolute;
        bottom: -2px;
        left: 0;
        right: 0;
        height: 2px;
        background: var(--primary-gradient);
      }

      .modal-tab-content {
        padding: 30px;
        overflow-y: auto;
        flex: 1;
      }

      .modal-tab-content::-webkit-scrollbar {
        width: 8px;
      }

      .modal-tab-content::-webkit-scrollbar-track {
        background: rgba(255, 255, 255, 0.05);
        border-radius: 10px;
      }

      .modal-tab-content::-webkit-scrollbar-thumb {
        background: var(--primary-gradient);
        border-radius: 10px;
      }

      .tab-panel {
        display: none;
      }

      .tab-panel.active {
        display: block;
      }

      .group-section {
        margin-bottom: 25px;
      }

      .group-section:last-child {
        margin-bottom: 0;
      }

      .group-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        margin-bottom: 15px;
        padding: 16px 20px;
        background: linear-gradient(135deg, rgba(138,180,255,0.12) 0%, rgba(138,180,255,0.06) 100%);
        border: 1px solid rgba(138,180,255,0.25);
        border-radius: 16px;
      }

      .group-header-content {
        display: flex;
        align-items: center;
        gap: 12px;
        flex: 1;
      }

      .group-header-actions {
        margin-left: 12px;
      }

      .group-icon {
        width: 40px;
        height: 40px;
        border-radius: 12px;
        background: var(--primary-gradient);
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1.2rem;
        color: #000;
      }

      .group-info h3 {
        font-size: 1.1rem;
        color: var(--text-primary);
        margin: 0 0 4px;
      }

      .group-time {
        font-size: 0.85rem;
        color: var(--text-secondary);
      }

      .students-list {
        display: flex;
        flex-direction: column;
        gap: 10px;
      }

      .student-card {
        background: rgba(255, 255, 255, 0.03);
        border: 1px solid var(--card-border);
        border-radius: 14px;
        padding: 16px 20px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        transition: all 0.3s ease;
        position: relative;
        overflow: hidden;
        gap: 10px;
      }

      .student-card::before {
        content: '';
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: var(--primary-gradient);
        opacity: 0.1;
        transition: left 0.3s ease;
      }

      .student-card:hover::before {
        left: 0;
      }

      .student-card:hover {
        border-color: var(--neon-cyan);
        transform: translateX(4px);
      }

      .student-info {
        display: flex;
        align-items: center;
        gap: 15px;
        flex: 1;
        min-width: 0;
      }

      .student-avatar {
        width: 45px;
        height: 45px;
        border-radius: 12px;
        background: var(--primary-gradient);
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1.1rem;
        font-weight: 700;
        color: #000;
      }

      .student-details {
        display: flex;
        flex-direction: column;
        flex: 1;
        min-width: 0;
      }

      .student-name {
        font-size: 1rem;
        font-weight: 600;
        color: var(--text-primary);
        margin-bottom: 4px;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        max-width: 100%;
      }

      .student-status {
        font-size: 0.8rem;
        color: var(--text-secondary);
      }

      .student-badges {
        display: flex;
        gap: 8px;
        align-items: center;
        flex-wrap: wrap;
      }

      .student-actions {
        display: flex;
        gap: 6px;
        margin-left: 0;
        flex-shrink: 0;
      }

      .action-icon-btn {
        width: 32px;
        height: 32px;
        border-radius: 8px;
        border: 1px solid var(--card-border);
        background: var(--card-bg);
        color: var(--text-primary);
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 0.9rem;
        transition: all 0.3s ease;
        position: relative;
        overflow: hidden;
      }

      .action-icon-btn::before {
        content: '';
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        opacity: 0.2;
        transition: left 0.3s ease;
      }

      .action-icon-btn.pause::before {
        background: linear-gradient(135deg, #f59e0b 0%, #f97316 100%);
      }

      .action-icon-btn.send::before {
        background: var(--accent-gradient);
      }

      .action-icon-btn.mark-paid::before {
        background: linear-gradient(135deg, #059669 0%, #047857 100%);
      }

      .action-icon-btn.send-email::before {
        background: linear-gradient(135deg, #10b981 0%, #059669 100%);
      }

      .action-icon-btn:hover::before {
        left: 0;
      }

      .action-icon-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 0 12px rgba(38, 255, 230, 0.3);
      }

      .action-icon-btn.pause:hover {
        border-color: rgba(245, 158, 11, 0.5);
      }

      .action-icon-btn.send:hover {
        border-color: var(--neon-cyan);
      }

      .action-icon-btn.mark-paid:hover {
        border-color: rgba(5, 150, 105, 0.6);
        box-shadow: 0 0 12px rgba(5, 150, 105, 0.4);
      }

      .action-icon-btn.send-email:hover {
        border-color: rgba(16, 185, 129, 0.6);
        box-shadow: 0 0 12px rgba(16, 185, 129, 0.5);
      }

      .action-icon-btn.paused {
        background: rgba(245, 158, 11, 0.2);
        border-color: rgba(245, 158, 11, 0.4);
      }

      .action-icon-btn:active {
        transform: translateY(0);
      }

      /* Tooltip for action buttons */
      .action-icon-btn[data-tooltip] {
        position: relative;
      }

      .action-icon-btn[data-tooltip]:hover::after {
        content: attr(data-tooltip);
        position: absolute;
        bottom: 100%;
        left: 50%;
        transform: translateX(-50%);
        margin-bottom: 8px;
        padding: 8px 12px;
        background: rgba(0, 0, 0, 0.95);
        color: white;
        font-size: 0.8125rem;
        white-space: nowrap;
        border-radius: 6px;
        border: 1px solid rgba(255, 255, 255, 0.2);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        z-index: 10000;
        pointer-events: none;
      }

      .action-icon-btn[data-tooltip]:hover::before {
        content: '';
        position: absolute;
        bottom: 100%;
        left: 50%;
        transform: translateX(-50%);
        margin-bottom: 2px;
        border: 5px solid transparent;
        border-top-color: rgba(0, 0, 0, 0.95);
        z-index: 10000;
        pointer-events: none;
      }

      .badge {
        padding: 6px 12px;
        border-radius: 8px;
        font-size: 0.75rem;
        font-weight: 600;
        display: flex;
        align-items: center;
        gap: 4px;
      }

      .badge.paid {
        background: rgba(16, 185, 129, 0.2);
        color: #34d399;
        border: 1px solid rgba(16, 185, 129, 0.3);
      }

      .badge.manual-paid {
        background: rgba(5, 150, 105, 0.25);
        color: #10b981;
        border: 1px solid rgba(5, 150, 105, 0.4);
        box-shadow: 0 0 8px rgba(5, 150, 105, 0.2);
      }

      .badge.unpaid {
        background: rgba(239, 68, 68, 0.2);
        color: #f87171;
        border: 1px solid rgba(239, 68, 68, 0.3);
      }

      .badge.absent {
        background: rgba(245, 158, 11, 0.2);
        color: #fbbf24;
        border: 1px solid rgba(245, 158, 11, 0.3);
      }

      .empty-state {
        text-align: center;
        padding: 40px 20px;
      }

      .empty-state-icon {
        font-size: 3rem;
        margin-bottom: 15px;
        opacity: 0.5;
      }

      .empty-state-text {
        color: var(--text-secondary);
        font-size: 1rem;
      }

      /* Student Details Modal */
      .student-modal {
        max-width: 500px;
      }

      .student-detail-section {
        margin-bottom: 20px;
      }

      .student-detail-section:last-child {
        margin-bottom: 0;
      }

      .section-label {
        font-size: 0.75rem;
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 1px;
        color: var(--text-secondary);
        margin-bottom: 8px;
      }

      .section-content {
        background: rgba(255, 255, 255, 0.03);
        border: 1px solid var(--card-border);
        border-radius: 12px;
        padding: 15px;
        font-size: 1rem;
        color: var(--text-primary);
      }

      .section-content.highlight {
        background: rgba(245, 158, 11, 0.15);
        border-color: rgba(245, 158, 11, 0.3);
      }

      .section-content.balance {
        background: rgba(245, 158, 11, 0.15);
        border-color: rgba(245, 158, 11, 0.3);
        font-size: 1.5rem;
        font-weight: 700;
      }

      .balance-note {
        font-size: 0.85rem;
        color: var(--text-secondary);
        margin-top: 6px;
        font-weight: 400;
      }

      /* Credit Modal Styles */
      .credit-summary {
        background: linear-gradient(135deg, rgba(34,197,94,0.12) 0%, rgba(34,197,94,0.06) 100%);
        border: 1px solid rgba(34,197,94,0.3);
        border-radius: 16px;
        padding: 20px;
        margin-bottom: 24px;
        display: flex;
        align-items: center;
        justify-content: space-between;
      }

      .credit-summary-info h3 {
        font-size: 1rem;
        font-weight: 600;
        color: var(--text-primary);
        margin: 0 0 8px 0;
      }

      .credit-summary-info p {
        font-size: 0.9rem;
        color: var(--text-secondary);
        margin: 0;
      }

      .credit-summary-total {
        font-size: 2rem;
        font-weight: 700;
        background: linear-gradient(135deg, #22c55e 0%, #10b981 100%);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
      }

      .credit-student-list {
        display: flex;
        flex-direction: column;
        gap: 16px;
      }

      .credit-student-card {
        background: rgba(255, 255, 255, 0.03);
        border: 1px solid var(--card-border);
        border-radius: 14px;
        padding: 18px;
        transition: var(--transition);
      }

      .credit-student-card:hover {
        background: rgba(255, 255, 255, 0.05);
        border-color: rgba(138,180,255,0.3);
      }

      .credit-student-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 12px;
      }

      .credit-student-name {
        font-size: 1.1rem;
        font-weight: 600;
        color: var(--text-primary);
      }

      .credit-student-total {
        font-size: 1.2rem;
        font-weight: 700;
        color: #22c55e;
      }

      .credit-payment-list {
        display: flex;
        flex-direction: column;
        gap: 8px;
        margin-left: 12px;
      }

      .credit-payment-item {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 10px 14px;
        background: rgba(255, 255, 255, 0.02);
        border: 1px solid rgba(255, 255, 255, 0.05);
        border-radius: 10px;
        font-size: 0.9rem;
      }

      .credit-payment-date {
        color: var(--text-secondary);
      }

      .credit-payment-amount {
        font-weight: 600;
        color: var(--text-primary);
      }

      .modal-footer .btn-secondary:hover {
        background: rgba(255, 255, 255, 0.1);
        border-color: rgba(138,180,255,0.3);
      }

      .modal-footer .btn-primary:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 24px rgba(138,180,255,0.3);
      }

      .quick-actions-grid {
        display: flex;
        gap: 12px;
        margin-top: 20px;
        justify-content: center;
        align-items: center;
      }

      .quick-action-btn {
        width: 60px;
        height: 60px;
        border-radius: 16px;
        border: none;
        background: #3a3a3c;
        color: white;
        font-size: 24px;
        cursor: pointer;
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        position: relative;
      }

      .quick-action-btn.pause {
        background: #3a3a3c;
      }

      .quick-action-btn.forward {
        background: #3a3a3c;
      }

      .quick-action-btn.email-reminder {
        background: #fbbf24;
        color: #000;
        font-weight: bold;
      }

      .quick-action-btn.tertiary {
        background: #3a3a3c;
      }

      .quick-action-btn.payment {
        background: #3a3a3c;
      }

      .quick-action-btn.secondary {
        background: #3a3a3c;
        width: auto;
        padding: 0 20px;
        font-size: 14px;
      }

      .quick-action-btn:hover {
        transform: scale(1.05);
        opacity: 0.9;
      }

      .quick-action-btn:active {
        transform: scale(0.95);
      }

      .student-name-clickable {
        cursor: pointer;
        transition: color 0.2s ease;
      }

      .student-name-clickable:hover {
        color: var(--neon-cyan);
        text-shadow: 0 0 8px rgba(38, 255, 230, 0.6);
      }

      /* Payment Allocation Review UI */
      .payment-review-banner {
        margin: 24px 0 10px;
        padding: 18px 24px;
        border-radius: 20px;
        border: 1px solid rgba(250, 204, 21, 0.45);
        background: linear-gradient(120deg, rgba(250, 204, 21, 0.12), rgba(249, 115, 22, 0.1));
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 18px;
        box-shadow: 0 18px 30px rgba(0, 0, 0, 0.35);
      }

      .payment-review-banner.hidden {
        display: none;
      }

      .payment-review-banner .banner-left {
        display: flex;
        align-items: center;
        gap: 16px;
      }

      .payment-review-banner .banner-icon {
        font-size: 1.8rem;
      }

      .payment-review-chip {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 4px 12px;
        border-radius: 999px;
        background: rgba(250, 204, 21, 0.2);
        color: #d97706;
        font-size: 0.75rem;
        letter-spacing: 0.04em;
        text-transform: uppercase;
        font-weight: 700;
      }

      .payment-review-banner h4 {
        margin: 4px 0;
        font-size: 1.1rem;
        color: var(--text-primary);
      }

      .payment-review-subtitle {
        font-size: 0.9rem;
        color: rgba(255, 255, 255, 0.75);
      }

      .payment-review-banner .banner-actions {
        display: flex;
        align-items: center;
        gap: 12px;
      }

      .payment-review-btn {
        padding: 10px 20px;
        border-radius: 12px;
        border: none;
        font-weight: 600;
        cursor: pointer;
        transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
        white-space: nowrap;
      }

      .payment-review-btn.primary {
        background: linear-gradient(135deg, #f97316, #facc15);
        color: #0b0f17;
        box-shadow: 0 10px 25px rgba(249, 115, 22, 0.35);
      }

      .payment-review-btn.secondary {
        background: transparent;
        border: 1px solid rgba(255, 255, 255, 0.35);
        color: var(--text-primary);
      }

      .payment-review-btn:hover {
        transform: translateY(-1px);
      }

      .payment-review-scrim {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.6);
        backdrop-filter: blur(6px);
        z-index: 1500;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.25s ease;
      }

      .payment-review-scrim.visible {
        opacity: 1;
        pointer-events: all;
      }

      .payment-review-drawer {
        position: fixed;
        top: 0;
        right: -480px;
        width: min(420px, 92vw);
        height: 100vh;
        background: rgba(10, 14, 25, 0.96);
        border-left: 1px solid rgba(250, 204, 21, 0.2);
        box-shadow: -20px 0 40px rgba(0, 0, 0, 0.4);
        z-index: 1550;
        transition: right 0.35s cubic-bezier(0.4, 0, 0.2, 1);
        display: flex;
        flex-direction: column;
      }

      .payment-review-drawer.open {
        right: 0;
      }

      .payment-review-header {
        padding: 28px;
        border-bottom: 1px solid rgba(255, 255, 255, 0.08);
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        gap: 16px;
      }

      .payment-review-header h3 {
        margin: 0 0 6px 0;
        font-size: 1.3rem;
        color: var(--text-primary);
      }

      .payment-review-header p {
        margin: 0;
        color: rgba(255, 255, 255, 0.7);
        font-size: 0.9rem;
      }

      .payment-review-controls {
        padding: 0 28px 20px;
        border-bottom: 1px solid rgba(255, 255, 255, 0.08);
        display: flex;
        flex-direction: column;
        gap: 14px;
      }

      .payment-review-search {
        width: 100%;
        padding: 12px 16px;
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.15);
        background: rgba(255, 255, 255, 0.04);
        color: var(--text-primary);
        font-size: 0.95rem;
      }

      .payment-review-inline-stats {
        display: flex;
        justify-content: space-between;
        font-size: 0.9rem;
        color: rgba(255, 255, 255, 0.7);
      }

      .payment-review-list {
        padding: 24px 28px;
        overflow-y: auto;
        flex: 1;
      }

      .payment-review-card {
        border: 1px solid rgba(250, 204, 21, 0.25);
        border-radius: 16px;
        padding: 16px;
        margin-bottom: 18px;
        background: rgba(255, 255, 255, 0.03);
      }

      .payment-review-card h4 {
        margin: 0 0 4px 0;
        font-size: 1rem;
      }

      .payment-review-card small {
        color: rgba(255, 255, 255, 0.6);
      }

      .payment-review-payments {
        margin-top: 12px;
        display: flex;
        flex-direction: column;
        gap: 10px;
      }

      .payment-review-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 12px;
        padding: 10px 0;
        border-top: 1px solid rgba(255, 255, 255, 0.08);
      }

      .payment-review-row:first-child {
        border-top: none;
        padding-top: 0;
      }

      .payment-review-row span {
        font-size: 0.9rem;
      }

      .payment-review-actions {
        display: flex;
        gap: 8px;
      }

      .allocation-action {
        padding: 6px 10px;
        font-size: 0.8rem;
        border-radius: 8px;
        border: 1px solid transparent;
        background: rgba(255, 255, 255, 0.06);
        color: var(--text-primary);
        cursor: pointer;
      }

      .allocation-action.credit {
        border-color: rgba(6, 182, 212, 0.6);
        color: #5eead4;
      }

      .allocation-action.dismiss {
        border-color: rgba(239, 68, 68, 0.6);
        color: #fca5a5;
      }

      .allocation-action:hover {
        background: rgba(255, 255, 255, 0.1);
      }

      .payment-review-empty {
        margin-top: 40px;
        text-align: center;
        color: rgba(255, 255, 255, 0.5);
        font-size: 0.95rem;
      }

      .payment-review-header-actions {
        display: flex;
        gap: 10px;
      }

      .payment-review-close,
      .payment-review-reset {
        border: 1px solid rgba(255, 255, 255, 0.2);
        background: transparent;
        color: var(--text-primary);
        border-radius: 10px;
        padding: 8px 12px;
        cursor: pointer;
        font-weight: 600;
      }

      .payment-review-close {
        font-size: 1.1rem;
      }

      @media (max-width: 768px) {
        .payment-review-banner {
          flex-direction: column;
          align-items: flex-start;
        }

        .payment-review-banner .banner-actions {
          width: 100%;
          justify-content: flex-start;
          flex-wrap: wrap;
        }
      }

      /* Loading Animation */
      @keyframes pulse {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.5;
        }
      }

      .loading .day {
        animation: pulse 1.5s ease-in-out infinite;
      }

      /* Responsive Design */
      @media (max-width: 1024px) {
        .container {
          grid-template-columns: 1fr;
        }

        .sidebar {
          position: relative;
          top: 0;
        }
      }

      @media (max-width: 768px) {
        .calendar-header {
          flex-direction: column;
          gap: 20px;
          padding: 20px;
        }

        .month-year h1 {
          font-size: 1.8rem;
        }

        .calendar-grid {
          padding: 15px;
        }

        .day-number {
          font-size: 1rem;
        }

        .legend {
          gap: 15px;
        }

        .stats-grid {
          grid-template-columns: 1fr;
        }
      }

      /* Fade-in animation */
      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: translateY(20px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .day:nth-child(1) {
        animation-delay: 0.05s;
      }
      .day:nth-child(2) {
        animation-delay: 0.1s;
      }
      .day:nth-child(3) {
        animation-delay: 0.15s;
      }
      .day:nth-child(4) {
        animation-delay: 0.2s;
      }
      .day:nth-child(5) {
        animation-delay: 0.25s;
      }
      .day:nth-child(6) {
        animation-delay: 0.3s;
      }
      .day:nth-child(7) {
        animation-delay: 0.35s;
      }
    </style>
  </head>
  <body>
    <!-- Floating Toggle Button -->
    <button class="floating-toggle" id="floatingToggle">
      <span class="toggle-icon">›</span>
    </button>

    <div class="container">
      <!-- Main Calendar Area -->
      <div class="calendar-wrapper">
        <!-- Header -->
        <div class="calendar-header">
          <div class="month-year">
            <div style="display: flex; align-items: center; gap: 20px">
              <h1 id="currentMonth">November</h1>
              <span class="year-badge" id="currentYear">2025</span>
            </div>
            <div class="calendar-stats" id="calendarStats">
              <span id="activeStudentsCount">44 active students</span>
              <span>•</span>
              <span id="scheduledClassesCount">391 scheduled classes</span>
              <span class="stat-divider">|</span>
              <span class="stat-paid" id="monthPaid">💰 15,975 $ paid</span>
              <span class="stat-divider">|</span>
              <span class="stat-pending" id="monthPending">⚠️ 1,025 $ pending</span>
            </div>
          </div>
          <div class="nav-controls">
            <button class="nav-btn" id="prevMonth" title="Previous Month">‹</button>
            <button class="today-btn" id="todayBtn">Today</button>
            <button class="nav-btn" id="nextMonth" title="Next Month">›</button>
            <button class="notification-bell" id="creditNotificationBell" title="Excess payment notifications">
              <svg viewBox="0 0 24 24">
                <path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"></path>
                <path d="M13.73 21a2 2 0 0 1-3.46 0"></path>
              </svg>
              <span class="notification-badge" id="creditNotificationBadge" style="display: none;">0</span>
            </button>
          </div>
        </div>

        <div class="payment-review-banner hidden" id="paymentReviewBanner">
          <div class="banner-left">
            <div class="banner-icon">⚠️</div>
            <div>
              <div class="payment-review-chip">Needs review</div>
              <h4>
                <span id="paymentReviewCount">0</span>
                pending payment<span id="paymentReviewPlural">s</span>
                ·
                <span id="paymentReviewTotal">0</span> $
              </h4>
              <div class="payment-review-subtitle" id="paymentReviewSummary">
                We couldn’t auto-match these payments between Nov 1 and today.
              </div>
            </div>
          </div>
          <div class="banner-actions">
            <button class="payment-review-btn primary" id="paymentReviewBannerBtn">Review now</button>
            <button class="payment-review-btn secondary" id="paymentReviewExportBtn">Export CSV</button>
          </div>
        </div>

        <!-- Calendar Grid -->
        <div class="calendar-grid">
          <!-- Weekday Headers -->
          <div class="weekdays">
            <div class="weekday">Sun</div>
            <div class="weekday">Mon</div>
            <div class="weekday">Tue</div>
            <div class="weekday">Wed</div>
            <div class="weekday">Thu</div>
            <div class="weekday">Fri</div>
            <div class="weekday">Sat</div>
          </div>

          <!-- Days -->
          <div class="days" id="calendarDays"></div>
        </div>

        <!-- Legend -->
        <div class="legend">
          <div class="legend-item">
            <div class="legend-dot dot-class"></div>
            <span>Class Scheduled</span>
          </div>
          <div class="legend-item">
            <div class="legend-dot dot-payment"></div>
            <span>Paid</span>
          </div>
          <div class="legend-item">
            <div class="legend-dot dot-credit"></div>
            <span>Credit Used</span>
          </div>
          <div class="legend-item">
            <div class="legend-dot dot-unpaid"></div>
            <span>Unpaid</span>
          </div>
          <div class="legend-item">
            <div class="legend-dot dot-partial"></div>
            <span>Partial Payment</span>
          </div>
          <div class="legend-item">
            <div class="legend-dot dot-absent"></div>
            <span>Absent</span>
          </div>
          <div class="legend-item">
            <div class="legend-dot dot-skipped"></div>
            <span>Class Skipped</span>
          </div>
          <div class="legend-item">
            <div class="legend-dot dot-canceled"></div>
            <span>Class Canceled</span>
          </div>
          <div class="legend-item">
            <div class="legend-dot" style="background: linear-gradient(135deg, #26ffe6, #8a4dff)"></div>
            <span>Today</span>
          </div>
        </div>
      </div>

      <!-- Sidebar -->
      <div class="sidebar" id="sidebar">
        <button class="sidebar-toggle" id="sidebarToggle">
          <span class="toggle-icon">›</span>
        </button>

        <div class="sidebar-content">
          <!-- Stats Section -->
          <div class="sidebar-section">
            <h3 class="sidebar-title">Overview</h3>
            <div class="stats-grid">
              <div class="stat-card">
                <span class="stat-number" id="totalClasses">12</span>
                <span class="stat-label">Classes</span>
              </div>
              <div class="stat-card">
                <span class="stat-number" id="totalPayments">8</span>
                <span class="stat-label">Payments</span>
              </div>
              <div class="stat-card">
                <span class="stat-number" id="totalAbsences">3</span>
                <span class="stat-label">Absences</span>
              </div>
              <div class="stat-card">
                <span class="stat-number" id="totalSkipped">2</span>
                <span class="stat-label">Skipped</span>
              </div>
            </div>
          </div>

          <!-- Filters Section -->
          <div class="sidebar-section">
            <h3 class="sidebar-title">Filters</h3>
            <div class="filter-group">
              <div class="filter-item active" data-filter="classes">
                <div class="filter-label">
                  <div class="filter-checkbox"></div>
                  <span>Show Classes</span>
                </div>
                <span class="filter-count">12</span>
              </div>
              <div class="filter-item active" data-filter="payments">
                <div class="filter-label">
                  <div class="filter-checkbox"></div>
                  <span>Show Payments</span>
                </div>
                <span class="filter-count">8</span>
              </div>
              <div class="filter-item active" data-filter="absences">
                <div class="filter-label">
                  <div class="filter-checkbox"></div>
                  <span>Show Absences</span>
                </div>
                <span class="filter-count">3</span>
              </div>
              <div class="filter-item active" data-filter="skipped">
                <div class="filter-label">
                  <div class="filter-checkbox"></div>
                  <span>Show Skipped</span>
                </div>
                <span class="filter-count">2</span>
              </div>
            </div>
          </div>

          <!-- Upcoming and Unpaid Alerts -->
          <div class="sidebar-section">
            <h3 class="sidebar-title">Upcoming Classes</h3>
            <div class="insight-list" id="upcomingClassesList">
              <div class="insight-empty">No future classes in view</div>
            </div>
          </div>

          <div class="sidebar-section">
            <h3 class="sidebar-title">Unpaid Alerts</h3>
            <div class="insight-list" id="unpaidClassesList">
              <div class="insight-empty">No unpaid classes in view</div>
            </div>
          </div>

          <!-- Quick Actions Section -->
          <div class="sidebar-section">
            <h3 class="sidebar-title">Quick Actions</h3>
            <div class="quick-actions">
              <button class="action-btn">📅 Add Event</button>
              <button class="action-btn">💰 Record Payment</button>
              <button class="action-btn">📊 View Reports</button>
              <button class="action-btn">⚙️ Settings</button>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Modal -->
    <div class="modal-overlay" id="dayModal">
      <div class="modal">
        <div class="modal-header">
          <div class="modal-title">
            <h2 id="modalDate">November 20, 2025</h2>
            <span class="modal-subtitle" id="modalDayOfWeek">Wednesday</span>
          </div>
          <button class="modal-close" id="closeModal">×</button>
        </div>
        <div class="modal-body" id="modalBody">
          <!-- Content will be dynamically inserted here -->
        </div>
      </div>
    </div>

    <!-- Credit Confirmation Modal -->
    <div class="modal-overlay" id="creditModal">
      <div class="modal" style="max-width: 700px;">
        <div class="modal-header">
          <div class="modal-title">
            <h2>💳 Excess Payments Detected</h2>
            <span class="modal-subtitle">Students paid more than their scheduled classes</span>
          </div>
          <button class="modal-close" id="closeCreditModal">×</button>
        </div>
        <div class="modal-body" id="creditModalBody" style="max-height: calc(80vh - 240px);">
          <!-- Content will be dynamically inserted here -->
        </div>
        <div class="modal-footer" style="padding: 20px 30px; border-top: 1px solid var(--card-border); display: flex; gap: 12px; justify-content: space-between;">
          <button class="btn-danger" id="skipAllCreditBtn" style="padding: 12px 24px; border-radius: 12px; border: 1px solid #ff4757; background: rgba(255, 71, 87, 0.1); color: #ff4757; cursor: pointer; font-weight: 600; transition: var(--transition);">
            Skip All
          </button>
          <div style="display: flex; gap: 12px;">
            <button class="btn-secondary" id="cancelCreditBtn" style="padding: 12px 24px; border-radius: 12px; border: 1px solid var(--glass-border); background: var(--glass-bg); color: var(--text-primary); cursor: pointer; font-weight: 600; transition: var(--transition);">
              Skip Student
            </button>
            <button class="btn-primary" id="applyCreditBtn" style="padding: 12px 24px; border-radius: 12px; border: none; background: var(--primary-gradient); color: #000; cursor: pointer; font-weight: 600; transition: var(--transition);">
              Confirm
            </button>
          </div>
        </div>
      </div>
    </div>

    <!-- Confirm Modal -->
    <div class="modal-overlay" id="confirmModal" style="display: none;">
      <div class="modal" style="max-width: 500px;">
        <div class="modal-header">
          <div class="modal-title">
            <h2 id="confirmTitle">Confirm</h2>
          </div>
          <button class="modal-close" id="closeConfirmModal">×</button>
        </div>
        <div class="modal-body" id="confirmMessage" style="padding: 30px;">
          <!-- Content will be dynamically inserted here -->
        </div>
        <div class="modal-footer" style="padding: 20px 30px; border-top: 1px solid var(--card-border); display: flex; gap: 12px; justify-content: flex-end;">
          <button class="btn-secondary" id="cancelBtn" style="padding: 12px 24px; border-radius: 12px; border: 1px solid var(--glass-border); background: var(--glass-bg); color: var(--text-primary); cursor: pointer; font-weight: 600; transition: var(--transition);">
            Cancel
          </button>
          <button class="btn-primary" id="confirmBtn" style="padding: 12px 24px; border-radius: 12px; border: none; background: var(--primary-gradient); color: #000; cursor: pointer; font-weight: 600; transition: var(--transition);">
            Confirm
          </button>
        </div>
      </div>
    </div>

    <div class="payment-review-scrim" id="paymentReviewScrim"></div>
    <aside class="payment-review-drawer" id="paymentReviewDrawer" aria-hidden="true">
      <div class="payment-review-header">
        <div>
          <h3>Payment allocation review</h3>
          <p id="paymentReviewDrawerSubtitle">Tell us what to do with uncertain payments.</p>
        </div>
        <div class="payment-review-header-actions">
          <button class="payment-review-reset" id="paymentReviewResetBtn" title="Bring back dismissed items">Reset hidden</button>
          <button class="payment-review-close" id="paymentReviewCloseBtn" aria-label="Close review drawer">×</button>
        </div>
      </div>
      <div class="payment-review-controls">
        <input
          type="search"
          class="payment-review-search"
          id="paymentReviewSearch"
          placeholder="Search by student, date, amount, or memo"
        />
        <div class="payment-review-inline-stats">
          <span id="paymentReviewDrawerCount">0 pending</span>
          <span id="paymentReviewDrawerTotal">0 $ unresolved</span>
        </div>
      </div>
      <div class="payment-review-list" id="paymentReviewList">
        <div class="payment-review-empty">You're all caught up 🙌</div>
      </div>
    </aside>

    <script>
      // Calendar State
      let currentDate = new Date();
      const monthNames = [
        'January',
        'February',
        'March',
        'April',
        'May',
        'June',
        'July',
        'August',
        'September',
        'October',
        'November',
        'December',
      ];
      const CALENDAR_START_DATE_STR = '2025-11-01';
      const CALENDAR_START_DATE = createDateFromDateStr(CALENDAR_START_DATE_STR);

      const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];

      const EVENT_STYLE_MAP = {
        class: {
          dotClass: 'dot-class',
          icon: '📘',
          accent: 'linear-gradient(135deg, #a855f7 0%, #9333ea 100%)',
        },
        payment: {
          dotClass: 'dot-payment',
          icon: '💵',
          accent: 'linear-gradient(135deg, #22c55e 0%, #4ade80 100%)',
        },
        credit: {
          dotClass: 'dot-credit',
          icon: '💳',
          accent: 'linear-gradient(135deg, #06b6d4 0%, #3b82f6 100%)',
        },
        studentJoin: {
          dotClass: 'dot-student',
          icon: '🧑‍🎓',
          accent: 'linear-gradient(135deg, #38bdf8 0%, #818cf8 100%)',
        },
        studentStatus: {
          dotClass: 'dot-status',
          icon: '🔁',
          accent: 'linear-gradient(135deg, #f97316 0%, #fb923c 100%)',
        },
        studentBirthday: {
          dotClass: 'dot-birthday',
          icon: '🎂',
          accent: 'linear-gradient(135deg, #f472b6 0%, #fb7185 100%)',
        },
      };

      let calendarBaseEvents = [];
      let currentMonthEventMap = {};
      let currentMonthEventsFlat = [];
      let lastMergedEventsCount = 0;

      const LA_TIMEZONE = 'America/Los_Angeles';
      const laDateTimeFormatter = new Intl.DateTimeFormat('en-US', {
        timeZone: LA_TIMEZONE,
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
        weekday: 'long',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        hour12: false,
      });
      const laHumanDateFormatter = new Intl.DateTimeFormat('en-US', {
        timeZone: LA_TIMEZONE,
        month: 'long',
        day: 'numeric',
        year: 'numeric',
      });
      const laWeekdayFormatter = new Intl.DateTimeFormat('en-US', {
        timeZone: LA_TIMEZONE,
        weekday: 'long',
      });
      const laTimeFormatter = new Intl.DateTimeFormat('en-US', {
        timeZone: LA_TIMEZONE,
        hour: 'numeric',
        minute: '2-digit',
        hour12: true,
      });

      function getLAParts(dateInput) {
        const date = dateInput instanceof Date ? dateInput : new Date(dateInput);
        if (isNaN(date.getTime())) return null;
        const parts = {};
        laDateTimeFormatter.formatToParts(date).forEach(part => {
          parts[part.type] = part.value;
        });
        return parts;
      }

      function getLAWeekdayName(dateInput) {
        const date = dateInput instanceof Date ? dateInput : new Date(dateInput);
        if (isNaN(date.getTime())) return '';
        return laWeekdayFormatter.format(date);
      }

      function getLAWeekdayIndex(dateInput) {
        const name = getLAWeekdayName(dateInput);
        if (!name) return null;
        const idx = dayNames.indexOf(name);
        return idx === -1 ? null : idx;
      }

      function formatHumanDateInLA(dateInput) {
        const date = dateInput instanceof Date ? dateInput : new Date(dateInput);
        if (isNaN(date.getTime())) return '';
        return laHumanDateFormatter.format(date);
      }

      function formatTimeInLA(dateInput) {
        const date = dateInput instanceof Date ? dateInput : new Date(dateInput);
        if (isNaN(date.getTime())) return '';
        return laTimeFormatter.format(date);
      }

      // Alias for compatibility
      function formatDateNice(dateStr) {
        if (!dateStr) return '';
        // Handle YYYY-MM-DD format
        const date = dateStr.includes('-') ? new Date(dateStr + 'T12:00:00') : new Date(dateStr);
        return formatHumanDateInLA(date);
      }

      function parseTimeToMinutes(timeStr) {
        if (!timeStr || typeof timeStr !== 'string') return 0;
        const match = timeStr.trim().match(/^(\d{1,2}):(\d{2})\s*(AM|PM)$/i);
        if (!match) return 0;
        let hours = Number(match[1]) % 12;
        const minutes = Number(match[2]) || 0;
        const period = match[3].toUpperCase();
        if (period === 'PM') {
          hours += 12;
        }
        return hours * 60 + minutes;
      }

      function normalizeDateInput(value) {
        if (!value) return '';
        if (typeof value === 'string') {
          const trimmed = value.trim();
          // If already in YYYY-MM-DD format, return as-is
          if (/^\d{4}-\d{2}-\d{2}$/.test(trimmed)) {
            return trimmed;
          }
        }
        // Convert to LA timezone before formatting
        // This ensures UTC timestamps are converted to LA dates
        return formatDateYYYYMMDD(value);
      }

      function createDateFromParts(year, monthIndex, day) {
        return new Date(Date.UTC(year, monthIndex, day, 12, 0, 0));
      }

      function createDateFromDateStr(dateStr) {
        const parts = parseDateParts(dateStr);
        if (!parts) return null;
        return createDateFromParts(parts.year, parts.month - 1, parts.day);
      }

      function getTodayLAParts() {
        return getLAParts(new Date());
      }

      function syncCurrentDateToLAToday() {
        const todayParts = getTodayLAParts();
        if (todayParts) {
          currentDate = createDateFromParts(
            Number(todayParts.year),
            Number(todayParts.month) - 1,
            Number(todayParts.day)
          );
        }
      }

      function getCurrentViewYearMonth() {
        const parts = getLAParts(currentDate);
        if (parts) {
          return { year: Number(parts.year), month: Number(parts.month) - 1 };
        }
        return { year: currentDate.getFullYear(), month: currentDate.getMonth() };
      }

      function shiftCurrentView(deltaMonths) {
        const { year, month } = getCurrentViewYearMonth();
        let newMonth = month + deltaMonths;
        let newYear = year;
        while (newMonth < 0) {
          newMonth += 12;
          newYear -= 1;
        }
        while (newMonth > 11) {
          newMonth -= 12;
          newYear += 1;
        }
        currentDate = createDateFromParts(newYear, newMonth, 1);
      }

      function ensureAMPMFormatLocal(timeStr) {
        if (!timeStr) return '';
        if (/AM|PM/i.test(timeStr)) return timeStr;

        const match = timeStr.match(/^(\d{1,2}):(\d{2})$/);
        if (!match) return timeStr;

        let hours = parseInt(match[1], 10);
        const minutes = match[2];
        const period = hours >= 12 ? 'PM' : 'AM';

        if (hours > 12) hours -= 12;
        if (hours === 0) hours = 12;

        return `${hours}:${minutes} ${period}`;
      }

      function parseScheduleString(scheduleStr) {
        if (scheduleStr == null) {
          return [];
        }

        if (typeof scheduleStr !== 'string') {
          // console.warn('Invalid schedule string:', scheduleStr);
          return [];
        }

        const rawInput = scheduleStr.trim();
        if (!rawInput) {
          return [];
        }

        // Some data sources use placeholder dashes or terms like "TBD" when no schedule exists.
  if (/^[-–—]+$/.test(rawInput) || /^(?:n[\/\.\s]?a|none|null|tbd|tba)$/i.test(rawInput)) {
          return [];
        }

        const sessions = [];
        
        // Normalize input: trim, handle various separators
        const normalizedSchedule = rawInput
          .replace(/\s*;\s*/g, ',')  // Handle semicolon separators
          .replace(/\s+/g, ' ');      // Normalize whitespace
          
        const parts = normalizedSchedule
          .split(',')
          .map(p => p.trim())
          .filter(Boolean);

        if (!parts.length) {
          return [];
        }

        const normalizeDay = day => {
          if (!day) return '';
          const cleaned = day.trim().toLowerCase().replace(/[^a-z]/g, '');
          const map = {
            sun: 'Sunday',
            sunday: 'Sunday',
            mon: 'Monday',
            monday: 'Monday',
            tue: 'Tuesday',
            tues: 'Tuesday',
            tuesday: 'Tuesday',
            wed: 'Wednesday',
            weds: 'Wednesday',
            wednesday: 'Wednesday',
            thu: 'Thursday',
            thur: 'Thursday',
            thurs: 'Thursday',
            thursday: 'Thursday',
            fri: 'Friday',
            friday: 'Friday',
            sat: 'Saturday',
            saturday: 'Saturday',
          };
          return map[cleaned] || '';
        };

        parts.forEach(part => {
          // More flexible regex to handle various formats
          const match = part.match(/^([A-Za-z/]+)\s+(.+)$/);
          if (!match) {
            // console.warn('Failed to parse schedule part:', part);
            return;
          }

          const daySegment = match[1];
          const timeSegment = ensureAMPMFormatLocal(match[2]);

          if (!timeSegment) {
            // console.warn('Failed to parse time:', match[2]);
            return;
          }

          daySegment.split('/').forEach(day => {
            const fullDay = normalizeDay(day);
            if (fullDay) {
              sessions.push({ day: fullDay, time: timeSegment });
            } else {
              // console.warn('Unrecognized day name:', day);
            }
          });
        });

        return sessions;
      }

      function parseDateParts(dateStr) {
        if (!dateStr || typeof dateStr !== 'string') return null;
        const match = dateStr.match(/^(\d{4})-(\d{2})-(\d{2})$/);
        if (!match) return null;
        return {
          year: Number(match[1]),
          month: Number(match[2]),
          day: Number(match[3]),
        };
      }

      function formatDateYYYYMMDD(dateInput) {
        // Match the working index.html: use toISOString().split('T')[0]
        // This extracts the UTC date part which is already LA time (due to -12hr offset)
        const date = dateInput instanceof Date ? dateInput : new Date(dateInput);
        if (isNaN(date.getTime())) return '';
        
        return date.toISOString().split('T')[0];
      }

      const monthCache = new Map();

      // ARNOMA rule: only consider classes/payments occurring on/after Nov 1, 2025 unless overridden.
      const COVERAGE_WINDOW_START =
        window.arnomaCoverageWindowStart || window.COVERAGE_WINDOW_START || '2025-11-01';

      function isWithinCoverageWindow(dateStr) {
        if (!dateStr || !COVERAGE_WINDOW_START) return false;
        return dateStr >= COVERAGE_WINDOW_START;
      }

      const PAYMENT_ALLOCATION_RESOLUTIONS_KEY = 'arnoma.paymentAllocationResolutions.v1';
      let paymentAllocationResolutionsCache = null;

      function loadPaymentAllocationResolutions() {
        if (paymentAllocationResolutionsCache) return paymentAllocationResolutionsCache;
        if (typeof localStorage === 'undefined') {
          paymentAllocationResolutionsCache = {};
          return paymentAllocationResolutionsCache;
        }
        try {
          const raw = localStorage.getItem(PAYMENT_ALLOCATION_RESOLUTIONS_KEY);
          paymentAllocationResolutionsCache = raw ? JSON.parse(raw) : {};
        } catch (error) {
          // console.warn('Unable to read payment allocation resolutions from localStorage', error);
          paymentAllocationResolutionsCache = {};
        }
        return paymentAllocationResolutionsCache;
      }

      function savePaymentAllocationResolutions(resolutions) {
        paymentAllocationResolutionsCache = resolutions;
        if (typeof localStorage === 'undefined') return;
        try {
          localStorage.setItem(PAYMENT_ALLOCATION_RESOLUTIONS_KEY, JSON.stringify(resolutions));
        } catch (error) {
          // console.warn('Unable to persist payment allocation resolutions', error);
        }
      }

      function resetPaymentAllocationResolutions() {
        savePaymentAllocationResolutions({});
      }

      function canonicalizeGroupCode(value) {
        if (!value) return '';
        const raw = value.toString().trim();
        if (!raw) return '';
        const withoutPrefix = raw.replace(/^group\s+/i, '');
        const normalized = withoutPrefix.replace(/[^a-z0-9]/gi, '').toUpperCase();
        return normalized;
      }

      function formatGroupDisplay(code) {
        if (!code) return 'No Group';
        return `Group ${code}`;
      }

      function buildPaymentAllocationKey(entry) {
        if (!entry) return 'unknown-allocation';
        const pieces = [
          entry.paymentId || entry.id || 'payment',
          entry.studentId || entry.studentName || 'student',
          entry.payDate || 'date',
          Number(entry.amount || 0).toFixed(2),
        ];
        return pieces.join('|');
      }

      function markPaymentAllocationResolution(entry, action = 'acknowledged', note = '') {
        if (!entry) return;
        const key = buildPaymentAllocationKey(entry);
        const existing = loadPaymentAllocationResolutions();
        existing[key] = {
          action,
          note,
          resolvedAt: new Date().toISOString(),
        };
        savePaymentAllocationResolutions(existing);
      }

      function filterResolvedPaymentAllocations(entries) {
        if (!Array.isArray(entries) || !entries.length) return [];
        const resolutions = loadPaymentAllocationResolutions();
        return entries.filter(entry => {
          const key = buildPaymentAllocationKey(entry);
          return !resolutions[key];
        });
      }

      function getMonthCacheKey(year, month) {
        return `${year}-${String(month + 1).padStart(2, '0')}`;
      }

      function clearMonthCache() {
        monthCache.clear();
      }

      function getMonthData(year, month) {
        const cacheKey = getMonthCacheKey(year, month);
        if (monthCache.has(cacheKey)) {
          return monthCache.get(cacheKey);
        }

        const computed = computeMonthData(year, month);
        monthCache.set(cacheKey, computed);
        return computed;
      }

      function computeMonthData(year, month) {
        const cacheKey = getMonthCacheKey(year, month);
        const label = `${monthNames[month]} ${year}`;
        const daysInMonth = new Date(year, month + 1, 0).getDate();
        const firstDayDate = createDateFromParts(year, month, 1);
        const firstDay = getLAWeekdayIndex(firstDayDate) ?? 0;
        const todayStr = formatDateYYYYMMDD(new Date());

        const dayMap = {};
        for (let day = 1; day <= daysInMonth; day++) {
          const dateObj = createDateFromParts(year, month, day);
          const dateStr = formatDateYYYYMMDD(dateObj);
          const weekdayIndex = getLAWeekdayIndex(dateObj);
          dayMap[day] = {
            date: dateObj,
            dateStr,
            weekdayIndex: weekdayIndex ?? dateObj.getUTCDay(),
            groups: [],
            payments: [],
            credits: [],
            studentEvents: [],
            stats: {
              classes: 0,
              payments: 0,
              credits: 0,
              absences: 0,
              skipped: 0,
            },
            totals: {
              paid: 0,
              unpaid: 0,
            },
            indicators: new Set(),
          };
        }

        const aggregates = {
          classes: 0,
          payments: 0,
          credits: 0,
          absenceCount: 0,
          skippedCount: 0,
          activeStudents: 0,
        };

        const eventsFlat = [];
        const students = window.studentsCache || [];
        const groups = window.groupsCache || [];
        const payments = window.paymentsCache || [];
        const creditLookup = creditPaymentsLookup || {};

        const studentIndexes = buildStudentIndexes(students);
        aggregates.activeStudents = studentIndexes.activeIds.size;
        const studentsByGroup = buildStudentsByGroup(students);
        const paymentIndexes = buildPaymentIndexes(payments, studentIndexes);
  const creditEventsByDate = buildCreditEventsByDate(creditLookup, studentIndexes.byId);
  const ambiguousPaymentAllocations = [];
  buildStudentPaymentCoverage({ students, groups, payments });

        addPaymentEvents(paymentIndexes.byDate);
        addCreditEvents(creditEventsByDate);
        addClassEvents(groups, studentsByGroup);
        addStudentMilestones(students);

        const totals = Object.values(dayMap).reduce(
          (acc, entry) => {
            acc.paid += entry.totals.paid;
            acc.unpaid += entry.totals.unpaid;
            return acc;
          },
          { paid: 0, unpaid: 0 }
        );

        const monthData = {
          key: cacheKey,
          year,
          month,
          firstDay,
          daysInMonth,
          dayMap,
          aggregates: {
            classes: aggregates.classes,
            payments: aggregates.payments,
            credits: aggregates.credits,
            absences: aggregates.absenceCount,
            skipped: aggregates.skippedCount,
            activeStudents: aggregates.activeStudents,
          },
          totals,
          eventsFlat,
          ambiguousPaymentAllocations: [],
          paymentAllocationSource: [],
          paymentAllocationMeta: { total: 0, unresolved: 0, resolved: 0 },
        };
        
        // Log payment matching statistics
        let matchedPayments = 0;
        let unmatchedPayments = 0;
        Object.values(dayMap).forEach(day => {
          (day.groups || []).forEach(group => {
            (group.students || []).forEach(student => {
              if (student.status === 'paid' || student.status === 'credit') {
                matchedPayments++;
              } else if (student.status === 'unpaid' && day.dateStr <= todayStr) {
                unmatchedPayments++;
              }
            });
          });
        });

        const unresolvedAllocations = filterResolvedPaymentAllocations(ambiguousPaymentAllocations);
        const resolvedCount = ambiguousPaymentAllocations.length - unresolvedAllocations.length;
        monthData.ambiguousPaymentAllocations = unresolvedAllocations;
        monthData.paymentAllocationSource = ambiguousPaymentAllocations;
        monthData.paymentAllocationMeta = {
          total: ambiguousPaymentAllocations.length,
          unresolved: unresolvedAllocations.length,
          resolved: resolvedCount,
        };

        if (resolvedCount > 0) {
          debugLog(
            `ℹ️ Skipped ${resolvedCount} previously reviewed payment allocation${resolvedCount === 1 ? '' : 's'}.`
          );
        }

        if (unresolvedAllocations.length) {
          window.paymentAllocationAlerts = unresolvedAllocations;
          // Payment allocation alerts handled by UI drawer
          // console.group('⚠️ Payment allocation requires review');
          // const sample = unresolvedAllocations.slice(0, 25);
          // sample.forEach(entry => {
          //   console.warn(
          //     `Student ${entry.studentName || entry.studentId} has $${entry.amount.toFixed(2)} from payment on ${entry.payDate || 'unknown date'} that could not be assigned between Nov 1 and today.`
          //   );
          // });
          // if (unresolvedAllocations.length > sample.length) {
          //   console.warn(
          //     `+${unresolvedAllocations.length - sample.length} additional payment${unresolvedAllocations.length - sample.length === 1 ? '' : 's'} require review. Use the on-screen review drawer to inspect all of them.`
          //   );
          // }
          // console.groupEnd();
        } else {
          window.paymentAllocationAlerts = [];
        }

        notifyPaymentAllocationReview(unresolvedAllocations, cacheKey, ambiguousPaymentAllocations);

        return monthData;

        // ===== Helper Functions (scoped to computeMonthData) =====

        function normalizeNameKey(value) {
          if (!value) return '';
          
          return value
            .toString()
            .trim()
            .toLowerCase()
            // Normalize Unicode characters (handles accents, Armenian, Cyrillic, etc.)
            .normalize('NFD')
            .replace(/[\u0300-\u036f]/g, '') // Remove diacritics/accents
            // Keep letters (including Unicode), numbers, and spaces - remove only punctuation
            .replace(/[^\p{L}\p{N}\s]/gu, '')
            .replace(/\s+/g, ''); // Remove ALL spaces for consistent matching
        }

        function parseAliasList(value) {
          if (!value) return [];
          if (Array.isArray(value)) return value;
          if (typeof value === 'string') {
            if (value.includes('|||')) return value.split('|||').map(v => v.trim()).filter(Boolean);
            if (value.includes(',')) return value.split(',').map(v => v.trim()).filter(Boolean);
            return [value];
          }
          return [];
        }

        function shouldIncludeStudent(student) {
          if (!student) return false;
          
          // Check calendar visibility flag (show_in_grid from database)
          // Only exclude if explicitly set to false (undefined means include)
          if (student.show_in_grid === false) {
            debugLog(`🚫 Student ${student.name} excluded: show_in_grid=${student.show_in_grid}`);
            return false;
          }
          
          // Exclude graduated/archived/inactive students
          const status = (student.status || '').toLowerCase().trim();
          const excludedStatuses = ['graduated', 'archived', 'inactive', 'deleted'];
          
          if (excludedStatuses.includes(status)) {
            debugLog(`🚫 Student ${student.name} excluded: status=${status}`);
            return false;
          }
          
          // Note: Paused students are INCLUDED but marked differently
          // They will show in calendar but won't generate unpaid warnings
          
          return true;
        }

        function getNameKeysForStudent(record) {
          const keys = new Set();
          if (!record) return keys;

          const directName = normalizeNameKey(record.name || record.student_name);
          if (directName) keys.add(directName);

          const aliasFields = [record.aliases, record.alias_list, record.alias];
          aliasFields.forEach(value => {
            parseAliasList(value).forEach(alias => {
              const key = normalizeNameKey(alias);
              if (key) keys.add(key);
            });
          });

          [record.parent_name, record.guardian_name, record.payer_name, record.payer]
            .filter(Boolean)
            .forEach(value => {
              const key = normalizeNameKey(value);
              if (key) keys.add(key);
            });

          return keys;
        }

        function buildStudentIndexes(rawStudents) {
          const byId = new Map();
          const nameToId = new Map();
          const activeIds = new Set();

          rawStudents.forEach(student => {
            const idKey = student && student.id != null ? String(student.id) : null;
            if (idKey) {
              byId.set(idKey, student);
            }

            if (!shouldIncludeStudent(student)) return;

            if (idKey) {
              activeIds.add(idKey);
            }

            const normalizedName = normalizeNameKey(student.name);
            if (normalizedName && idKey && !nameToId.has(normalizedName)) {
              nameToId.set(normalizedName, idKey);
            }

            parseAliasList(student.aliases).forEach(alias => {
              const aliasKey = normalizeNameKey(alias);
              if (aliasKey && idKey && !nameToId.has(aliasKey)) {
                nameToId.set(aliasKey, idKey);
              }
            });
          });

          return { byId, nameToId, activeIds };
        }

        function deriveStudentGroups(student) {
          const primarySources = [student.group_code, student.group_display, student.group_name, student.group, student.groupName];
          const extra = Array.isArray(student.groups) ? student.groups : [];
          const combined = [...primarySources, ...extra]
            .map(value => (value === 'ungrouped' ? 'ungrouped' : canonicalizeGroupCode(value)))
            .filter(Boolean);

          if (combined.length === 0) return ['ungrouped'];
          return Array.from(new Set(combined));
        }

        function normalizeGroupKey(value) {
          if (!value || value === 'ungrouped') return 'ungrouped';
          const normalized = canonicalizeGroupCode(value);
          return normalized || 'ungrouped';
        }

        function buildStudentsByGroup(rawStudents) {
          const map = {};
          rawStudents.forEach(student => {
            if (!shouldIncludeStudent(student)) return;
            deriveStudentGroups(student).forEach(groupName => {
              const key = normalizeGroupKey(groupName);
              if (!map[key]) map[key] = [];
              map[key].push(student);
            });
          });
          return map;
        }

        function getStudentPricePerClass(student, group) {
          const fromStudent = student.price_per_class || student.pricePerClass || student.pay_per_class;
          if (fromStudent) return Number(fromStudent) || 0;
          if (group && group.price_per_class) return Number(group.price_per_class) || 0;
          return 0;
        }

        function getStudentBalance(student) {
          const balanceFields = [
            student.balance,
            student.credit_balance,
            student.balance_amount,
            student.creditBalance,
          ];
          const value = balanceFields.find(v => v !== undefined && v !== null);
          return Number(value) || 0;
        }

        function buildPaymentIndexes(rawPayments, indexes) {
          const byDate = {};
          const byStudentDate = {};
          const byNameDate = {};

          (rawPayments || []).forEach(payment => {
            const dateStr = extractDateStr(payment);
            if (!dateStr) return;

            const studentId = resolveStudentIdForPayment(payment, indexes);
            const studentEntry = studentId ? indexes.byId.get(studentId) : null;
            const studentName =
              studentEntry?.name ||
              payment.student_name ||
              payment.studentName ||
              payment.resolved_student_name ||
              payment.payer_name ||
              payment.payer ||
              payment.payer_name_raw ||
              '';
            const amount = Number(payment.amount) || 0;

            const entry = {
              id: payment.id || payment.gmail_id || `${dateStr}-${Math.random().toString(36).slice(2, 8)}`,
              studentId,
              studentName,
              amount,
              payerName: payment.payer_name || payment.payer || payment.payer_name_raw || '',
              memo: payment.memo || payment.message || '',
              raw: payment,
            };

            if (!byDate[dateStr]) byDate[dateStr] = [];
            byDate[dateStr].push(entry);

            if (studentId) {
              if (!byStudentDate[studentId]) byStudentDate[studentId] = {};
              if (!byStudentDate[studentId][dateStr]) byStudentDate[studentId][dateStr] = [];
              byStudentDate[studentId][dateStr].push(entry);
            }

            const nameKeys = new Set();
            [
              studentEntry?.name,
              payment.student_name,
              payment.studentName,
              payment.resolved_student_name,
              payment.payer_name,
              payment.payer,
              payment.payer_name_raw,
              payment.sender_name,
            ]
              .filter(Boolean)
              .forEach(value => {
                const key = normalizeNameKey(value);
                if (key) nameKeys.add(key);
              });

            // Include aliases stored on the payment record if present
            if (payment.aliases && Array.isArray(payment.aliases)) {
              payment.aliases.forEach(alias => {
                const key = normalizeNameKey(alias);
                if (key) nameKeys.add(key);
              });
            }

            nameKeys.forEach(key => {
              if (!byNameDate[key]) byNameDate[key] = {};
              if (!byNameDate[key][dateStr]) byNameDate[key][dateStr] = [];
              byNameDate[key][dateStr].push(entry);
            });
          });

          return { byDate, byStudentDate, byNameDate };

          function extractDateStr(payment) {
            const source = payment.email_date || payment.emailDate || payment.date || payment.created_at;
            if (!source) return '';
            
            // CRITICAL: ALL payment dates MUST be converted to LA timezone
            // We cannot just extract the date portion from ISO strings because
            // "2025-11-23T05:05:51+00:00" in UTC could be "2025-11-22" in LA time
            
            const sourceStr = String(source);
            
            // If it's already in simple YYYY-MM-DD format (no time component), use as-is
            if (/^\d{4}-\d{2}-\d{2}$/.test(sourceStr) && !sourceStr.includes('T')) {
              return sourceStr;
            }
            
            // For any date with time information, convert to LA timezone
            // This handles ISO strings, timestamps, and Date objects
            return normalizeDateInput(source);
          }
        }

        function resolveStudentIdForPayment(payment, indexes) {
          // Step 1: Try direct ID matches
          const candidateIds = [
            payment.student_id,
            payment.studentid,
            payment.linked_student_id,
            payment.derived_student_id,
          ].filter(Boolean);

          for (const candidate of candidateIds) {
            const key = String(candidate);
            if (indexes.byId.has(key)) {
              return key;
            }
          }

          // Step 2: Try name matching (student_name, resolved_student_name)
          const studentKey = normalizeNameKey(payment.student_name || payment.studentName || payment.resolved_student_name);
          if (studentKey && indexes.nameToId.has(studentKey)) {
            return indexes.nameToId.get(studentKey);
          }

          // Step 3: Try payer name matching
          const payerKey = normalizeNameKey(payment.payer_name || payment.payer || payment.payer_name_raw);
          if (payerKey && indexes.nameToId.has(payerKey)) {
            return indexes.nameToId.get(payerKey);
          }

          // Step 4: Try email matching
          const paymentEmail = payment.student_email || payment.email || payment.payer_email;
          if (paymentEmail) {
            const normalizedEmail = paymentEmail.toLowerCase().trim();
            // Search through all students for email match
            for (const [studentId, student] of indexes.byId) {
              const studentEmail = student.email || student.student_email;
              if (studentEmail && studentEmail.toLowerCase().trim() === normalizedEmail) {
                return studentId;
              }
            }
          }

          return null;
        }

        function buildCreditEventsByDate(lookup, studentMap) {
          const byDate = {};
          Object.keys(lookup || {}).forEach(studentId => {
            const studentRecords = lookup[studentId];
            Object.keys(studentRecords || {}).forEach(dateStr => {
              const record = studentRecords[dateStr];
              if (!byDate[dateStr]) byDate[dateStr] = [];
              byDate[dateStr].push({
                studentId,
                studentName: studentMap.get(studentId)?.name || 'Unknown Student',
                amount: Number(record.amount) || 0,
                balance: record.balance_after ?? null,
              });
            });
          });
          return byDate;
        }

  function buildStudentPaymentCoverage(options = {}) {
          const students = options.students || window.studentsCache || [];
          const groups = options.groups || window.groupsCache || [];
          const payments = options.payments || window.paymentsCache || [];
          const coverageStart = options.coverageStart || COVERAGE_WINDOW_START || CALENDAR_START_DATE_STR;
          const coverageMap = new Map();
          const stats = {
            studentsEvaluated: 0,
            studentsWithPayments: 0,
            classesCovered: 0,
            totalPayments: payments.length,
          };

          // Make results globally accessible for status checks
          window.studentPaymentCoverage = coverageMap;
          window.studentPaymentCoverageStats = stats;

          if (!Array.isArray(students) || !students.length || !Array.isArray(payments) || !payments.length) {
            return coverageMap;
          }

          const todayStr = formatDateYYYYMMDD(new Date());
          const coverageStartStr = coverageStart || '2025-11-01';
          const groupLookup = new Map();
          const groupDatesCache = new Map();
          const studentDatesCache = new Map();

          (groups || []).forEach(group => {
            const key = normalizeGroupKey(group?.group_code || group?.group_name || group?.name || '');
            if (key) {
              groupLookup.set(key, group);
            }
          });

          const validStudents = students.filter(shouldIncludeStudent);

          validStudents.forEach(student => {
            stats.studentsEvaluated++;
            const idKey = student?.id != null ? String(student.id) : null;
            const classPrice = Math.max(getStudentPricePerClass(student), 0);
            if (!classPrice) return;

            const studentPayments = collectPaymentsForStudent(student, idKey);
            if (!studentPayments.length) return;

            const classDatesDesc = getClassDatesForStudent(student);
            if (!classDatesDesc.length) return;

            const coverage = allocatePaymentsToClasses(studentPayments, classDatesDesc, classPrice);
            if (!coverage.size) return;

            const keys = [];
            if (idKey) keys.push(idKey);
            const nameKey = normalizeNameKey(student?.name || student?.student_name);
            if (nameKey) keys.push(`name:${nameKey}`);
            keys.forEach(key => {
              coverageMap.set(key, coverage);
            });

            stats.studentsWithPayments += 1;
            stats.classesCovered += coverage.size;
          });

          return coverageMap;

          function collectPaymentsForStudent(student, idKey) {
            const matches = [];
            const studentNameLower = (student?.name || student?.student_name || '').toLowerCase().trim();
            const aliases = student?.aliases || student?.alias;
            const aliasList = Array.isArray(aliases) ? aliases : aliases ? [aliases] : [];
            const aliasLower = aliasList.map(alias => (alias || '').toLowerCase().trim()).filter(Boolean);

            (payments || []).forEach(payment => {
              if (!payment || payment.ignored) return;

              // Priority 1: Direct ID matches take priority
              if (idKey) {
                const candidateIds = [
                  payment.student_id,
                  payment.studentid,
                  payment.studentId,
                  payment.linked_student_id,
                  payment.derived_student_id,
                ]
                  .map(value => (value != null ? String(value) : null))
                  .filter(Boolean);
                if (candidateIds.includes(idKey)) {
                  matches.push(payment);
                  return;
                }
              }

              // Priority 2: Name matching (student_name, payer_name, payer_name_raw)
              const paymentStudentName = (payment.student_name || payment.studentName || '').toLowerCase().trim();
              const paymentPayerName = (payment.payer_name || payment.payerName || payment.payer || '').toLowerCase().trim();
              const paymentPayerRaw = (payment.payer_name_raw || payment.payerNameRaw || '').toLowerCase().trim();
              
              // CRITICAL FIX: Add resolved_student_name matching
              const paymentResolvedName = (payment.resolved_student_name || '').toLowerCase().trim();

              if (
                studentNameLower &&
                (paymentStudentName === studentNameLower ||
                  paymentPayerName === studentNameLower ||
                  paymentPayerRaw === studentNameLower ||
                  paymentResolvedName === studentNameLower)
              ) {
                matches.push(payment);
                return;
              }

              // Priority 3: Alias matching
              if (
                aliasLower.length &&
                aliasLower.some(alias => alias && (alias === paymentStudentName || alias === paymentPayerName || alias === paymentPayerRaw || alias === paymentResolvedName))
              ) {
                matches.push(payment);
                return;
              }
            });

            return matches;
          }

          function getClassDatesForStudent(student) {
            const cacheKey = student?.id != null ? String(student.id) : normalizeNameKey(student?.name || student?.student_name);
            if (cacheKey && studentDatesCache.has(cacheKey)) {
              return studentDatesCache.get(cacheKey);
            }

            const groupCodes = deriveStudentGroups(student);
            
            const classDates = new Set();
            groupCodes.forEach(code => {
              const normalized = normalizeGroupKey(code);
              const groupRecord = groupLookup.get(normalized);
              if (!groupRecord) return;
              const groupDates = getGroupDates(groupRecord);
              groupDates.forEach(dateStr => classDates.add(dateStr));
            });

            // Get student's absence data
            const idKey = student?.id != null ? String(student.id) : normalizeNameKey(student?.name || student?.student_name);
            const studentAbsences = (idKey && absencesData[idKey]) ? absencesData[idKey] : {};

            const filtered = Array.from(classDates)
              .filter(date => {
                // Filter out dates beyond today or before coverage start
                if (!date || date > todayStr || (coverageStartStr && date < coverageStartStr)) {
                  return false;
                }
                // CRITICAL: Filter out absent dates - these should NOT count as classes for payment allocation
                if (studentAbsences[date]) {
                  return false;
                }
                return true;
              })
              .sort((a, b) => b.localeCompare(a));

            if (cacheKey) {
              studentDatesCache.set(cacheKey, filtered);
            }

            return filtered;
          }

          function getGroupDates(groupRecord) {
            if (!groupRecord) return [];
            const key = groupRecord.id != null
              ? `id:${groupRecord.id}`
              : normalizeGroupKey(groupRecord.group_code || groupRecord.group_name || groupRecord.name);

            if (key && groupDatesCache.has(key)) {
              return groupDatesCache.get(key);
            }

            const classDates = new Set();
            const sessions = parseScheduleString(groupRecord.schedule || '');
            
            // CRITICAL FIX: Expand date range to include 6 months of historical data
            // This allows historical payments from July-October to match classes
            const today = new Date();
            const sixMonthsAgo = new Date(today);
            sixMonthsAgo.setMonth(today.getMonth() - 6);
            
            // Use the earlier of coverageStartStr or 6 months ago
            const coverageDate = createDateFromDateStr(coverageStartStr);
            const startDate = (coverageDate && coverageDate < sixMonthsAgo) ? coverageDate : sixMonthsAgo;
            
            // Get today's date in LA timezone using formatDateYYYYMMDD (which uses getLAParts internally)
            const todayStrLA = formatDateYYYYMMDD(new Date());
            
            // Create endDate from today's date string to ensure it's at start of day
            const endDate = createDateFromDateStr(todayStrLA);
            if (!endDate) {
              console.error('🔴 getGroupDates: Failed to create endDate from:', todayStrLA);
              return [];
            }
            
            const cursor = new Date(startDate);
            cursor.setHours(0, 0, 0, 0);
            
            // Set endDate to end of day to ensure today is included
            endDate.setHours(23, 59, 59, 999);

            const groupName = groupRecord.group_name || groupRecord.name || groupRecord.group_code || 'Unknown';

            if (sessions.length) {
              let loopCount = 0;
              const endDateStr = formatDateYYYYMMDD(endDate);
              
              while (true) {
                const cursorDateStr = formatDateYYYYMMDD(cursor);
                
                // Break if we've passed the end date
                if (cursorDateStr > endDateStr) {
                  break;
                }
                
                const laWeekdayIndex = getLAWeekdayIndex(cursor);
                
                sessions.forEach(session => {
                  const weekdayIndex = dayNames.indexOf(session.day);
                  if (weekdayIndex === laWeekdayIndex) {
                    classDates.add(cursorDateStr);
                  }
                });
                
                cursor.setDate(cursor.getDate() + 1);
                loopCount++;
                
                // Safety check to prevent infinite loops
                if (loopCount > 1000) {
                  console.error('🔴 getGroupDates: Loop exceeded 1000 iterations, breaking');
                  break;
                }
              }
            }

            (Array.isArray(groupRecord.one_time_schedules) ? groupRecord.one_time_schedules : []).forEach(override => {
              const normalizedDate = normalizeDateInput(override?.date);
              if (
                normalizedDate &&
                normalizedDate >= coverageStartStr &&
                normalizedDate <= todayStr
              ) {
                classDates.add(normalizedDate);
              }
            });

            const sorted = Array.from(classDates).sort((a, b) => b.localeCompare(a));
            if (key) {
              groupDatesCache.set(key, sorted);
            }
            return sorted;
          }

          /**
           * IMPROVED PAYMENT ALLOCATION LOGIC
           * Matches payments to classes by date proximity with conflict detection
           * Priority: Early payments for upcoming classes > Exact matches > Late payments for past classes
           * 
           * CONFLICT RESOLUTION:
           * - Each payment can only be used once (prevents double-counting)
           * - Detects when a payment could match multiple classes (overlap)
           * - Logs ambiguous allocations for manual review
           */
          function allocatePaymentsToClasses(studentPayments, classDatesDesc, classPrice) {
            if (!studentPayments.length || !classDatesDesc.length || !classPrice) return new Map();

            // Initialize coverage map
            const coverage = new Map();
            const usedPaymentIds = new Set(); // Track which payments have been used
            const coveredClasses = new Set(); // Track which classes are covered
            const todayStr = formatDateYYYYMMDD(new Date());
            
            // STRATEGY: Process in order that prevents "wasting" payments
            // 1. Exact matches for PAST classes only (already happened, no ambiguity)
            // 2. Late payments for unpaid past classes (0-7 days late)
            // 3. Early payments for future classes (1-5 days early)
            // 4. Exact matches for TODAY/FUTURE classes (use remaining exact matches)
            // 5. Mark remaining as unpaid/future
            
            // Pass 1: Exact matches for PAST classes only
            classDatesDesc.forEach(classDate => {
              if (classDate >= todayStr) return; // Skip today/future classes for now
              
              const exactPayment = studentPayments.find(p => {
                const paymentId = p.id || p.gmail_id || p.payment_id;
                if (usedPaymentIds.has(paymentId)) return false;

                const paymentTimestamp = p.emailDate || p.email_date || p.date || p.timestamp;
                if (!paymentTimestamp) return false;

                const paymentDateStr = normalizeDateInput(paymentTimestamp);
                return paymentDateStr === classDate;
              });

              if (exactPayment) {
                const paymentId = exactPayment.id || exactPayment.gmail_id || exactPayment.payment_id;
                usedPaymentIds.add(paymentId);
                coveredClasses.add(classDate);
                const paymentAmount = Number(exactPayment.amount || exactPayment.amountUSD || exactPayment.amount_paid_usd || 0);
                coverage.set(classDate, {
                  amount: paymentAmount,
                  payDate: classDate,
                  paymentIds: [paymentId],
                  matchType: 'exact'
                });
              }
            });
            
            // Pass 2: Match late payments for UNPAID past classes (within 7 days after)
            // CRITICAL: Only apply to classes that are NOT already covered
            // PRIORITY: Pay off past unpaid classes BEFORE applying to future classes
            classDatesDesc.forEach(classDate => {
              if (coveredClasses.has(classDate)) return; // Already covered by exact match

              // Only process past classes that are UNPAID
              if (classDate >= todayStr) return; // Skip future classes for now

              const latePayment = studentPayments.find(p => {
                const paymentId = p.id || p.gmail_id || p.payment_id;
                if (usedPaymentIds.has(paymentId)) return false;

                const paymentTimestamp = p.emailDate || p.email_date || p.date || p.timestamp;
                if (!paymentTimestamp) return false;

                const paymentDateStr = normalizeDateInput(paymentTimestamp);
                const classDt = new Date(classDate + 'T12:00:00');
                const payDt = new Date(paymentDateStr + 'T12:00:00');
                const daysDiff = Math.floor((payDt - classDt) / (1000 * 60 * 60 * 24));

                // Late payment: 0-7 days after class
                return daysDiff >= 0 && daysDiff <= 7;
              });

              if (latePayment) {
                const paymentId = latePayment.id || latePayment.gmail_id || latePayment.payment_id;
                usedPaymentIds.add(paymentId);
                coveredClasses.add(classDate); // Mark class as covered
                const paymentAmount = Number(latePayment.amount || latePayment.amountUSD || latePayment.amount_paid_usd || 0);
                const paymentDateStr = normalizeDateInput(latePayment.emailDate || latePayment.email_date || latePayment.date || latePayment.timestamp);
                const daysAfter = Math.floor((new Date(paymentDateStr + 'T12:00:00') - new Date(classDate + 'T12:00:00')) / (1000 * 60 * 60 * 24));
                coverage.set(classDate, {
                  amount: paymentAmount,
                  payDate: paymentDateStr,
                  paymentIds: [paymentId],
                  matchType: 'late'
                });
              }
            });

            // Pass 3: Match early payments for TODAY/FUTURE classes (within 5 days before)
            // Process BEFORE exact matches for today/future to avoid wasting early payments
            classDatesDesc.forEach(classDate => {
              if (coveredClasses.has(classDate)) return; // Already covered

              // Only look for early payments for today/future classes
              if (classDate < todayStr) return;

              const earlyPayment = studentPayments.find(p => {
                const paymentId = p.id || p.gmail_id || p.payment_id;
                if (usedPaymentIds.has(paymentId)) return false;

                const paymentTimestamp = p.emailDate || p.email_date || p.date || p.timestamp;
                if (!paymentTimestamp) return false;

                const paymentDateStr = normalizeDateInput(paymentTimestamp);
                const classDt = new Date(classDate + 'T12:00:00');
                const payDt = new Date(paymentDateStr + 'T12:00:00');
                const daysDiff = Math.floor((classDt - payDt) / (1000 * 60 * 60 * 24));

                // Early payment: 1-5 days before class
                return daysDiff >= 1 && daysDiff <= 5;
              });

              if (earlyPayment) {
                const paymentId = earlyPayment.id || earlyPayment.gmail_id || earlyPayment.payment_id;
                usedPaymentIds.add(paymentId);
                coveredClasses.add(classDate);
                const paymentAmount = Number(earlyPayment.amount || earlyPayment.amountUSD || earlyPayment.amount_paid_usd || 0);
                const paymentDateStr = normalizeDateInput(earlyPayment.emailDate || earlyPayment.email_date || earlyPayment.date || earlyPayment.timestamp);
                const daysBefore = Math.floor((new Date(classDate + 'T12:00:00') - new Date(paymentDateStr + 'T12:00:00')) / (1000 * 60 * 60 * 24));
                coverage.set(classDate, {
                  amount: paymentAmount,
                  payDate: paymentDateStr,
                  paymentIds: [paymentId],
                  matchType: 'early'
                });
              }
            });
            
            // Pass 4: Exact matches for TODAY/FUTURE classes (use any remaining exact payments)
            classDatesDesc.forEach(classDate => {
              if (coveredClasses.has(classDate)) return; // Already covered
              if (classDate < todayStr) return; // Already processed past classes in Pass 1
              
              const exactPayment = studentPayments.find(p => {
                const paymentId = p.id || p.gmail_id || p.payment_id;
                if (usedPaymentIds.has(paymentId)) return false;

                const paymentTimestamp = p.emailDate || p.email_date || p.date || p.timestamp;
                if (!paymentTimestamp) return false;

                const paymentDateStr = normalizeDateInput(paymentTimestamp);
                return paymentDateStr === classDate;
              });

              if (exactPayment) {
                const paymentId = exactPayment.id || exactPayment.gmail_id || exactPayment.payment_id;
                usedPaymentIds.add(paymentId);
                coveredClasses.add(classDate);
                const paymentAmount = Number(exactPayment.amount || exactPayment.amountUSD || exactPayment.amount_paid_usd || 0);
                coverage.set(classDate, {
                  amount: paymentAmount,
                  payDate: classDate,
                  paymentIds: [paymentId],
                  matchType: 'exact'
                });
              }
            });

            // Pass 5: SMART ALLOCATION - DISABLED
            // REASON: This was force-matching old payments (30+ days) to unrelated classes
            // Example: Oct 26 payment matched to Nov 28 class (+33 days) - incorrect!
            // These excess payments should flow to credit balance instead of being force-allocated
            // If re-enabled, add strict time window (e.g., max 14 days difference)
            
            /* DISABLED CODE - DO NOT USE
            const unpaidPastClasses = classDatesDesc.filter(d => !coveredClasses.has(d) && d < todayStr);
            const unmatchedPayments = studentPayments.filter(p => {
              const paymentId = p.id || p.gmail_id || p.payment_id;
              return !usedPaymentIds.has(paymentId);
            });
            
            if (unpaidPastClasses.length > 0 && unmatchedPayments.length > 0) {
              // Smart allocation logic here...
            }
            */
            
            // Pass 6: Mark remaining classes as unpaid or future
            classDatesDesc.forEach(classDate => {
              if (coveredClasses.has(classDate)) return; // Already covered

              if (classDate >= todayStr) {
                coverage.set(classDate, { amount: 0, payDate: null, paymentIds: [], matchType: 'future' });
              } else {
                coverage.set(classDate, { amount: 0, payDate: null, paymentIds: [], matchType: 'unpaid' });
              }
            });

            // Check for REMAINING unmatched payments AFTER smart allocation
            const remainingUnmatched = studentPayments.filter(p => {
              const paymentId = p.id || p.gmail_id || p.payment_id;
              return !usedPaymentIds.has(paymentId);
            });

            if (remainingUnmatched.length > 0) {
              // Store excess payments for credit dialog (will be used by UI)
              if (!window.excessPaymentsForCredit) {
                window.excessPaymentsForCredit = [];
              }
              
              remainingUnmatched.forEach(p => {
                const paymentDateStr = normalizeDateInput(p.emailDate || p.email_date || p.date || p.timestamp);
                const amount = Number(p.amount || 0);
                const paymentId = p.id || p.gmail_id || p.payment_id;
                
                window.excessPaymentsForCredit.push({
                  paymentId,
                  studentId: p.student_id,
                  studentName: p.payer_name || p.student_name,
                  amount,
                  date: paymentDateStr,
                  reason: `${remainingUnmatched.length} payment(s) exceed class count`
                });
              });
            }

            return coverage;
          }

          function normalizePaymentDate(payment) {
            if (!payment) return '';
            const source =
              payment.emailDate ||
              payment.email_date ||
              payment.payDate ||
              payment.payment_date ||
              payment.date ||
              payment.timestamp ||
              payment.created_at ||
              payment.raw?.email_date ||
              payment.raw?.date;
            if (!source) return '';
            return normalizeDateInput(source) || '';
          }
        }

        function addPaymentEvents(paymentsByDate) {
          Object.entries(paymentsByDate || {}).forEach(([dateStr, list]) => {
            const parts = parseDateParts(dateStr);
            if (!parts || parts.year !== year || parts.month !== month + 1) return;
            const dayEntry = dayMap[parts.day];
            if (!dayEntry) return;

            dayEntry.payments.push(...list);
            dayEntry.stats.payments += list.length;
            dayEntry.indicators.add('payment');
            aggregates.payments += list.length;

            list.forEach(entry => {
              eventsFlat.push({ type: 'payment', date: dateStr, studentName: entry.studentName, amount: entry.amount });
            });
          });
        }

        function addCreditEvents(creditByDate) {
          Object.entries(creditByDate || {}).forEach(([dateStr, list]) => {
            const parts = parseDateParts(dateStr);
            if (!parts || parts.year !== year || parts.month !== month + 1) return;
            const dayEntry = dayMap[parts.day];
            if (!dayEntry) return;

            dayEntry.credits.push(...list);
            dayEntry.stats.credits += list.length;
            dayEntry.indicators.add('credit');
            aggregates.credits += list.length;

            list.forEach(entry => {
              eventsFlat.push({ type: 'credit', date: dateStr, studentName: entry.studentName, amount: entry.amount });
            });
          });
        }

        function getSkipInfoForGroup(groupName, dateStr) {
          if (!groupName || !dateStr) return null;
          if (skippedClassesData[groupName] && skippedClassesData[groupName][dateStr]) {
            return skippedClassesData[groupName][dateStr];
          }

          const normalized = normalizeGroupKey(groupName);
          for (const key of Object.keys(skippedClassesData || {})) {
            if (normalizeGroupKey(key) === normalized && skippedClassesData[key][dateStr]) {
              return skippedClassesData[key][dateStr];
            }
          }
          return null;
        }

        function generateGroupOccurrences(groupRecord) {
          const occurrences = [];
          const sessions = parseScheduleString(groupRecord.schedule);
          for (const session of sessions) {
            const weekdayIndex = dayNames.indexOf(session.day);
            if (weekdayIndex === -1) continue;

            for (let day = 1; day <= daysInMonth; day++) {
              const dateObj = createDateFromParts(year, month, day);
              const laWeekdayIndex = getLAWeekdayIndex(dateObj);
              if (laWeekdayIndex !== weekdayIndex) continue;
              const dateStr = formatDateYYYYMMDD(dateObj);
              occurrences.push({
                dateObj,
                dateStr,
                weekdayIndex: laWeekdayIndex,
                laTime: session.time,
                isOneTime: false,
              });
            }
          }

          (Array.isArray(groupRecord.one_time_schedules) ? groupRecord.one_time_schedules : []).forEach(override => {
            if (!override || !override.date) return;
            const normalizedDate = normalizeDateInput(override.date);
            const parts = parseDateParts(normalizedDate);
            if (!parts || parts.year !== year || parts.month !== month + 1) return;
            const overrideDate = createDateFromParts(parts.year, parts.month - 1, parts.day);
            const laTime = ensureAMPMFormatLocal(override.time || '');
            occurrences.push({
              dateObj: overrideDate,
              dateStr: normalizedDate,
              weekdayIndex: getLAWeekdayIndex(overrideDate) ?? overrideDate.getUTCDay(),
              laTime,
              isOneTime: true,
            });
          });

          return occurrences;
        }

        function buildFallbackGroupStudents(groupRecord) {
          if (!groupRecord || !Array.isArray(groupRecord.students)) return [];
          const groupCode = groupRecord.group_code || canonicalizeGroupCode(groupRecord.group_name || groupRecord.name || '');
          const groupDisplay = groupCode ? formatGroupDisplay(groupCode) : (groupRecord.group_name || groupRecord.name || 'Untitled Group');
          return groupRecord.students.map((student, index) => ({
            id: student.id != null ? String(student.id) : `${groupRecord.id || 'group'}-student-${index}`,
            name: student.name || student.student_name || `Student ${index + 1}`,
            group_code: groupCode,
            group_display: groupDisplay,
            group_name: groupRecord.group_name || groupRecord.name || groupDisplay,
            price_per_class: student.price_per_class || groupRecord.price_per_class || 0,
            status: student.status || 'active',
            show_in_calendar: student.show_in_calendar ?? true,
          }));
        }

        /**
         * Determines the payment status for a student on a specific class date.
         * 
         * PAYMENT MATCHING RULES (Core Billing Logic):
         * ================================================
         * 
         * 1. Every scheduled class creates an "expected payment"
         *    - Red dot = student owes money for that specific class
         *    - Red dot only disappears when valid payment/credit is found
         * 
         * 2. Payment Identification (who paid?)
         *    A payment belongs to a student if ANY of these match:
         *    - student_id, linked_student_id, derived_student_id
         *    - resolved_student_name, student_email
         *    - Any name alias configured for the student
         * 
         * 3. Payment Application (which class does it cover?)
         *    - Payment applies to nearest PAST class ON or BEFORE payment date
         *    - Payment CANNOT apply to future classes
         *    - Exact date match has highest priority
         * 
         *    Example:
         *    Classes: Nov 10, Nov 12, Nov 14
         *    Payment: Nov 13 (LA time)
         *    
         *    Result:
         *    - Nov 10: May get earlier payment if exists
         *    - Nov 12: Gets Nov 13 payment ✅ (nearest past class)
         *    - Nov 14: Not covered (payment is before this class)
         * 
         * 4. When payment matches:
         *    ✅ Remove red dot
         *    ✅ Add green dot (payment) or cyan dot (credit)
         *    ✅ Mark student as PAID/CREDIT
         *    ✅ Show payment in day modal
         *    ✅ Reduce outstanding balance
         * 
         * 5. Credit payments (using student's profile credit):
         *    - Work exactly like cash payments
         *    - Show cyan dot instead of green
         *    - Reduce credit balance
         *    - Logged in credit_payments table
         * 
         * 6. No payment/credit found:
         *    ❌ Keep red dot (UNPAID)
         *    ❌ Show in "Unpaid Students" list
         *    ❌ Day modal shows "Unpaid (no payment found)"
         * 
         * CRITICAL: All dates MUST use LA timezone only
         * 
         * @param {Object} student - Student record with name, id, schedule info
         * @param {String} studentId - Student ID for lookups
         * @param {String} dateStr - Class date in YYYY-MM-DD format (LA time)
         * @param {Number} pricePerClass - Expected payment amount for this class
         * @param {Object} skipInfo - Optional cancellation/skip information
         * @returns {Object} Status object with: status, label, balance, paidAmount
         */
  function determineClassStatus(student, studentId, dateStr, pricePerClass, skipInfo, groupName, classTime) {
          // Add comprehensive null safety
          if (!student || !dateStr) return null;
          
          const idKey = studentId ? String(studentId) : null;
          const studentName = student?.name || student?.student_name || 'Unknown';
          const balance = getStudentBalance(student);
          const classDate = createDateFromDateStr(dateStr);
          const todayStr = formatDateYYYYMMDD(new Date());

          if (!classDate) return null;

          // Validate pricePerClass
          const validPrice = Number(pricePerClass) || 0;
          if (validPrice <= 0) {
            // console.warn(`Invalid pricePerClass for student ${student.name}: ${pricePerClass}`);
          }

          // Hide historical classes before system start or before the student existed
          if (CALENDAR_START_DATE && classDate < CALENDAR_START_DATE) {
            return null;
          }

          const visibilityThreshold = getStudentVisibilityThreshold(student);
          if (visibilityThreshold && dateStr < visibilityThreshold) {
            return null;
          }

          // Priority 1: Check if class was canceled or skipped
          if (skipInfo) {
            const isCanceled = skipInfo.type === 'class-canceled';
            return {
              status: isCanceled ? 'canceled' : 'skipped',
              label: skipInfo.note || (isCanceled ? 'Class canceled' : 'Class skipped'),
              balance,
              paidAmount: 0,
            };
          }

          // Priority 2: Check if student was absent
          // Check both absencesData and AbsentManager for real-time updates
          const isAbsentInData = idKey && absencesData[idKey] && absencesData[idKey][dateStr];
          const isAbsentInManager = idKey && window.AbsentManager && window.AbsentManager.isAbsent(idKey, dateStr);
          
          // DEBUG: Log Alvard specifically
          if (studentName && studentName.toLowerCase().includes('alvard')) {
            debugLog(`🔍 ALVARD CHECK on ${dateStr}:`, {
              studentName,
              idKey,
              dateStr,
              isAbsentInData,
              isAbsentInManager,
              absencesDataKeys: Object.keys(absencesData),
              absencesForThisStudent: absencesData[idKey]
            });
          }
          
          if (isAbsentInData || isAbsentInManager) {
            // Log first few absences for debugging
            if (Math.random() < 0.01) { // Log ~1% to avoid spam
              debugLog(`✓ Absence detected: Student ${idKey} on ${dateStr} (fromData: ${!!isAbsentInData}, fromManager: ${!!isAbsentInManager})`);
            }
            return {
              status: 'absent',
              label: 'Marked absent',
              balance,
              paidAmount: 0,
            };
          }

          // Priority 3: CRITICAL FIX - Check payment coverage FIRST (before credits)
          // This is the main payment matching engine - it MUST be checked for all classes
          const coverageEntry = lookupPaymentCoverage(dateStr);
          
          // DEBUG: Log coverage lookup attempts
          if (Math.random() < 0.02) { // Log 2% of lookups
            debugLog(`🔎 Coverage lookup for ${studentName} on ${dateStr}:`, {
              idKey,
              studentName,
              coverageExists: !!coverageEntry,
              coverageAmount: coverageEntry?.amount,
              validPrice,
              globalCoverageSize: window.studentPaymentCoverage?.size
            });
          }
          
          // Priority 3: PAID via regular payment coverage
          // CRITICAL: Trust payment allocation from buildStudentPaymentCoverage
          // Don't compare amounts - student's current price may differ from price at time of payment
          if (coverageEntry && coverageEntry.amount > 0) {
            const paidAmount = coverageEntry.amount;
            const matchType = coverageEntry.matchType || 'exact';
            const matchLabel = {
              exact: `Paid ${formatCurrency(paidAmount)} $`,
              early: `Paid ${formatCurrency(paidAmount)} $ (early)`,
              late: `Paid ${formatCurrency(paidAmount)} $ (late)`
            }[matchType] || `Paid ${formatCurrency(paidAmount)} $`;
            
            return {
              status: 'paid',
              label: matchLabel,
              balance,
              paidAmount: paidAmount,
              paymentDate: coverageEntry.payDate,
            };
          }

          // Priority 4: Check if paid via credit/balance usage record (fallback if no cash payment)
          // Check both creditLookup and CreditPaymentManager for real-time updates
          const creditInLookup = idKey && creditLookup[idKey] && creditLookup[idKey][dateStr];
          const creditInManager = idKey && window.CreditPaymentManager && window.CreditPaymentManager.getCreditPayment(idKey, dateStr);
          const creditRecord = creditInLookup || creditInManager;
          
          if (creditRecord) {
            const creditAmount = Number(creditRecord.amount) || pricePerClass;
            return {
              status: 'credit',
              label: `Paid from credit (${formatCurrency(creditAmount)} $)`,
              balance: creditRecord.balance_after ?? creditRecord.balance ?? balance,
              paidAmount: creditAmount,
            };
          }

          // Priority 5: Future class (no payment yet)
          if (dateStr > todayStr) {
            return {
              status: 'upcoming',
              label: balance > 0 ? `Upcoming (balance ${formatCurrency(balance)} $)` : 'Upcoming class',
              balance,
              paidAmount: 0,
            };
          }

          // Priority 6: Unpaid (past or today, no payment)
          return {
            status: 'unpaid',
            label: balance > 0 ? `Unpaid (${formatCurrency(balance)} $ balance)` : 'Unpaid',
            balance,
            paidAmount: 0,
          };

          function getStudentVisibilityThreshold(record) {
            const created = normalizeDateInput(
              record?.created_at || record?.start_date || record?.startDate || record?.joined_at || record?.joinedAt
            );
            return created || CALENDAR_START_DATE_STR;
          }

          function lookupPaymentCoverage(targetDateStr) {
            const store = window.studentPaymentCoverage;
            if (!store || typeof store.get !== 'function') return null;

            const keysToTry = [];
            if (idKey) keysToTry.push(idKey);
            const normalizedName = normalizeNameKey(studentName);
            if (normalizedName) keysToTry.push(`name:${normalizedName}`);

            for (const key of keysToTry) {
              const perStudent = store.get(key);
              if (perStudent && typeof perStudent.get === 'function' && perStudent.has(targetDateStr)) {
                return perStudent.get(targetDateStr);
              }
            }

            return null;
          }

        }

        function addClassEvents(groupList, groupedStudents) {
          groupList.forEach(groupRecord => {
            const groupNameRaw = groupRecord.group_name || groupRecord.name || 'Untitled Group';
            const groupCode = groupRecord.group_code || canonicalizeGroupCode(groupNameRaw);
            const canonicalKey = groupCode || 'ungrouped';
            const fallbackKey = normalizeGroupKey(groupNameRaw);
            const groupDisplay = groupCode ? formatGroupDisplay(groupCode) : groupNameRaw;
            const groupStudents = (groupedStudents[canonicalKey] && groupedStudents[canonicalKey].length)
              ? groupedStudents[canonicalKey]
              : (groupedStudents[fallbackKey] && groupedStudents[fallbackKey].length)
                ? groupedStudents[fallbackKey]
                : buildFallbackGroupStudents(groupRecord);

            if (!groupStudents.length) return;

            const occurrences = generateGroupOccurrences(groupRecord);
            occurrences.forEach((occurrence, idx) => {
              const parts = parseDateParts(occurrence.dateStr);
              if (!parts) return;
              const dayEntry = dayMap[parts.day];
              if (!dayEntry) return;

              const skipInfo = getSkipInfoForGroup(groupNameRaw, occurrence.dateStr);
              const classEntry = {
                id: `${canonicalKey || 'group'}-${occurrence.dateStr}-${idx}`,
                groupName: groupDisplay,
                groupCode,
                laTime: occurrence.laTime,
                day: dayNames[occurrence.weekdayIndex],
                isOneTime: occurrence.isOneTime,
                students: [],
                skipped: Boolean(skipInfo),
                skipInfo,
              };

              groupStudents.forEach(student => {
                if (!student || !shouldIncludeStudent(student)) return;
                
                const studentId = student.id != null ? String(student.id) : null;
                const studentName = student.name || 'Unknown Student';
                
                // Validate student has required data
                if (!studentName && !studentId) {
                  // console.warn('Student missing both name and id:', student);
                  return;
                }
                
                const pricePerClass = getStudentPricePerClass(student, groupRecord);
                const statusInfo = determineClassStatus(
                  student,
                  studentId,
                  occurrence.dateStr,
                  pricePerClass,
                  skipInfo,
                  groupNameRaw,
                  occurrence.laTime
                );
                
                if (!statusInfo) return;

                const studentEntry = {
                  id: studentId || `${classEntry.id}-${studentName}`,
                  name: studentName,
                  groupName: groupDisplay,
                  groupCode: groupCode || student.group_code || '',
                  pricePerClass: Number(pricePerClass) || 0,
                  balance: Number(statusInfo.balance) || 0,
                  paid: statusInfo.status === 'paid' || statusInfo.status === 'credit',
                  absent: statusInfo.status === 'absent',
                  status: statusInfo.status,
                  statusLabel: statusInfo.label || '',
                  paidAmount: Number(statusInfo.paidAmount) || 0,
                  autoPaused: (student.status || '').toLowerCase() === 'paused',
                };

                classEntry.students.push(studentEntry);

                const validPrice = Number(pricePerClass) || 0;
                if (statusInfo.status === 'paid' || statusInfo.status === 'credit') {
                  // For paid classes, use the actual paid amount (important for manual/cash payments)
                  const actualPaid = Number(statusInfo.paidAmount) || validPrice;
                  dayEntry.totals.paid += actualPaid;
                } else if (statusInfo.status === 'partial') {
                  // Partial payment: add the partial amount to paid and the remainder to unpaid
                  const partialPaid = Number(statusInfo.paidAmount) || 0;
                  const remainder = validPrice - partialPaid;
                  dayEntry.totals.paid += partialPaid;
                  dayEntry.totals.unpaid += remainder;
                } else if (statusInfo.status === 'unpaid') {
                  dayEntry.totals.unpaid += validPrice;
                }

                if (statusInfo.status === 'absent') {
                  dayEntry.stats.absences += 1;
                  dayEntry.indicators.add('absent');
                  aggregates.absenceCount += 1;
                }
              });

              if (classEntry.students.length === 0 && !(skipInfo && skipInfo.type)) {
                return;
              }

              classEntry.students.sort((a, b) => a.name.localeCompare(b.name));
              dayEntry.groups.push(classEntry);
              dayEntry.stats.classes += 1;
              aggregates.classes += 1;

              if (skipInfo) {
                dayEntry.stats.skipped += 1;
                dayEntry.indicators.add('skipped');
                aggregates.skippedCount += 1;
                if (skipInfo.type === 'class-canceled') {
                  // Keep indicator but note cancellation
                  dayEntry.indicators.add('class');
                }
              } else {
                dayEntry.indicators.add('class');
              }

              eventsFlat.push({
                type: 'class',
                date: occurrence.dateStr,
                groupName: groupDisplay,
                groupCode: groupCode,
                students: classEntry.students.length,
                skipped: Boolean(skipInfo),
              });
            });
          });
        }

        function addStudentMilestones(rawStudents) {
          (rawStudents || []).forEach(student => {
            if (!shouldIncludeStudent(student)) return;

            const candidateDates = [];
            if (student.start_date) {
              candidateDates.push({ type: 'studentJoin', value: student.start_date, label: 'Joined Program' });
            }
            if (student.created_at) {
              candidateDates.push({ type: 'studentJoin', value: student.created_at, label: 'Student Added' });
            }
            if (student.birthdate || student.birthday) {
              const source = student.birthdate || student.birthday;
              const birthParts = parseDateParts(source);
              if (birthParts) {
                const normalizedBirthday = `${year}-${String(birthParts.month).padStart(2, '0')}-${String(birthParts.day).padStart(2, '0')}`;
                candidateDates.push({ type: 'studentBirthday', value: normalizedBirthday, label: 'Birthday' });
              }
            }

            candidateDates.forEach(eventInfo => {
              const targetDateStr = normalizeDateInput(eventInfo.value);
              const parts = parseDateParts(targetDateStr);
              if (!parts || parts.year !== year || parts.month !== month + 1) return;
              const dayEntry = dayMap[parts.day];
              if (!dayEntry) return;

              const event = {
                type: eventInfo.type,
                studentName: student.name,
                label: eventInfo.label,
              };

              dayEntry.studentEvents.push(event);
              dayEntry.indicators.add(eventInfo.type);
              eventsFlat.push({ type: eventInfo.type, date: targetDateStr, studentName: student.name });
            });
          });
        }
      }

      // ============================================================================
      // SCHEDULING CONFLICT DETECTION
      // ============================================================================
      
      /**
       * Check if a student has overlapping classes on the same date
       * Returns conflict info if found, null otherwise
       */
      async function checkSchedulingConflict(studentId, classDate, startTime, endTime, excludeGroupId = null) {
        try {
          const students = window.studentsCache || [];
          const groups = window.groupsCache || [];
          const student = students.find(s => s.id === studentId);
          
          if (!student) {
            // console.warn('Student not found:', studentId);
            return null;
          }
          
          // Get all groups this student is in
          const studentGroups = deriveStudentGroups(student);
          
          // Check each group for classes on this date
          const conflicts = [];
          
          for (const groupCode of studentGroups) {
            const normalized = normalizeGroupKey(groupCode);
            const group = groups.find(g => {
              const gCode = g.group_code || canonicalizeGroupCode(g.group_name || g.name || '');
              return normalized === normalizeGroupKey(gCode || '');
            });
            
            if (!group || (excludeGroupId && group.id === excludeGroupId)) continue;
            
            // Check if this group has a class on the target date
            const sessions = parseScheduleString(group.schedule || '');
            const targetDate = createDateFromDateStr(classDate);
            if (!targetDate) continue;
            
            const targetWeekday = getLAWeekdayName(targetDate);
            
            for (const session of sessions) {
              if (session.day === targetWeekday) {
                // Parse times and check for overlap
                const sessionStart = parseTimeToMinutes(session.time);
                const sessionEnd = sessionStart + 60; // Assume 60 min classes
                const newStart = parseTimeToMinutes(startTime);
                const newEnd = parseTimeToMinutes(endTime);
                
                // Check for time overlap
                if (newStart < sessionEnd && newEnd > sessionStart) {
                  conflicts.push({
                    groupName: group.group_name || group.name,
                    groupCode: group.group_code,
                    time: session.time,
                    date: classDate,
                    day: session.day
                  });
                }
              }
            }
            
            // Check one-time schedules
            if (Array.isArray(group.one_time_schedules)) {
              for (const override of group.one_time_schedules) {
                const overrideDate = normalizeDateInput(override.date);
                if (overrideDate === classDate) {
                  const sessionStart = parseTimeToMinutes(override.time);
                  const sessionEnd = sessionStart + 60;
                  const newStart = parseTimeToMinutes(startTime);
                  const newEnd = parseTimeToMinutes(endTime);
                  
                  if (newStart < sessionEnd && newEnd > sessionStart) {
                    conflicts.push({
                      groupName: group.group_name || group.name,
                      groupCode: group.group_code,
                      time: override.time,
                      date: classDate,
                      day: getLAWeekdayName(targetDate),
                      isOneTime: true
                    });
                  }
                }
              }
            }
          }
          
          if (conflicts.length > 0) {
            return {
              hasConflict: true,
              conflicts,
              message: `Student ${student.name} is already scheduled for ${conflicts.length} class${conflicts.length > 1 ? 'es' : ''} on ${classDate}`
            };
          }
          
          return null;
        } catch (err) {
          console.error('Error checking scheduling conflict:', err);
          return null;
        }
      }
      
      /**
       * Helper function to derive student groups (copied from computeMonthData scope)
       */
      function deriveStudentGroups(student) {
        const primarySources = [student.group_code, student.group_display, student.group_name, student.group, student.groupName];
        const extra = Array.isArray(student.groups) ? student.groups : [];
        const combined = [...primarySources, ...extra]
          .map(value => (value === 'ungrouped' ? 'ungrouped' : canonicalizeGroupCode(value)))
          .filter(Boolean);

        if (combined.length === 0) return ['ungrouped'];
        return Array.from(new Set(combined));
      }
      
      /**
       * Helper function to normalize group key
       */
      function normalizeGroupKey(value) {
        if (!value || value === 'ungrouped') return 'ungrouped';
        const normalized = canonicalizeGroupCode(value);
        return normalized || 'ungrouped';
      }
      
      // ============================================================================
      // CREDIT BALANCE & PREPAYMENT TRACKING
      // ============================================================================
      
      /**
       * Calculate student's accurate balance based only on allocated payments
       * This prevents showing negative balances when students prepay
       */
      function calculateStudentBalance(student, studentId) {
        try {
          // Get all payments for this student
          const payments = window.paymentsCache || [];
          const studentPayments = payments.filter(p => {
            if (!p) return false;
            
            // Check direct ID match
            const paymentStudentId = p.student_id || p.studentid || p.linked_student_id;
            if (paymentStudentId && String(paymentStudentId) === String(studentId)) {
              return true;
            }
            
            // Check name match
            const studentName = (student?.name || '').toLowerCase().trim();
            const paymentName = (p.student_name || p.studentName || '').toLowerCase().trim();
            const payerName = (p.payer_name || p.payer || '').toLowerCase().trim();
            
            return studentName && (paymentName === studentName || payerName === studentName);
          });
          
          // Get payment coverage (what's been allocated to classes)
          const coverageMap = window.studentPaymentCoverage;
          const coverage = coverageMap?.get(String(studentId));
          
          // Sum all payments
          const totalPaid = studentPayments.reduce((sum, p) => {
            return sum + (Number(p.amount) || 0);
          }, 0);
          
          // Sum all allocated payments (what's been used for classes)
          let totalAllocated = 0;
          if (coverage && typeof coverage.get === 'function') {
            for (const [dateStr, allocationInfo] of coverage) {
              totalAllocated += Number(allocationInfo.amount) || 0;
            }
          }
          
          // Calculate credit balance (payments not yet allocated)
          const creditBalance = totalPaid - totalAllocated;
          
          // Get stored balance from student record (may include manual adjustments)
          const storedBalance = Number(student?.balance) || 0;
          
          // Use the greater of stored balance or calculated credit
          // This accounts for manual balance additions
          const finalBalance = Math.max(creditBalance, storedBalance);
          
          debugLog(`💰 Balance for ${student?.name || studentId}:`, {
            totalPaid,
            totalAllocated,
            creditBalance,
            storedBalance,
            finalBalance
          });
          
          return {
            totalPaid,
            totalAllocated,
            creditBalance,
            storedBalance,
            finalBalance
          };
        } catch (err) {
          console.error('Error calculating student balance:', err);
          return {
            totalPaid: 0,
            totalAllocated: 0,
            creditBalance: 0,
            storedBalance: Number(student?.balance) || 0,
            finalBalance: Number(student?.balance) || 0
          };
        }
      }
      
      /**
       * Handle prepayments by adding to student's credit balance
       * instead of trying to allocate to future classes
       */
      async function recordPrepayment(studentId, amount, paymentDate, memo = '') {
        try {
          const students = window.studentsCache || [];
          const student = students.find(s => s.id === studentId);
          
          if (!student) {
            throw new Error('Student not found');
          }
          
          // Calculate current accurate balance
          const balanceInfo = calculateStudentBalance(student, studentId);
          const newBalance = balanceInfo.finalBalance + amount;
          
          // Update student balance in database
          const { error: updateError } = await supabase
            .from('students')
            .update({ balance: newBalance })
            .eq('id', studentId);
          
          if (updateError) {
            throw new Error(`Failed to update student balance: ${updateError.message}`);
          }
          
          // Record the payment
          const paymentRecord = {
            student_id: studentId,
            student_name: student.name,
            amount: amount,
            date: paymentDate,
            email_date: paymentDate + 'T12:00:00',
            timestamp: new Date().toISOString(),
            payer_name: student.name,
            message: memo || 'Prepayment/Credit added',
            source: 'manual',
            is_manual: true,
            is_prepayment: true,
            ignored: false
          };
          
          const { error: paymentError } = await supabase
            .from('payments')
            .insert([paymentRecord]);
          
          if (paymentError) {
            throw new Error(`Failed to record payment: ${paymentError.message}`);
          }
          
          debugLog('✅ Prepayment recorded:', {
            student: student.name,
            amount,
            oldBalance: balanceInfo.finalBalance,
            newBalance
          });
          
          // Refresh data
          await loadPayments();
          student.balance = newBalance; // Update cache
          clearMonthCache();
          renderCalendar();
          
          return {
            success: true,
            oldBalance: balanceInfo.finalBalance,
            newBalance,
            message: `Added ${formatCurrency(amount)} $ credit. New balance: ${formatCurrency(newBalance)} $`
          };
        } catch (err) {
          console.error('Error recording prepayment:', err);
          throw err;
        }
      }

      // ============================================================================
      // DATA LOADING FROM SUPABASE
      // ============================================================================
      
      // Load all students from Supabase
      async function loadStudents() {
        try {
          const { data, error } = await supabase
            .from('students')
            .select('*')
            .order('name');
            
          if (error) {
            console.error('❌ Error loading students:', error);
            return [];
          }
          
          const normalizedStudents = (data || []).map(record => {
            const groupCode = record.group_code || canonicalizeGroupCode(record.group_name || record.group || record.groupName || '');
            const groupDisplay = groupCode ? formatGroupDisplay(groupCode) : (record.group_name || record.group || record.groupName || 'No Group');
            
            const normalized = {
              ...record,
              group_code: groupCode,
              group_display: groupDisplay,
            };
            
            return normalized;
          });
          window.studentsCache = normalizedStudents;
          return window.studentsCache;
        } catch (err) {
          console.error('❌ Exception loading students:', err);
          return [];
        }
      }
      
      // Load all groups from Supabase
      async function loadGroups() {
        try {
          const { data, error } = await supabase
            .from('groups')
            .select('*')
            .order('group_name');
            
          if (error) {
            console.error('❌ Error loading groups:', error);
            return [];
          }
          
          const normalizedGroups = (data || []).map(record => {
            const groupCode = record.group_code || canonicalizeGroupCode(record.group_name || record.name || '');
            const displayName = groupCode ? formatGroupDisplay(groupCode) : (record.group_name || record.name || 'Untitled Group');
            
            const normalized = {
              ...record,
              group_code: groupCode,
              group_display: displayName,
            };
            
            return normalized;
          });
          window.groupsCache = normalizedGroups;
          return window.groupsCache;
        } catch (err) {
          console.error('❌ Exception loading groups:', err);
          return [];
        }
      }
      
      // Load all payments from Supabase
      async function loadPayments() {
        try {
          const { data, error } = await supabase
            .from('payments')
            .select('*')
            .order('email_date', { ascending: false });
            
          if (error) {
            console.error('❌ Error loading payments:', error);
            return [];
          }
          
          window.paymentsCache = data || [];
          return window.paymentsCache;
        } catch (err) {
          console.error('❌ Exception loading payments:', err);
          return [];
        }
      }
      
      // Load absences from Supabase
      async function loadAbsences() {
        try {
          const { data, error } = await supabase
            .from('student_absences')
            .select('*');
            
          if (error) {
            console.error('❌ Error loading absences:', error);
            return {};
          }
          
          // Convert to object format: { studentId: { 'YYYY-MM-DD': true } }
          const absences = {};
          let totalAbsences = 0;
          (data || []).forEach(record => {
            const studentId = record.student_id != null ? String(record.student_id) : null;
            const dateStr = normalizeDateInput(record.class_date || record.date);
            if (!studentId || !dateStr) {
              // console.warn('⚠️ Skipping invalid absence record:', record);
              return;
            }
            if (!absences[studentId]) {
              absences[studentId] = {};
            }
            absences[studentId][dateStr] = true;
            totalAbsences++;
          });
          
          return absences;
        } catch (err) {
          console.error('❌ Exception loading absences:', err);
          return {};
        }
      }
      
      // Load skipped/canceled classes from Supabase
      async function loadSkippedClasses() {
        try {
          const { data, error } = await supabase
            .from('skipped_classes')
            .select('*');
            
          if (error) {
            console.error('❌ Error loading skipped classes:', error);
            return {};
          }
          
          // Convert to object format: { groupName: { 'YYYY-MM-DD': { type, note } } }
          const skipped = {};
          (data || []).forEach(record => {
            const groupName = record.group_name;
            const dateStr = normalizeDateInput(record.class_date || record.date);
            if (!groupName || !dateStr) return;
            if (!skipped[groupName]) {
              skipped[groupName] = {};
            }
            skipped[groupName][dateStr] = {
              type: record.skip_type || 'class-canceled',
              note: record.note || null
            };
          });
          
          return skipped;
        } catch (err) {
          console.error('❌ Exception loading skipped classes:', err);
          return {};
        }
      }

      // Load credit payments (when balances are used to cover classes)
      async function loadCreditPayments() {
        try {
          const { data, error } = await supabase
            .from('credit_payments')
            .select('*')
            .order('class_date', { ascending: false });

          if (error) {
            console.error('❌ Error loading credit payments:', error);
            window.creditPaymentsCache = [];
            return {};
          }

          window.creditPaymentsCache = data || [];
          creditPaymentsLookup = buildCreditPaymentLookup(window.creditPaymentsCache);
          const studentCount = Object.keys(creditPaymentsLookup).length;
          debugLog(
            `✅ Loaded ${window.creditPaymentsCache.length} credit payments for ${studentCount} student${studentCount === 1 ? '' : 's'}`
          );
          return creditPaymentsLookup;
        } catch (err) {
          console.error('❌ Exception loading credit payments:', err);
          window.creditPaymentsCache = [];
          return {};
        }
      }

      function buildCreditPaymentLookup(records) {
        const lookup = {};
        (records || []).forEach(record => {
          if (!record || !record.student_id) return;
          const studentKey = String(record.student_id);
          const dateStr = normalizeDateInput(record.created_at || record.class_date);
          if (!dateStr) return;
          if (!lookup[studentKey]) {
            lookup[studentKey] = {};
          }
          lookup[studentKey][dateStr] = { ...record, la_date: dateStr };
        });
        return lookup;
      }

      // ============================================================================
      // ABSENT MANAGER - Cloud Sync for Student Absences ☁️
      // ============================================================================
      /**
       * Absent Manager - Supabase Cloud Sync Version
       * - Tracks which students were absent on which dates
       * - Syncs across all devices via Supabase student_absences table
       * - Fallback to localStorage for offline support
       */
      // ============================================================
      // AUTOMATED ABSENCE EMAIL SYSTEM
      // ============================================================
      async function sendAbsenceEmail(studentId, dateStr) {
        try {
          debugLog('📧 Sending absence email...', { studentId, dateStr });
          
          // Get student information
          const students = window.studentsCache || [];
          const student = students.find(s => s.id === parseInt(studentId));
          
          if (!student) {
            throw new Error('Student not found');
          }
          
          debugLog('📧 Student email check:', { 
            name: student.name, 
            email: student.email, 
            emailType: typeof student.email 
          });
          
          if (!student.email) {
            throw new Error('Student has no email address');
          }
          
          // Parse email if it's JSON array string
          let cleanEmail = String(student.email).trim();
          
          // Check if email is a JSON array string like '["email@example.com"]'
          if (cleanEmail.startsWith('[') && cleanEmail.endsWith(']')) {
            try {
              const parsed = JSON.parse(cleanEmail);
              if (Array.isArray(parsed) && parsed.length > 0) {
                cleanEmail = String(parsed[0]).trim();
                debugLog('📧 Parsed email from JSON array:', cleanEmail);
              }
            } catch (e) {
              // console.warn('⚠️ Failed to parse email JSON:', e);
            }
          }
          
          // Validate email format
          const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
          
          if (!emailRegex.test(cleanEmail)) {
            throw new Error(`Invalid email format: "${cleanEmail}" - Please update student's email in Student Manager`);
          }
          
          // Format the date nicely
          const dateObj = new Date(dateStr + 'T00:00:00');
          const formattedDate = dateObj.toLocaleDateString('en-US', { 
            weekday: 'long', 
            year: 'numeric', 
            month: 'long', 
            day: 'numeric' 
          });
          
          // Generate email HTML
          const emailHTML = generateAbsenceEmailHTML(student.name, formattedDate, dateStr);
          
          debugLog('📧 Sending to email:', cleanEmail);
          
          // Send email via Supabase Edge Function
          const response = await fetch(`${SUPABASE_URL}/functions/v1/send-email`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
            },
            body: JSON.stringify({
              to: cleanEmail,
              subject: `⚠️ Absence Notice - ${formattedDate}`,
              html: emailHTML,
            }),
          });
          
          if (!response.ok) {
            const errorData = await response.json().catch(() => ({}));
            console.error('❌ Email API error response:', errorData);
            const errorMsg = errorData.error?.message || errorData.error || 'Unknown error';
            throw new Error(`Email API error: ${errorMsg}`);
          }
          
          const result = await response.json();
          
          // Check if the result contains an error (Resend returns success:true but includes error details)
          if (result.data && result.data.error) {
            console.error('❌ Email service error:', result.data.error);
            throw new Error(`Email service error: ${result.data.error.message || JSON.stringify(result.data.error)}`);
          }
          
          debugLog('✅ Absence email sent successfully:', result);
          
          // Log to sent_emails and notifications tables
          try {
            const resendEmailId = result?.id || result?.data?.id || null;
            
            // 1. Log to sent_emails table (for Email System)
            const sentEmailRecord = {
              recipient_email: cleanEmail,
              recipient_name: student.name,
              subject: `⚠️ Absence Notice - ${formattedDate}`,
              html_content: emailHTML,
              template_name: 'Absence Notice',
              email_type: 'absence_notice',
              resend_id: resendEmailId,
              delivery_status: 'delivered',
              status: 'sent',
              sent_at: new Date().toISOString()
            };
            
            const { data: logData, error: logError } = await supabase.from('sent_emails').insert([sentEmailRecord]).select();
            
            if (logError) {
              console.error('⚠️ Failed to log to sent_emails:', logError);
            } else {
              debugLog('✅ Absence email logged to sent_emails:', logData[0]);
            }
            
            // 2. Log to notifications table (for Notification Center bell)
            const notificationRecord = {
              type: 'email_sent',
              category: 'email',
              title: 'Absence Notice Sent',
              description: `Sent absence notice to ${student.name} (${cleanEmail}) for ${formattedDate}`,
              student_name: student.name,
              metadata: {
                student_id: studentId,
                student_name: student.name,
                email: cleanEmail,
                absence_date: dateStr,
                email_type: 'absence_notice',
                subject: `⚠️ Absence Notice - ${formattedDate}`,
                html: emailHTML
              },
              timestamp: new Date().toISOString(),
              read: false,
              created_at: new Date().toISOString()
            };
            
            const { data: notifData, error: notifError } = await supabase.from('notifications').insert([notificationRecord]).select();
            
            if (notifError) {
              console.error('⚠️ Failed to log to notifications:', notifError);
            } else {
              debugLog('✅ Notification logged:', notifData[0]);
            }
            
          } catch (logErr) {
            console.error('⚠️ Error logging notifications (email still sent):', logErr);
          }
          
          return result;
        } catch (err) {
          console.error('❌ Error sending absence email:', err);
          throw err;
        }
      }
      
      function generateAbsenceEmailHTML(studentName, formattedDate, dateStr) {
        return `<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ARNOMA NCLEX-RN Email</title>
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      padding: 0;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      padding: 40px 20px;
    }
    .email-wrapper {
      max-width: 600px;
      margin: 0 auto;
    }
    .email-container {
      background-color: #ffffff;
      border-radius: 16px;
      overflow: hidden;
      box-shadow: 0 20px 60px rgba(0,0,0,0.3);
    }
    .email-header {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      padding: 45px 35px 35px;
      text-align: center;
    }
    .email-header img {
      width: 140px;
      height: 140px;
      margin-bottom: 15px;
      filter: drop-shadow(0 0 6px rgba(255,255,255,0.7))
              drop-shadow(0 0 12px rgba(255,255,255,0.4))
              drop-shadow(0 0 3px rgba(255,255,255,0.8));
      animation: fadeIn 1.5s ease-in-out;
    }
    .email-header h1 {
      color: #fff;
      margin: 0;
      font-size: 28px;
      letter-spacing: -0.5px;
    }
    @keyframes fadeIn {
      from { opacity: 0; transform: scale(0.9); }
      to { opacity: 1; transform: scale(1); }
    }
    .email-body {
      padding: 35px;
      color: #333;
      font-size: 16px;
      line-height: 1.6;
    }
    .email-body p {
      margin: 0 0 16px 0;
    }
    .info-box {
      background-color: #f6f8fe;
      border-left: 3px solid #3b82f6;
      border-radius: 10px;
      padding: 14px 18px;
      font-size: 15px;
      line-height: 1.5;
      color: #1e293b;
      margin: 20px 0;
      box-shadow: 0 2px 6px rgba(0,0,0,0.05);
    }
    .info-box p {
      margin: 6px 0;
      text-align: left;
    }
    .info-box strong {
      color: #1e40af;
    }
    .warning-box {
      background-color: #fef3c7;
      border-left: 3px solid #f59e0b;
      border-radius: 10px;
      padding: 14px 18px;
      font-size: 15px;
      line-height: 1.5;
      color: #78350f;
      margin: 20px 0;
      box-shadow: 0 2px 6px rgba(0,0,0,0.05);
    }
    .warning-box p {
      margin: 6px 0;
      text-align: left;
    }
    .highlight-box {
      background: linear-gradient(135deg, #ecfdf5 0%, #d1fae5 100%);
      border-left: 3px solid #10b981;
      border-radius: 10px;
      padding: 18px;
      font-size: 15px;
      line-height: 1.6;
      color: #065f46;
      margin: 24px 0;
      box-shadow: 0 2px 8px rgba(16, 185, 129, 0.1);
    }
    .highlight-box p {
      margin: 6px 0;
      text-align: left;
    }
    .highlight-box strong {
      color: #047857;
      font-size: 16px;
    }
    .divider {
      height: 1px;
      background: linear-gradient(to right, transparent, rgba(0,0,0,0.1) 20%, rgba(0,0,0,0.1) 80%, transparent);
      margin: 24px 0;
      border: none;
    }
    .email-footer {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: #fff;
      text-align: center;
      padding: 30px 20px;
    }
    .email-footer img {
      width: 100px;
      height: 100px;
      margin: 10px 0;
      filter: drop-shadow(0 0 5px rgba(255,255,255,0.6))
              drop-shadow(0 0 10px rgba(255,255,255,0.3))
              drop-shadow(0 0 2px rgba(255,255,255,0.8));
    }
    .email-footer p {
      margin: 6px 0;
      font-size: 13px;
    }
    @media (max-width: 600px) {
      body { padding: 20px 10px; }
      .email-body { padding: 25px 20px; font-size: 15px; }
      .email-header img { width: 110px; height: 110px; }
    }
  </style>
</head>
<body>
  <div class="email-wrapper">
    <div class="email-container">
      <!-- Header -->
      <div class="email-header">
        <img src="https://raw.githubusercontent.com/easylearnrn-hash/ARNOMA/main/richyfesta-logo.png" alt="ARNOMA Logo">
        <h1>Absence Notice</h1>
      </div>

      <!-- Body -->
      <div class="email-body">
        <p><strong>Hi ${studentName},</strong></p>
        
        <p>
          This email is to inform you that you have been marked as <strong>absent</strong> for the following class:
        </p>

        <div class="info-box">
          <p><strong>Class Date:</strong> ${formattedDate}</p>
        </div>

        <div class="warning-box">
          <p><strong>What this means:</strong></p>
          <p>• Your attendance for this class has been recorded as absent</p>
          <p>• If you no longer wish to attend the class, please notify the instructor</p>
        </div>

        <hr class="divider">

        <div class="highlight-box">
          <p><strong>📚 Want to Get the Class Notes?</strong></p>
          <p>If you would like to receive the notes we went over during this class, you can make the payment for the class and the notes will be sent to you <strong>within 30 minutes</strong>.</p>
          <p style="margin-top: 12px;">Simply make the payment and we'll email you the complete class materials right away!</p>
        </div>

        <hr class="divider">

        <p style="margin-top: 24px;">
          <strong>Need Help?</strong><br>
          Contact your instructor or reply to this email for assistance.
        </p>
      </div>

      <!-- Footer -->
      <div class="email-footer">
        <img src="https://raw.githubusercontent.com/easylearnrn-hash/ARNOMA/main/richyfesta-logo.png" alt="ARNOMA Logo">
        <p><strong style="font-size: 18px;">ARNOMA – NCLEX RN</strong></p>
        <p style="font-size: 14px;">Professional NCLEX Preparation & Medical Education</p>
        <p style="font-size: 13px;">
          nclex.rn@arnoma.us<br>
          richy@arnoma.us<br>
          909-808-1818
        </p>
        <p style="font-size: 12px; color: #95a5a6;">
          © ${new Date().getFullYear()} ARNOMA. All rights reserved.
        </p>
        <p style="font-size: 12px; color: #7f8c8d;">
          This is an automated notification from your ARNOMA NCLEX prep program.
        </p>
      </div>
    </div>
  </div>
</body>
</html>`;
      }

      // ============================================================
      // PAYMENT REMINDER EMAIL
      // ============================================================
      async function sendPaymentReminderEmail(studentId) {
        try {
          debugLog('📧 Sending payment reminder email...', { studentId });
          
          // Get student information
          const students = window.studentsCache || [];
          const student = students.find(s => s.id === parseInt(studentId));
          
          if (!student) {
            throw new Error('Student not found');
          }
          
          debugLog('📧 Student email check:', { 
            name: student.name, 
            email: student.email, 
            emailType: typeof student.email 
          });
          
          if (!student.email) {
            throw new Error('Student has no email address');
          }
          
          // Parse email if it's JSON array string
          let cleanEmail = String(student.email).trim();
          
          // Check if email is a JSON array string like '["email@example.com"]'
          if (cleanEmail.startsWith('[') && cleanEmail.endsWith(']')) {
            try {
              const parsed = JSON.parse(cleanEmail);
              if (Array.isArray(parsed) && parsed.length > 0) {
                cleanEmail = String(parsed[0]).trim();
                debugLog('📧 Parsed email from JSON array:', cleanEmail);
              }
            } catch (e) {
              // console.warn('⚠️ Failed to parse email JSON:', e);
            }
          }
          
          // Validate email format
          const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
          
          if (!emailRegex.test(cleanEmail)) {
            throw new Error(`Invalid email format: "${cleanEmail}" - Please update student's email in Student Manager`);
          }
          
          // Get student balance and price
          const balance = Number(student.balance) || 0;
          const pricePerClass = Number(student.price_per_class) || 0;
          
          console.log('📊 Student data from cache:', {
            studentId,
            name: student.name,
            balance,
            pricePerClass,
            rawBalance: student.balance,
            rawPrice: student.price_per_class
          });
          
          // CRITICAL: Count ACTUAL unpaid red dots from the current calendar display
          // The balance field may be stale - we need to count visible unpaid classes
          let unpaidClassesFromCalendar = 0;
          let unpaidAmountFromCalendar = 0;
          
          // Look at the currently displayed calendar cells (use .indicator-dot class)
          const calendarDots = document.querySelectorAll(`.indicator-dot[data-student-id="${studentId}"]`);
          console.log(`🔴 Found ${calendarDots.length} calendar dots for student ${studentId}`);
          
          calendarDots.forEach(dot => {
            const status = dot.dataset.status || dot.getAttribute('data-status');
            const price = parseFloat(dot.dataset.price || dot.getAttribute('data-price') || pricePerClass);
            const dateStr = dot.dataset.date || dot.getAttribute('data-date');
            
            console.log(`  Dot on ${dateStr}: status=${status}, price=${price}`);
            
            if (status === 'unpaid') {
              unpaidClassesFromCalendar++;
              unpaidAmountFromCalendar += price;
            }
          });
          
          console.log('💰 Unpaid classes from visible calendar:', {
            count: unpaidClassesFromCalendar,
            amount: unpaidAmountFromCalendar
          });
          
          // Use calendar data if we found unpaid classes, otherwise fall back to balance
          const finalBalance = unpaidAmountFromCalendar > 0 ? unpaidAmountFromCalendar : balance;
          const finalPrice = pricePerClass || 15;
          
          // Generate email HTML (async now - loads from Email System)
          const emailHTML = await generatePaymentReminderEmailHTML(student.name, finalBalance, finalPrice, studentId);
          
          debugLog('📧 Sending payment reminder to:', cleanEmail);
          
          // Send email via Supabase Edge Function
          const response = await fetch(`${SUPABASE_URL}/functions/v1/send-email`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
            },
            body: JSON.stringify({
              to: cleanEmail,
              subject: `Payment Reminder - ARNOMA NCLEX-RN`,
              html: emailHTML,
            }),
          });
          
          if (!response.ok) {
            const errorData = await response.json().catch(() => ({}));
            console.error('❌ Email API error response:', errorData);
            const errorMsg = errorData.error?.message || errorData.error || 'Unknown error';
            throw new Error(`Email API error: ${errorMsg}`);
          }
          
          const result = await response.json();
          
          // Check if the result contains an error
          if (result.data && result.data.error) {
            console.error('❌ Email service error:', result.data.error);
            throw new Error(`Email service error: ${result.data.error.message || JSON.stringify(result.data.error)}`);
          }
          
          debugLog('✅ Payment reminder email sent successfully:', result);
          
          console.log('🔥 ABOUT TO LOG EMAIL TO sent_emails TABLE');
          
          // CRITICAL: Log to BOTH notification systems
          try {
            const resendEmailId = result?.id || result?.data?.id || null;
            
            // 1. Log to sent_emails table (for Email System)
            const sentEmailRecord = {
              recipient_email: cleanEmail,
              recipient_name: student.name,
              subject: `Payment Reminder - ARNOMA NCLEX-RN`,
              html_content: emailHTML,
              template_name: 'Payment Reminder',
              email_type: 'payment_reminder',
              resend_id: resendEmailId,
              delivery_status: 'delivered',
              status: 'sent',
              sent_at: new Date().toISOString()
            };
            
            console.log('📝 sentEmailRecord:', sentEmailRecord);
            
            const { data: logData, error: logError } = await supabase
              .from('sent_emails')
              .insert([sentEmailRecord])
              .select();
            
            console.log('💾 Supabase sent_emails response:', { logData, logError });
            
            if (logError) {
              console.error('⚠️ Failed to log to sent_emails:', logError);
            } else {
              debugLog('✅ Payment reminder logged to sent_emails:', logData[0]);
            }
            
            // 2. Log to notifications table (for Notification Center bell)
            const notificationRecord = {
              type: 'email_sent',
              category: 'email',  // For UI rendering (getCategoryIcon)
              title: 'Payment Reminder Sent',
              description: `Sent payment reminder to ${student.name} (${cleanEmail}) for $${finalBalance}`,
              student_name: student.name,
              metadata: {
                student_id: studentId,
                student_name: student.name,
                email: cleanEmail,
                amount: finalBalance,
                email_type: 'payment_reminder',
                subject: `Payment Reminder - ARNOMA NCLEX-RN`,
                html: emailHTML  // Full email HTML for preview
              },
              timestamp: new Date().toISOString(),
              read: false,
              created_at: new Date().toISOString()
            };
            
            const { data: notifData, error: notifError } = await supabase
              .from('notifications')
              .insert([notificationRecord])
              .select();
            
            console.log('🔔 Supabase notifications response:', { notifData, notifError });
            
            if (notifError) {
              console.error('⚠️ Failed to log to notifications:', notifError);
            } else {
              debugLog('✅ Notification logged:', notifData[0]);
            }
            
          } catch (logErr) {
            console.error('⚠️ Error logging notifications (email still sent):', logErr);
          }
          
          return result;
        } catch (err) {
          console.error('❌ Error sending payment reminder email:', err);
          throw err;
        }
      }
      
      // Generate email HTML using Email System template structure
      function generateEmailHTML(title, bodyContent) {
        return `<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ARNOMA NCLEX-RN Email</title>
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      padding: 0;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      padding: 40px 20px;
    }
    .email-wrapper {
      max-width: 600px;
      margin: 0 auto;
    }
    .email-container {
      background-color: #ffffff;
      border-radius: 16px;
      overflow: hidden;
      box-shadow: 0 20px 60px rgba(0,0,0,0.3);
    }
    .email-header {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      padding: 45px 35px 35px;
      text-align: center;
    }
    .email-header img {
      width: 140px;
      height: 140px;
      margin-bottom: 15px;
      filter: drop-shadow(0 0 6px rgba(255,255,255,0.7))
              drop-shadow(0 0 12px rgba(255,255,255,0.4))
              drop-shadow(0 0 3px rgba(255,255,255,0.8));
      animation: fadeIn 1.5s ease-in-out;
    }
    .email-header h1 {
      color: #fff;
      margin: 0;
      font-size: 28px;
      letter-spacing: -0.5px;
    }
    @keyframes fadeIn {
      from { opacity: 0; transform: scale(0.9); }
      to { opacity: 1; transform: scale(1); }
    }
    .email-body {
      padding: 35px;
      color: #333;
      font-size: 16px;
      line-height: 1.6;
    }
    .email-body p {
      margin: 0 0 16px 0;
    }
    .email-body img {
      display: block;
      max-width: 100%;
      height: auto;
      margin: 20px auto;
      border-radius: 12px;
      box-shadow: 0 6px 20px rgba(0,0,0,0.15);
    }
    .payment-frame {
      background-color: #f8f9fc;
      border: 2px solid #e5e7eb;
      border-radius: 12px;
      padding: 20px;
      margin: 24px 0;
      text-align: center;
      box-shadow: 0 2px 8px rgba(0,0,0,0.08);
    }
    .payment-frame img {
      margin: 12px auto;
      border-radius: 8px;
      box-shadow: none;
    }
    .info-box {
      background-color: #f6f8fe;
      border-left: 3px solid #3b82f6;
      border-radius: 10px;
      padding: 14px 18px;
      font-size: 15px;
      line-height: 1.5;
      color: #1e293b;
      margin: 20px 0;
      box-shadow: 0 2px 6px rgba(0,0,0,0.05);
    }
    .info-box p {
      margin: 6px 0;
      text-align: left;
    }
    .divider {
      height: 1px;
      background: linear-gradient(to right, transparent, rgba(255,255,255,0.3) 20%, rgba(255,255,255,0.3) 80%, transparent);
      margin: 24px 0;
      border: none;
    }
    .email-footer {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: #fff;
      text-align: center;
      padding: 30px 20px;
    }
    .email-footer img {
      width: 100px;
      height: 100px;
      margin: 10px 0;
      filter: drop-shadow(0 0 5px rgba(255,255,255,0.6))
              drop-shadow(0 0 10px rgba(255,255,255,0.3))
              drop-shadow(0 0 2px rgba(255,255,255,0.8));
    }
    .email-footer p {
      margin: 6px 0;
      font-size: 13px;
    }
    @media (max-width: 600px) {
      body { padding: 20px 10px; }
      .email-body { padding: 25px 20px; font-size: 15px; }
      .email-header img { width: 110px; height: 110px; }
    }
  </style>
</head>
<body>
  <div class="email-wrapper">
    <div class="email-container">
      <div class="email-header">
        <img src="https://raw.githubusercontent.com/easylearnrn-hash/ARNOMA/main/richyfesta-logo.png" alt="ARNOMA Logo">
        <h1>${title}</h1>
      </div>

      <div class="email-body">
        ${bodyContent}
      </div>

      <div class="email-footer">
        <img src="https://raw.githubusercontent.com/easylearnrn-hash/ARNOMA/main/richyfesta-logo.png" alt="ARNOMA Logo">
        <p><strong style="font-size: 18px;">ARNOMA – NCLEX RN</strong></p>
        <p style="font-size: 14px;">Professional NCLEX Preparation & Medical Education</p>
        <p style="font-size: 13px;">
          nclex.rn@arnoma.us<br>
          richy@arnoma.us<br>
          909-808-1818
        </p>
        <p style="font-size: 12px; color: #95a5a6;">
          © 2025 ARNOMA. All rights reserved.
        </p>
        <p style="font-size: 12px; color: #7f8c8d;">
          This is an automated notification from your ARNOMA NCLEX prep program.
        </p>
      </div>
    </div>
  </div>
</body>
</html>`;
      }

      async function generatePaymentReminderEmailHTML(studentName, balance, pricePerClass, studentId = null) {
        // Helper function to format date beautifully
        function formatClassDate(dateStr) {
          const date = new Date(dateStr + 'T12:00:00');
          const options = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
          return date.toLocaleDateString('en-US', options);
        }
        
        // Calculate unpaid amount from student balance
        // The calendar red dots show unpaid classes, and balance reflects this
        let unpaidClasses = [];
        let actualAmountDue = 0;
        let actualUnpaidCount = 0;
        
        if (studentId && balance && balance > 0) {
          // Student has positive balance = money owed
          actualAmountDue = balance;
          
          // Calculate number of unpaid classes based on price per class
          const validPricePerClass = (pricePerClass && pricePerClass > 0) ? pricePerClass : 15;
          actualUnpaidCount = Math.ceil(actualAmountDue / validPricePerClass);
          
          console.log('💰 Payment reminder - using student balance:', {
            studentId,
            studentName,
            balance,
            pricePerClass: validPricePerClass,
            unpaidCount: actualUnpaidCount,
            amountDue: actualAmountDue
          });
        } else {
          console.log('💰 Payment reminder - no balance owed:', {
            studentId,
            studentName,
            balance
          });
        }
        
        // Build unpaid classes summary HTML
        let unpaidClassesSummary = '';
        
        // Calculate actual amounts from unpaid classes
        if (unpaidClasses.length > 0) {
          actualUnpaidCount = unpaidClasses.length;
          actualAmountDue = unpaidClasses.reduce((sum, cls) => sum + cls.amount, 0);
          
          if (unpaidClasses.length === 1) {
            // Single unpaid class - simple format
            unpaidClassesSummary = `
              <div style="background: #f0f4ff; border-left: 4px solid #667eea; padding: 16px; margin: 16px 0; border-radius: 6px;">
                <p style="margin: 4px 0; font-size: 15px;"><strong>📅 ${unpaidClasses[0].formattedDate}</strong></p>
                <p style="margin: 4px 0; font-size: 15px;"><strong>Amount Due:</strong> $${unpaidClasses[0].amount.toFixed(2)}</p>
              </div>
            `;
          } else {
            // Multiple unpaid classes - beautiful list
            const classList = unpaidClasses.map((cls, index) => `
              <div style="background: ${index === unpaidClasses.length - 1 ? '#fff9e6' : '#ffffff'}; padding: 12px; margin: 8px 0; border-radius: 6px; border: 1px solid #e5e7eb;">
                <p style="margin: 4px 0; font-size: 14px; color: #6b7280;">Class ${index + 1}</p>
                <p style="margin: 4px 0; font-size: 15px;"><strong>${index === unpaidClasses.length - 1 ? '👉 ' : ''}${cls.formattedDate}</strong></p>
                <p style="margin: 4px 0; font-size: 15px; text-align: right;"><strong>$${cls.amount.toFixed(2)}</strong></p>
              </div>
            `).join('');
            
            unpaidClassesSummary = `
              <div style="background: #f9fafb; border: 2px solid #e5e7eb; border-radius: 12px; padding: 20px; margin: 20px 0;">
                <h3 style="margin: 0 0 16px 0; color: #764ba2; font-size: 18px;">💳 Outstanding Classes</h3>
                ${classList}
                <div style="background: #667eea; color: white; padding: 12px; margin: 12px 0 0 0; border-radius: 6px; text-align: right;">
                  <strong style="font-size: 16px;">Total Amount Due: $${actualAmountDue.toFixed(2)}</strong>
                </div>
              </div>
            `;
          }
        } else {
          // Fallback: calculate from balance if we couldn't fetch classes
          const normalizedBalance = Number(balance) || 0;
          actualAmountDue = normalizedBalance > 0 ? normalizedBalance : 0;
          
          // Validate pricePerClass to prevent NaN
          const validPricePerClass = (pricePerClass && pricePerClass > 0) ? pricePerClass : 15; // Default to $15 if invalid
          actualUnpaidCount = Math.ceil(actualAmountDue / validPricePerClass);
          
          // Ensure actualUnpaidCount is a valid number
          if (!Number.isFinite(actualUnpaidCount) || actualUnpaidCount < 0) {
            actualUnpaidCount = 0;
          }
          
          debugLog('💰 Using fallback calculation:', {
            balance: normalizedBalance,
            actualAmountDue,
            pricePerClass: validPricePerClass,
            unpaidCount: actualUnpaidCount
          });
          
          unpaidClassesSummary = `${actualUnpaidCount} unpaid ${actualUnpaidCount === 1 ? 'class' : 'classes'} - Total: $${actualAmountDue.toFixed(2)}`;
        }
        
        try {
          // Try to load Payment Reminder template from Email System (Supabase)
          const { data: templates, error } = await supabase
            .from('email_templates')
            .select('*')
            .eq('name', 'Payment Reminder')
            .single();
          
          if (!error && templates && templates.body) {
            debugLog('✅ Using Payment Reminder template from Email System');
            debugLog(`📊 Payment details: ${actualUnpaidCount} classes, $${actualAmountDue.toFixed(2)} total`);
            
            // Replace template variables with actual data (case-insensitive)
            let emailHTML = templates.body
              .replace(/\{\{StudentName\}\}/gi, studentName)
              .replace(/\{\{UnpaidClasses\}\}/gi, unpaidClassesSummary)
              .replace(/\{\{ClassDate\}\}/gi, new Date().toLocaleDateString())
              .replace(/\{\{PricePerClass\}\}/gi, pricePerClass.toFixed(2))
              .replace(/\{\{Balance\}\}/gi, actualAmountDue.toFixed(2))
              .replace(/\{\{AmountDue\}\}/gi, actualAmountDue.toFixed(2))
              .replace(/\{\{UnpaidClassCount\}\}/gi, actualUnpaidCount.toString())
              .replace(/\{\{TeacherEmail\}\}/gi, 'arnomaschool@gmail.com')
              .replace(/\{\{TeacherName\}\}/gi, 'ARNOMA Team');
            
            return emailHTML;
          }
        } catch (e) {
          // console.warn('⚠️ Could not load template from Email System, using fallback:', e);
        }
        
        // FALLBACK: Use hardcoded template if Email System template not found
        debugLog('ℹ️ Using fallback payment reminder template');
        const fallbackHTML = `<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ARNOMA NCLEX-RN Email</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica Neue', Arial, sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        padding: 20px;
        margin: 0;
      }

      .email-wrapper {
        width: 100%;
        max-width: 600px;
        margin: 0 auto;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        padding: 24px;
        border-radius: 16px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      }

      .email-container {
        background: white;
        border-radius: 12px;
        overflow: hidden;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
      }

      .email-header {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        padding: 40px 30px;
        text-align: center;
        position: relative;
        overflow: hidden;
      }

      .email-header::before {
        content: '';
        position: absolute;
        top: -50%;
        left: -50%;
        width: 200%;
        height: 200%;
        background: radial-gradient(circle, rgba(255, 255, 255, 0.1) 0%, transparent 70%);
        animation: pulse 15s ease-in-out infinite;
      }

      @keyframes pulse {
        0%,
        100% {
          transform: scale(1);
          opacity: 0.5;
        }
        50% {
          transform: scale(1.1);
          opacity: 0.8;
        }
      }

      .email-header img {
        width: 120px;
        height: auto;
        margin-bottom: 20px;
        position: relative;
        z-index: 1;
        filter: drop-shadow(0 4px 6px rgba(0, 0, 0, 0.1)) drop-shadow(0 0 10px rgba(255, 255, 255, 0.6)) drop-shadow(0 0 20px rgba(255, 255, 255, 0.4));
      }

      .email-header h1 {
        color: white;
        font-size: 32px;
        font-weight: 700;
        margin: 0;
        position: relative;
        z-index: 1;
        text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }

      .email-body {
        padding: 40px 30px;
        color: #1f2937;
        line-height: 1.8;
        background: white;
      }

      .email-body p {
        margin: 16px 0;
        font-size: 16px;
        color: #374151;
      }

      .email-body strong {
        color: #764ba2;
        font-weight: 600;
      }

      .info-box {
        background-color: #f6f8fe;
        border-left: 3px solid #3b82f6;
        border-radius: 10px;
        padding: 14px 18px;
        font-size: 15px;
        line-height: 1.5;
        color: #1e293b;
        margin: 20px 0;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.05);
      }

      .info-box p {
        margin: 6px 0;
        text-align: left;
      }

      .payment-instructions {
        background: #f9fafb;
        border-radius: 12px;
        padding: 24px;
        margin: 24px 0;
      }

      .payment-instructions h3 {
        color: #764ba2;
        font-size: 20px;
        margin-bottom: 16px;
        font-weight: 600;
      }

      .payment-instructions p {
        margin: 12px 0;
        color: #4b5563;
      }

      .payment-frame {
        background: linear-gradient(135deg, rgba(102, 126, 234, 0.05), rgba(118, 75, 162, 0.05));
        border: 2px solid rgba(118, 75, 162, 0.2);
        border-radius: 16px;
        padding: 32px;
        margin: 32px 0;
        text-align: center;
        box-shadow: 0 4px 12px rgba(102, 126, 234, 0.1);
      }

      .payment-frame p {
        margin: 12px 0;
        font-size: 18px;
        color: #1f2937;
      }

      .payment-frame img {
        max-width: 240px;
        height: auto;
        margin: 20px auto;
        display: block;
        border-radius: 12px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      }

      .zelle-number {
        font-size: 24px;
        font-weight: 700;
        color: #764ba2;
        margin: 16px 0;
        letter-spacing: 1px;
      }

      .email-footer {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        padding: 32px 30px;
        text-align: center;
        color: white;
      }

      .email-footer img {
        width: 80px;
        height: auto;
        margin-bottom: 16px;
        filter: brightness(0) invert(1);
        opacity: 0.9;
      }

      .email-footer p {
        margin: 8px 0;
        font-size: 14px;
        color: rgba(255, 255, 255, 0.9);
      }

      .email-footer strong {
        color: white;
        font-weight: 600;
      }

      .divider {
        height: 1px;
        background: linear-gradient(to right, transparent, rgba(118, 75, 162, 0.3), transparent);
        margin: 24px 0;
      }

      @media only screen and (max-width: 600px) {
        .email-wrapper {
          padding: 16px;
        }

        .email-header {
          padding: 30px 20px;
        }

        .email-header h1 {
          font-size: 24px;
        }

        .email-body {
          padding: 24px 20px;
        }

        .payment-frame {
          padding: 20px;
        }

        .payment-frame img {
          max-width: 200px;
        }
      }
    </style>
  </head>
  <body>
    <div class="email-wrapper">
      <div class="email-container">
        <!-- Header -->
        <div class="email-header">
          <img
            src="https://raw.githubusercontent.com/easylearnrn-hash/ARNOMA/main/richyfesta-logo.png"
            alt="ARNOMA Logo"
          />
          <h1>Payment Reminder</h1>
        </div>

        <!-- Body -->
        <div class="email-body">
          <p>
            Hello
            <strong>${studentName}</strong>
            ,
          </p>

          <p>This is a quick, automated check regarding your recent classes:</p>

          <div class="info-box">
            <p><strong>${unpaidClassesSummary}</strong></p>
          </div>

          <p>Our records show that your payment hasn't been posted yet.</p>

          <div class="divider"></div>

          <div class="payment-instructions">
            <h3>What to do:</h3>

            <p>
              <strong>If you have already paid:</strong>
              <br />
              Great! Please simply reply with the screenshot of your transfer. That's all we need to update our log and
              ensure you don't receive any more reminders.
            </p>

            <p>
              <strong>If you still plan to pay:</strong>
              <br />
              Please submit the payment at your earliest convenience. The system can only process and send your notes
              once payment is confirmed.
            </p>
          </div>

          <div class="divider"></div>

          <!-- Payment Frame -->
          <div class="payment-frame">
            <p style="font-size: 20px; margin-bottom: 8px">
              <strong>
                Send Money with
                <span style="color: #764ba2">Zelle®</span>
              </strong>
            </p>
            <p style="font-size: 14px; color: #6b7280; margin-bottom: 20px">Scan in your banking app to pay.</p>

            <p class="zelle-number">909-300-5155</p>

            <img
              src="https://raw.githubusercontent.com/easylearnrn-hash/ARNOMA/main/Arnoma%20Zelle.JPG"
              alt="Zelle QR Code"
            />

            <p style="font-size: 16px; color: #9ca3af; margin-top: 16px">
              <strong style="color: #764ba2">Zelle</strong>
            </p>
          </div>

          <p style="margin-top: 32px">Thank you for your prompt attention to this!</p>

          <p style="margin-top: 24px">
            Best regards,
            <br />
            <strong style="color: #764ba2">ARNOMA Team</strong>
          </p>
        </div>

        <!-- Footer -->
        <div class="email-footer">
          <img
            src="https://raw.githubusercontent.com/easylearnrn-hash/ARNOMA/main/richyfesta-logo.png"
            alt="ARNOMA Logo"
          />
          <p><strong>ARNOMA – NCLEX RN</strong></p>
          <p style="margin-top: 12px">nclex.rn@arnoma.us | richy@arnoma.us | 909-808-1818</p>
          <p style="margin-top: 16px; font-size: 12px; opacity: 0.8">© 2025 ARNOMA. All rights reserved.</p>
        </div>
      </div>
    </div>
  </body>
</html>`;
        
        return fallbackHTML;
      }

      // ============================================================
      // ABSENT MANAGER
      // ============================================================
      window.AbsentManager = (function () {
        // Absences data structure: { studentId: { 'YYYY-MM-DD': true } }
        let absences = {};
        let isInitialized = false;

        // Load absences from Supabase
        async function loadAbsences() {
          try {
            debugLog('☁️ Loading absences from Supabase...');
            const { data, error } = await supabase.from('student_absences').select('*');

            if (error) {
              console.error('❌ Error loading absences from Supabase:', error);
              loadAbsencesFromLocalStorage();
              return;
            }

            // Convert array to nested object: { studentId: { 'YYYY-MM-DD': true } }
            absences = {};
            let supabaseCount = 0;
            (data || []).forEach(record => {
              const studentId = record.student_id != null ? String(record.student_id) : null;
              const dateStr = normalizeDateInput(record.class_date || record.date);

              if (!studentId || !dateStr) {
                // console.warn('⚠️ AbsentManager: Skipping invalid record:', record);
                return;
              }
              if (!absences[studentId]) {
                absences[studentId] = {};
              }
              absences[studentId][dateStr] = true;
              supabaseCount++;
            });
            
            // Always merge with localStorage as fallback (in case of RLS issues)
            const localAbsences = getAbsencesFromLocalStorage();
            if (localAbsences && Object.keys(localAbsences).length > 0) {
              // Merge localStorage data into absences
              for (const studentId in localAbsences) {
                if (!absences[studentId]) {
                  absences[studentId] = {};
                }
                for (const dateStr in localAbsences[studentId]) {
                  if (localAbsences[studentId][dateStr]) {
                    absences[studentId][dateStr] = true;
                  }
                }
              }
            }
          } catch (err) {
            console.error('❌ Exception loading absences:', err);
            loadAbsencesFromLocalStorage();
          }
        }

        // Save absences to Supabase
        async function saveAbsences() {
          try {
            debugLog('☁️ Saving absences to Supabase...');

            // Convert nested object to array of records
            const records = [];
            for (const studentId in absences) {
              for (const dateStr in absences[studentId]) {
                if (absences[studentId][dateStr]) {
                  records.push({
                    student_id: parseInt(studentId),
                    class_date: dateStr,
                  });
                }
              }
            }

            // Delete all existing records
            const { error: deleteError } = await supabase.from('student_absences').delete().neq('id', 0);

            if (deleteError) {
              console.error('❌ Error deleting absences:', deleteError);
              saveAbsencesToLocalStorage();
              return;
            }

            // Insert new records
            if (records.length > 0) {
              const { error: insertError } = await supabase.from('student_absences').insert(records);

              if (insertError) {
                console.error('❌ Error inserting absences:', insertError);
                saveAbsencesToLocalStorage();
                return;
              }
            }

            debugLog('✅ Saved absences to Supabase:', records.length, 'records');
            saveAbsencesToLocalStorage(); // Keep localStorage as backup
          } catch (err) {
            console.error('❌ Exception saving absences:', err);
            saveAbsencesToLocalStorage();
          }
        }

        // Fallback: Load from localStorage
        function getAbsencesFromLocalStorage() {
          // Migrate from old format: absent:studentId:dateStr
          const localAbsences = {};
          for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key && key.startsWith('absent:')) {
              const [, studentId, dateStr] = key.split(':');
              if (localStorage.getItem(key) === 'true') {
                if (!localAbsences[studentId]) {
                  localAbsences[studentId] = {};
                }
                localAbsences[studentId][dateStr] = true;
              }
            }
          }
          return localAbsences;
        }

        function loadAbsencesFromLocalStorage() {
          debugLog('📦 Loading absences from localStorage (fallback)...');
          absences = getAbsencesFromLocalStorage();
          debugLog('📦 Loaded absences from localStorage:', Object.keys(absences).length, 'students');
        }

        // Fallback: Save to localStorage
        function saveAbsencesToLocalStorage() {
          debugLog('📦 Saving absences to localStorage (fallback)...');
          // Clear old absence keys
          const keysToRemove = [];
          for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key && key.startsWith('absent:')) {
              keysToRemove.push(key);
            }
          }
          keysToRemove.forEach(key => localStorage.removeItem(key));

          // Save new absences
          for (const studentId in absences) {
            for (const dateStr in absences[studentId]) {
              if (absences[studentId][dateStr]) {
                const key = `absent:${studentId}:${dateStr}`;
                localStorage.setItem(key, 'true');
              }
            }
          }
        }

        // Initialize: Load from Supabase
        async function init() {
          if (isInitialized) return;
          await loadAbsences();
          isInitialized = true;

          // Set up real-time subscription for cross-device sync
          const channel = supabase
            .channel('student_absences_changes')
            .on('postgres_changes', { event: '*', schema: 'public', table: 'student_absences' }, async payload => {
              // Reload absences from Supabase to stay in sync
              await loadAbsences();
              // Refresh calendar if visible
              if (typeof clearMonthCache === 'function') {
                clearMonthCache();
              }
              if (typeof renderCalendar === 'function') {
                renderCalendar();
              }
            })
            .subscribe();
        }

        // Public API
        return {
          init,

          // Check if student is absent on a date
          isAbsent(studentId, dateStr) {
            const idKey = studentId != null ? String(studentId) : null;
            if (!idKey) return false;
            return !!(absences[idKey] && absences[idKey][dateStr]);
          },

          // Mark student as absent
          async markAbsent(studentId, dateStr) {
            const idKey = studentId != null ? String(studentId) : null;
            if (!idKey) return;
            if (!absences[idKey]) {
              absences[idKey] = {};
            }
            absences[idKey][dateStr] = true;
            
            // Save to localStorage first (primary storage due to RLS restrictions)
            saveAbsencesToLocalStorage();
            
            // Try to sync to Supabase (will fail silently if RLS blocks it)
            try {
              const { error } = await supabase
                .from('student_absences')
                .upsert({
                  student_id: parseInt(studentId),
                  class_date: dateStr,
                }, {
                  onConflict: 'student_id,class_date'
                });
              
              if (error) {
                // console.warn('⚠️ Could not sync absence to Supabase (RLS restricted):', error.message);
                debugLog('✅ Absence saved to localStorage');
              } else {
                debugLog('✅ Absence saved to Supabase and localStorage');
              }
            } catch (err) {
              // console.warn('⚠️ Exception syncing absence to Supabase:', err.message);
              debugLog('✅ Absence saved to localStorage');
            }
            
            // 📧 AUTOMATICALLY SEND ABSENCE EMAIL
            debugLog(`📧 Attempting to send absence email for student ${studentId} on ${dateStr}`);
            try {
              const emailResult = await sendAbsenceEmail(studentId, dateStr);
              debugLog(`✅ Absence email sent successfully:`, emailResult);
            } catch (emailErr) {
              console.error('❌ Failed to send absence email:', emailErr);
              console.error('   Error details:', {
                message: emailErr.message,
                stack: emailErr.stack
              });
              // Don't block absence marking if email fails
            }
          },

          // Remove absent mark
          async removeAbsent(studentId, dateStr) {
            const idKey = studentId != null ? String(studentId) : null;
            if (!idKey) return;
            if (absences[idKey]) {
              delete absences[idKey][dateStr];
              if (Object.keys(absences[idKey]).length === 0) {
                delete absences[idKey];
              }
            }
            
            // Save to localStorage first (primary storage due to RLS restrictions)
            saveAbsencesToLocalStorage();
            
            // Try to sync to Supabase (will fail silently if RLS blocks it)
            try {
              const { error } = await supabase
                .from('student_absences')
                .delete()
                .eq('student_id', parseInt(studentId))
                .eq('class_date', dateStr);
              
              if (error) {
                // console.warn('⚠️ Could not sync absence removal to Supabase (RLS restricted):', error.message);
                debugLog('✅ Absence removed from localStorage');
              } else {
                debugLog('✅ Absence removed from Supabase and localStorage');
              }
            } catch (err) {
              // console.warn('⚠️ Exception syncing absence removal to Supabase:', err.message);
              debugLog('✅ Absence removed from localStorage');
            }
          },

          // Reload from Supabase (for manual sync)
          async reloadFromSupabase() {
            debugLog('🔄 Reloading absences from Supabase...');
            await loadAbsences();
          },
        };
      })();

      // ============================================================================
      // CREDIT PAYMENT MANAGER - Cloud Sync for Credit Payments ☁️
      // ============================================================================
      /**
       * Credit Payment Manager - Supabase Cloud Sync Version
       * - Tracks when student credit/balance is applied to pay for a class
       * - Syncs across all devices via Supabase
       * - Fallback to localStorage for offline support
       */
      window.CreditPaymentManager = (function () {
        // Credit payments data structure: { studentId: { 'YYYY-MM-DD': {amount, balance} } }
        let creditPayments = {};
        let isInitialized = false;

        // Load credit payments from Supabase
        async function loadCreditPayments() {
          try {
            debugLog('☁️ Loading credit payments from Supabase...');
            const { data, error } = await supabase.from('credit_payments').select('*');

            if (error) {
              console.error('❌ Error loading credit payments from Supabase:', error);
              loadCreditPaymentsFromLocalStorage();
              return;
            }

            // Convert array to nested object
            creditPayments = {};
            (data || []).forEach(record => {
              const studentId = record.student_id;
              const dateStr = record.class_date;

              if (!creditPayments[studentId]) {
                creditPayments[studentId] = {};
              }
              creditPayments[studentId][dateStr] = {
                amount: parseFloat(record.amount),
                balance: record.balance_after ? parseFloat(record.balance_after) : null,
              };
            });
          } catch (err) {
            console.error('❌ Exception loading credit payments:', err);
            loadCreditPaymentsFromLocalStorage();
          }
        }

        // Save credit payments to Supabase
        async function saveCreditPayments() {
          try {
            debugLog('☁️ Saving credit payments to Supabase...');

            // Convert nested object to array of records
            const records = [];
            for (const studentId in creditPayments) {
              for (const dateStr in creditPayments[studentId]) {
                const payment = creditPayments[studentId][dateStr];
                records.push({
                  student_id: parseInt(studentId),
                  class_date: dateStr,
                  amount: payment.amount,
                  balance_after: payment.balance,
                });
              }
            }

            // Delete all existing records
            const { error: deleteError } = await supabase.from('credit_payments').delete().neq('id', 0);

            if (deleteError) {
              console.error('❌ Error deleting credit payments:', deleteError);
              saveCreditPaymentsToLocalStorage();
              return;
            }

            // Insert new records
            if (records.length > 0) {
              const { error: insertError } = await supabase.from('credit_payments').insert(records);

              if (insertError) {
                console.error('❌ Error inserting credit payments:', insertError);
                saveCreditPaymentsToLocalStorage();
                return;
              }
            }

            debugLog('✅ Saved credit payments to Supabase:', records.length, 'records');
            saveCreditPaymentsToLocalStorage(); // Keep localStorage as backup
          } catch (err) {
            console.error('❌ Exception saving credit payments:', err);
            saveCreditPaymentsToLocalStorage();
          }
        }

        // Fallback: Load from localStorage
        function loadCreditPaymentsFromLocalStorage() {
          debugLog('📦 Loading credit payments from localStorage (fallback)...');
          creditPayments = {};
          for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key && key.startsWith('credit-payment:')) {
              const [, , studentId, dateStr] = key.split(':');
              const value = localStorage.getItem(key);
              if (value) {
                try {
                  const data = JSON.parse(value);
                  if (!creditPayments[studentId]) {
                    creditPayments[studentId] = {};
                  }
                  creditPayments[studentId][dateStr] = {
                    amount: data.amount,
                    balance: data.balance,
                  };
                } catch (e) {
                  console.error('Error parsing credit payment:', e);
                }
              }
            }
          }
          debugLog('📦 Loaded credit payments from localStorage:', Object.keys(creditPayments).length, 'students');
        }

        // Fallback: Save to localStorage
        function saveCreditPaymentsToLocalStorage() {
          debugLog('📦 Saving credit payments to localStorage (fallback)...');
          // Clear old credit payment keys
          const keysToRemove = [];
          for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key && key.startsWith('credit-payment:')) {
              keysToRemove.push(key);
            }
          }
          keysToRemove.forEach(key => localStorage.removeItem(key));

          // Save new credit payments
          for (const studentId in creditPayments) {
            for (const dateStr in creditPayments[studentId]) {
              const payment = creditPayments[studentId][dateStr];
              const key = `credit-payment:${studentId}:${dateStr}`;
              localStorage.setItem(key, JSON.stringify(payment));
            }
          }
        }

        // Initialize: Load from Supabase
        async function init() {
          if (isInitialized) return;
          debugLog('🚀 Initializing CreditPaymentManager...');
          await loadCreditPayments();
          isInitialized = true;
        }

        // Public API
        return {
          init,

          // Check if credit was applied for a student on a date
          getCreditPayment(studentId, dateStr) {
            return creditPayments[studentId] && creditPayments[studentId][dateStr];
          },

          // Apply credit payment
          async applyCreditPayment(studentId, dateStr, amount, balance) {
            if (!creditPayments[studentId]) {
              creditPayments[studentId] = {};
            }
            creditPayments[studentId][dateStr] = { amount, balance };
            await saveCreditPayments();
          },

          // Remove credit payment
          async removeCreditPayment(studentId, dateStr) {
            if (creditPayments[studentId]) {
              delete creditPayments[studentId][dateStr];
              if (Object.keys(creditPayments[studentId]).length === 0) {
                delete creditPayments[studentId];
              }
            }
            await saveCreditPayments();
          },

          // Reload from Supabase (for manual sync)
          async reloadFromSupabase() {
            debugLog('🔄 Reloading credit payments from Supabase...');
            await loadCreditPayments();
          },
        };
      })();
      
      // Initialize managers
      if (window.supabase) {
        window.AbsentManager.init().catch(err => {
          console.error('Failed to initialize AbsentManager:', err);
        });
        window.CreditPaymentManager.init().catch(err => {
          console.error('Failed to initialize CreditPaymentManager:', err);
        });
      }
      
      // Initialize all data
      let absencesData = {};
      let skippedClassesData = {};
      let creditPaymentsLookup = {};
      
      async function initializeData() {
        debugLog('🚀 Initializing calendar data...');
        debugLog('🌎 Using timezone:', LA_TIMEZONE);
        
        // Verify current LA time
        const now = new Date();
        const laParts = getLAParts(now);
        debugLog('🕒 Current LA time:', laParts ? `${laParts.year}-${laParts.month}-${laParts.day} ${laParts.hour}:${laParts.minute}` : 'Unable to determine');
        
        // Load all data in parallel
        const [students, groups, payments, absences, skipped, credits] = await Promise.all([
          loadStudents(),
          loadGroups(),
          loadPayments(),
          loadAbsences(),
          loadSkippedClasses(),
          loadCreditPayments()
        ]);
        
        absencesData = absences;
        skippedClassesData = skipped;
        creditPaymentsLookup = credits;
        clearMonthCache();
        calendarBaseEvents = [];
        currentMonthEventMap = {};
        currentMonthEventsFlat = [];
        lastMergedEventsCount = 0;
        
        // Set up real-time subscriptions for automatic updates
        setupRealtimeSubscriptions();
        
        // Render calendar with real data
        renderCalendar();
      }

      // Set up real-time subscriptions to auto-refresh when data changes
      function setupRealtimeSubscriptions() {
        // Subscribe to student changes (group, price, etc.)
        supabase
          .channel('students_changes')
          .on('postgres_changes', { event: '*', schema: 'public', table: 'students' }, async payload => {
            // Reload students and re-render calendar
            await loadStudents();
            clearMonthCache();
            renderCalendar();
          })
          .subscribe();

        // Subscribe to group changes (schedule, price, etc.)
        supabase
          .channel('groups_changes')
          .on('postgres_changes', { event: '*', schema: 'public', table: 'groups' }, async payload => {
            // Reload groups and re-render calendar
            await loadGroups();
            clearMonthCache();
            renderCalendar();
          })
          .subscribe();

        // Subscribe to payment changes
        supabase
          .channel('payments_changes')
          .on('postgres_changes', { event: '*', schema: 'public', table: 'payments' }, async payload => {
            // Reload payments and re-render calendar
            await loadPayments();
            clearMonthCache();
            renderCalendar();
          })
          .subscribe();
      }


      const SIDEBAR_ALERT_LIMIT = 6;

      // Filter state
      const filters = {
        classes: true,
        payments: true,
        absences: true,
        skipped: true,
      };

      // Initialize Calendar
      async function initCalendar() {
        // ⚡ Performance: Initialize DOM cache first
        DOMCache.init();
        
        syncCurrentDateToLAToday();
        // First load all data from Supabase
        await initializeData();
        
        // Then attach event listeners
        attachEventListeners();
      }

      // Update Stats (Sidebar)
      function updateStats() {
        const { year, month } = getCurrentViewYearMonth();
        const monthData = getMonthData(year, month);
        const aggregates = monthData?.aggregates || {};

        document.getElementById('totalClasses').textContent = aggregates.classes || 0;
        document.getElementById('totalPayments').textContent = aggregates.payments || 0;
        document.getElementById('totalAbsences').textContent = aggregates.absences || 0;
        document.getElementById('totalSkipped').textContent = aggregates.skipped || 0;
      }

      // Update Calendar Stats (Header)
      function updateCalendarStats() {
        const { year, month } = getCurrentViewYearMonth();
        const monthData = getMonthData(year, month);
        const aggregates = monthData?.aggregates || {};
        const totals = monthData?.totals || { paid: 0, unpaid: 0 };

        const activeStudentCount = aggregates.activeStudents || 0;
        const totalScheduledClasses = aggregates.classes || 0;
        const totalPaid = totals.paid || 0;
        const totalPending = totals.unpaid || 0;

        document.getElementById('activeStudentsCount').textContent =
          `${activeStudentCount} active student${activeStudentCount === 1 ? '' : 's'}`;
        document.getElementById('scheduledClassesCount').textContent =
          `${totalScheduledClasses} scheduled class${totalScheduledClasses === 1 ? '' : 'es'}`;
        document.getElementById('monthPaid').textContent = `💰 ${totalPaid.toLocaleString()} $ paid`;
        document.getElementById('monthPending').textContent = `⚠️ ${totalPending.toLocaleString()} $ pending`;
      }

      function buildSidebarAlerts(monthData) {
        const alerts = { upcoming: [], unpaid: [] };
        if (!monthData?.dayMap) return alerts;

        const todayStr = formatDateYYYYMMDD(new Date());
        const dayEntries = Object.values(monthData.dayMap);

        dayEntries.forEach(dayEntry => {
          if (!dayEntry?.dateStr) return;
          const isFutureDay = dayEntry.dateStr > todayStr;
          const isToday = dayEntry.dateStr === todayStr;
          const isPastOrToday = dayEntry.dateStr <= todayStr;
          const dateLabel = formatHumanDateInLA(dayEntry.date);

          (dayEntry.groups || []).forEach(group => {
            const groupName = group.groupName || group.group || 'Group';
            const timeLabel = group.laTime || '';

            (group.students || []).forEach(student => {
              const status = student.status || 'unpaid';
              const baseEntry = {
                studentName: student.name || 'Student',
                groupName,
                dateStr: dayEntry.dateStr,
                dateLabel,
                timeLabel,
                status,
                price: Number(student.pricePerClass) || 0,
              };

              const isUpcomingEntry = (isFutureDay || (isToday && status === 'upcoming')) && status !== 'canceled' && status !== 'skipped';

              if (isUpcomingEntry) {
                alerts.upcoming.push(baseEntry);
              }

              if (status === 'unpaid' && isPastOrToday) {
                alerts.unpaid.push(baseEntry);
              }
            });
          });
        });

        const sortByDate = (a, b) => {
          if (a.dateStr === b.dateStr) {
            return parseTimeToMinutes(a.timeLabel) - parseTimeToMinutes(b.timeLabel);
          }
          return a.dateStr.localeCompare(b.dateStr);
        };

        alerts.upcoming.sort(sortByDate);
        alerts.unpaid.sort(sortByDate);

        return alerts;
      }

      function renderSidebarAlerts(monthData) {
        const upcomingContainer = document.getElementById('upcomingClassesList');
        const unpaidContainer = document.getElementById('unpaidClassesList');
        if (!upcomingContainer || !unpaidContainer) return;

        const alerts = buildSidebarAlerts(monthData);
        const upcomingItems = (alerts.upcoming || []).slice(0, SIDEBAR_ALERT_LIMIT);
        const unpaidItems = (alerts.unpaid || []).slice(0, SIDEBAR_ALERT_LIMIT);

        renderList(upcomingContainer, upcomingItems, alerts.upcoming?.length || 0, 'upcoming');
        renderList(unpaidContainer, unpaidItems, alerts.unpaid?.length || 0, 'unpaid');

        function renderList(container, items, totalCount, type) {
          container.innerHTML = '';
          if (!items.length) {
            const empty = document.createElement('div');
            empty.className = 'insight-empty';
            empty.textContent = type === 'upcoming' ? 'No future classes in view' : 'No unpaid classes in view';
            container.appendChild(empty);
            return;
          }

          items.forEach(entry => {
            container.appendChild(createInsightCard(entry, type));
          });

          if (totalCount > items.length) {
            const remaining = totalCount - items.length;
            const more = document.createElement('div');
            more.className = 'insight-empty';
            more.textContent = `+${remaining} more ${type === 'upcoming' ? 'class' : 'alert'} this month`;
            container.appendChild(more);
          }
        }

        function createInsightCard(entry, type) {
          const card = document.createElement('div');
          card.className = 'insight-card';

          const topRow = document.createElement('div');
          topRow.className = 'insight-meta';

          const dateSpan = document.createElement('span');
          dateSpan.textContent = entry.dateLabel || entry.dateStr;
          topRow.appendChild(dateSpan);

          const secondarySpan = document.createElement('span');
          if (type === 'upcoming') {
            secondarySpan.textContent = entry.timeLabel || 'Time TBA';
          } else {
            secondarySpan.textContent = `${formatCurrency(entry.price)} $`;
          }
          topRow.appendChild(secondarySpan);
          card.appendChild(topRow);

          const title = document.createElement('div');
          title.className = 'insight-title';
          title.textContent = entry.studentName;
          card.appendChild(title);

          const bottomRow = document.createElement('div');
          bottomRow.className = 'insight-meta';

          const groupSpan = document.createElement('span');
          groupSpan.textContent = entry.groupName;
          bottomRow.appendChild(groupSpan);

          const badge = document.createElement('span');
          const isUnpaid = type === 'unpaid' || entry.status === 'unpaid';
          badge.className = `insight-badge ${isUnpaid ? 'unpaid' : 'upcoming'}`;
          badge.textContent = isUnpaid ? 'Unpaid' : 'Upcoming';
          bottomRow.appendChild(badge);

          card.appendChild(bottomRow);

          return card;
        }
      }

      let paymentReviewPromptState = { key: null, count: 0 };
      let paymentReviewDrawerOpen = false;

      function notifyPaymentAllocationReview(unresolvedList = [], monthKey = 'current', rawList = []) {
        window.paymentAllocationReviewSource = {
          monthKey,
          raw: Array.isArray(rawList) ? [...rawList] : [],
          unresolved: Array.isArray(unresolvedList) ? [...unresolvedList] : [],
        };

        updatePaymentAllocationReviewUI(window.paymentAllocationReviewSource.unresolved, monthKey);

        if (!unresolvedList.length) {
          return;
        }

        const promptKey = `${monthKey}-${unresolvedList.length}`;
        if (paymentReviewPromptState.key === promptKey) {
          return;
        }

        paymentReviewPromptState = { key: promptKey, count: unresolvedList.length };

        setTimeout(() => {
          showConfirmDialog(
            'Payment allocation review needed',
            `We couldn't auto-match ${unresolvedList.length} payment${unresolvedList.length === 1 ? '' : 's'} between Nov 1 and today. Would you like to review them now?`
          ).then(openNow => {
            if (openNow) {
              openPaymentReviewDrawer();
            }
          });
        }, 400);
      }

      function updatePaymentAllocationReviewUI(alerts = [], monthKey = 'current') {
        const banner = document.getElementById('paymentReviewBanner');
        if (!banner) return;

        if (!window.paymentAllocationReviewSource) {
          window.paymentAllocationReviewSource = { monthKey, raw: alerts, unresolved: alerts };
        } else {
          window.paymentAllocationReviewSource.unresolved = Array.isArray(alerts) ? [...alerts] : [];
          if (monthKey) {
            window.paymentAllocationReviewSource.monthKey = monthKey;
          }
        }

        const countEl = document.getElementById('paymentReviewCount');
        const pluralEl = document.getElementById('paymentReviewPlural');
        const totalEl = document.getElementById('paymentReviewTotal');
        const summaryEl = document.getElementById('paymentReviewSummary');
        const drawerCountEl = document.getElementById('paymentReviewDrawerCount');
        const drawerTotalEl = document.getElementById('paymentReviewDrawerTotal');

        if (!alerts.length) {
          banner.classList.add('hidden');
          if (countEl) countEl.textContent = '0';
          if (pluralEl) pluralEl.textContent = 's';
          if (totalEl) totalEl.textContent = '0';
          if (summaryEl) summaryEl.textContent = 'All payments have been matched.';
          if (drawerCountEl) drawerCountEl.textContent = '0 pending';
          if (drawerTotalEl) drawerTotalEl.textContent = '0 $ unresolved';
          if (paymentReviewDrawerOpen) {
            renderPaymentReviewList([]);
          }
          closePaymentReviewDrawer(true);
          return;
        }

        const totalAmount = alerts.reduce((sum, entry) => sum + (Number(entry.amount) || 0), 0);

        banner.classList.remove('hidden');
        if (countEl) countEl.textContent = alerts.length;
        if (pluralEl) pluralEl.textContent = alerts.length === 1 ? '' : 's';
        if (totalEl) totalEl.textContent = formatCurrency(totalAmount);
        if (summaryEl) {
          summaryEl.textContent = 'Click review to tell us whether these become credits or stay on hold.';
        }
        if (drawerCountEl) {
          drawerCountEl.textContent = `${alerts.length} payment${alerts.length === 1 ? '' : 's'} pending`;
        }
        if (drawerTotalEl) {
          drawerTotalEl.textContent = `${formatCurrency(totalAmount)} $ unresolved`;
        }

        if (paymentReviewDrawerOpen) {
          renderPaymentReviewList(alerts);
        }
      }

      function initPaymentReviewUI() {
        if (window.paymentReviewEventsBound) return;
        window.paymentReviewEventsBound = true;
        const bannerBtn = document.getElementById('paymentReviewBannerBtn');
        if (bannerBtn && !bannerBtn.dataset.bound) {
          bannerBtn.dataset.bound = 'true';
          bannerBtn.addEventListener('click', openPaymentReviewDrawer);
        }

        const exportBtn = document.getElementById('paymentReviewExportBtn');
        if (exportBtn && !exportBtn.dataset.bound) {
          exportBtn.dataset.bound = 'true';
          exportBtn.addEventListener('click', exportPaymentAllocationAlerts);
        }

        const closeBtn = document.getElementById('paymentReviewCloseBtn');
        if (closeBtn && !closeBtn.dataset.bound) {
          closeBtn.dataset.bound = 'true';
          closeBtn.addEventListener('click', () => closePaymentReviewDrawer());
        }

        const resetBtn = document.getElementById('paymentReviewResetBtn');
        if (resetBtn && !resetBtn.dataset.bound) {
          resetBtn.dataset.bound = 'true';
          resetBtn.addEventListener('click', handleResetPaymentAllocations);
        }

        const scrim = document.getElementById('paymentReviewScrim');
        if (scrim && !scrim.dataset.bound) {
          scrim.dataset.bound = 'true';
          scrim.addEventListener('click', () => closePaymentReviewDrawer());
        }

        const searchInput = document.getElementById('paymentReviewSearch');
        if (searchInput && !searchInput.dataset.bound) {
          searchInput.dataset.bound = 'true';
          searchInput.addEventListener('input', () => {
            if (paymentReviewDrawerOpen) {
              renderPaymentReviewList(window.paymentAllocationReviewSource?.unresolved || []);
            }
          });
        }

        if (!window.paymentReviewKeyListenerAttached) {
          window.paymentReviewKeyListenerAttached = true;
          document.addEventListener('keydown', event => {
            if (event.key === 'Escape' && paymentReviewDrawerOpen) {
              closePaymentReviewDrawer();
            }
          });
        }
      }

      function openPaymentReviewDrawer() {
        const drawer = document.getElementById('paymentReviewDrawer');
        const scrim = document.getElementById('paymentReviewScrim');
        if (!drawer || !scrim) return;
        paymentReviewDrawerOpen = true;
        drawer.setAttribute('aria-hidden', 'false');
        drawer.classList.add('open');
        scrim.classList.add('visible');
        renderPaymentReviewList(window.paymentAllocationReviewSource?.unresolved || []);
      }

      function closePaymentReviewDrawer(force = false) {
        if (!paymentReviewDrawerOpen && !force) return;
        const drawer = document.getElementById('paymentReviewDrawer');
        const scrim = document.getElementById('paymentReviewScrim');
        if (!drawer || !scrim) return;
        paymentReviewDrawerOpen = false;
        drawer.setAttribute('aria-hidden', 'true');
        drawer.classList.remove('open');
        scrim.classList.remove('visible');
      }

      function renderPaymentReviewList(entries = []) {
        const container = document.getElementById('paymentReviewList');
        if (!container) return;
        const searchTerm = (document.getElementById('paymentReviewSearch')?.value || '').trim().toLowerCase();
        const filteredEntries = filterPaymentReviewEntries(entries, searchTerm);

        const drawerCountEl = document.getElementById('paymentReviewDrawerCount');
        const drawerTotalEl = document.getElementById('paymentReviewDrawerTotal');
        const totalAmount = filteredEntries.reduce((sum, entry) => sum + (Number(entry.amount) || 0), 0);

        if (drawerCountEl) {
          drawerCountEl.textContent = `${filteredEntries.length} payment${filteredEntries.length === 1 ? '' : 's'} pending`;
        }
        if (drawerTotalEl) {
          drawerTotalEl.textContent = `${formatCurrency(totalAmount)} $ unresolved`;
        }

        container.innerHTML = '';

        if (!filteredEntries.length) {
          container.innerHTML = "<div class=\"payment-review-empty\">You're all caught up 🙌</div>";
          return;
        }

        const grouped = groupPaymentAllocationsByStudent(filteredEntries);

        grouped.forEach(group => {
          const card = document.createElement('div');
          card.className = 'payment-review-card';

          const title = document.createElement('h4');
          title.textContent = group.studentName;
          card.appendChild(title);

          const subtitle = document.createElement('small');
          subtitle.textContent = `${group.payments.length} payment${group.payments.length === 1 ? '' : 's'} · ${formatCurrency(group.totalAmount)} $`;
          card.appendChild(subtitle);

          const list = document.createElement('div');
          list.className = 'payment-review-payments';

          group.payments
            .sort((a, b) => (b.payDate || '').localeCompare(a.payDate || ''))
            .forEach(entry => {
              const row = document.createElement('div');
              row.className = 'payment-review-row';

              const details = document.createElement('div');
              details.style.flex = '1';
              details.innerHTML = `<strong>${entry.payDate || 'Unknown date'}</strong><br/><span>${formatCurrency(entry.amount)} $ · ${entry.paymentId || 'Untracked payment'}</span>`;

              const actions = document.createElement('div');
              actions.className = 'payment-review-actions';

              const creditBtn = document.createElement('button');
              creditBtn.className = 'allocation-action credit';
              creditBtn.textContent = 'Mark credit';
              creditBtn.addEventListener('click', () => handlePaymentAllocationResolution(entry, 'credit'));

              const dismissBtn = document.createElement('button');
              dismissBtn.className = 'allocation-action dismiss';
              dismissBtn.textContent = 'Ignore this month';
              dismissBtn.addEventListener('click', () => handlePaymentAllocationResolution(entry, 'ignore'));

              actions.appendChild(creditBtn);
              actions.appendChild(dismissBtn);

              row.appendChild(details);
              row.appendChild(actions);
              list.appendChild(row);
            });

          card.appendChild(list);
          container.appendChild(card);
        });
      }

      function filterPaymentReviewEntries(entries, searchTerm) {
        if (!searchTerm) return entries;
        return entries.filter(entry => {
          const haystack = [
            entry.studentName,
            entry.studentId,
            entry.payDate,
            entry.paymentId,
            entry.amount != null ? String(entry.amount) : '',
          ]
            .filter(Boolean)
            .map(value => value.toString().toLowerCase());
          return haystack.some(value => value.includes(searchTerm));
        });
      }

      function groupPaymentAllocationsByStudent(entries) {
        const groups = new Map();
        entries.forEach(entry => {
          const key = entry.studentId || entry.studentName || entry.paymentId || Math.random().toString(36).slice(2, 8);
          if (!groups.has(key)) {
            groups.set(key, {
              studentId: entry.studentId,
              studentName: entry.studentName || 'Unknown Student',
              totalAmount: 0,
              payments: [],
            });
          }
          const group = groups.get(key);
          group.totalAmount += Number(entry.amount) || 0;
          group.payments.push(entry);
        });
        return Array.from(groups.values()).sort((a, b) => b.totalAmount - a.totalAmount);
      }

      async function handlePaymentAllocationResolution(entry, action) {
        const actionLabel = action === 'credit' ? 'mark as credit/rollover' : 'ignore for this month';
        const confirmed = await showConfirmDialog(
          'Resolve payment allocation',
          `Do you want to ${actionLabel} for ${entry.studentName || 'this student'} — ${formatCurrency(entry.amount)} $ from ${entry.payDate || 'unknown date'}? This hides it from the alert list.`
        );
        if (!confirmed) return;

        markPaymentAllocationResolution(entry, action);
        showSuccessToast(action === 'credit' ? 'Saved as credit note locally' : 'Dismissed until new activity arrives');
        refreshPaymentAllocationAlerts();
      }

      function refreshPaymentAllocationAlerts() {
        const source = window.paymentAllocationReviewSource;
        if (!source) {
          updatePaymentAllocationReviewUI(window.paymentAllocationAlerts || [], null);
          return;
        }
        const refreshed = filterResolvedPaymentAllocations(source.raw || []);
        source.unresolved = refreshed;
        window.paymentAllocationAlerts = refreshed;
        updatePaymentAllocationReviewUI(refreshed, source.monthKey);
        if (paymentReviewDrawerOpen) {
          renderPaymentReviewList(refreshed);
        }
      }

      function exportPaymentAllocationAlerts() {
        const entries = window.paymentAllocationReviewSource?.unresolved || [];
        if (!entries.length) {
          showErrorToast('No pending payments to export.');
          return;
        }

        const header = ['Student', 'Student ID', 'Payment Date', 'Amount', 'Payment ID'];
        const rows = entries.map(entry => [
          entry.studentName || '',
          entry.studentId || '',
          entry.payDate || '',
          Number(entry.amount || 0).toFixed(2),
          entry.paymentId || '',
        ]);

        const csv = [header, ...rows]
          .map(row => row.map(value => `"${String(value).replace(/"/g, '""')}"`).join(','))
          .join('\n');

        const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = `payment-allocation-review-${formatDateYYYYMMDD(new Date())}.csv`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
      }

      async function handleResetPaymentAllocations() {
        const confirmed = await showConfirmDialog(
          'Reset hidden alerts',
          'This clears all previous review decisions so every payment will show up again. Continue?'
        );
        if (!confirmed) return;
        resetPaymentAllocationResolutions();
        showSuccessToast('Payment review decisions cleared');
        refreshPaymentAllocationAlerts();
      }

      // Render Calendar
      // ============================================================
      // EXCESS PAYMENTS DETECTION & NOTIFICATION SYSTEM
      // ============================================================
      // Tracks payments that exceed scheduled classes and prompts admin
      // to either apply as credit or dismiss the alert.
      //
      // Features:
      // - Dismissed alerts are saved to localStorage and never shown again
      // - Each payment is uniquely identified by: studentId_paymentId_date_amount
      // - Skip button permanently dismisses alerts for specific payments
      // - Confirm button applies credits and removes from alert queue
      // - Notification bell shows count of remaining alerts
      // - Admin can reset dismissed alerts via: clearDismissedExcessPayments()
      // ============================================================
      
      // Check for excess payments and notify user
      function checkAndNotifyExcessPayments() {
        if (!window.excessPaymentsForCredit || window.excessPaymentsForCredit.length === 0) {
          // Hide notification bell
          updateCreditNotificationBell(0);
          return; // No excess payments detected
        }
        
        // Initialize dismissed payments tracking in localStorage
        let dismissedPayments = [];
        try {
          const stored = localStorage.getItem('dismissedExcessPayments');
          if (stored) {
            dismissedPayments = JSON.parse(stored);
            // Ensure it's an array
            if (!Array.isArray(dismissedPayments)) {
              dismissedPayments = [];
            }
          }
        } catch (e) {
          console.error('Failed to load dismissed payments, resetting:', e);
          dismissedPayments = [];
          localStorage.removeItem('dismissedExcessPayments');
        }
        
        // Filter out already dismissed payments
        const newExcessPayments = window.excessPaymentsForCredit.filter(payment => {
          // Create unique key for this payment
          const paymentKey = `${payment.studentId}_${payment.paymentId}_${payment.date}_${payment.amount}`;
          const isDismissed = dismissedPayments.includes(paymentKey);
          return !isDismissed;
        });
        
        // If all payments were previously dismissed, don't show modal
        if (newExcessPayments.length === 0) {
          window.excessPaymentsForCredit = [];
          updateCreditNotificationBell(0);
          return;
        }
        
        // Update the list to only show new excess payments
        window.excessPaymentsForCredit = newExcessPayments;
        
        // Group by student to count unique students
        const byStudent = {};
        newExcessPayments.forEach(item => {
          const studentName = item.studentName || 'Unknown';
          if (!byStudent[studentName]) {
            byStudent[studentName] = [];
          }
          byStudent[studentName].push(item);
        });
        
        const studentCount = Object.keys(byStudent).length;
        
        // Show notification bell with count instead of auto-opening modal
        updateCreditNotificationBell(studentCount);
      }
      
      // Update notification bell visibility and count
      function updateCreditNotificationBell(count) {
        const bell = document.getElementById('creditNotificationBell');
        const badge = document.getElementById('creditNotificationBadge');
        
        if (!bell || !badge) return;
        
        // Bell is always visible
        bell.style.display = 'flex';
        
        if (count > 0) {
          // Has notifications - green and highlighted
          bell.classList.add('has-notifications');
          badge.style.display = 'flex';
          badge.textContent = count;
        } else {
          // No notifications - subtle appearance
          bell.classList.remove('has-notifications');
          badge.style.display = 'none';
        }
      }
      
      // Utility: Clear all dismissed excess payment alerts (for debugging/reset)
      // Call from console: window.clearDismissedExcessPayments()
      window.clearDismissedExcessPayments = function() {
        localStorage.removeItem('dismissedExcessPayments');
        alert('Dismissed excess payment alerts have been cleared. Refresh the page to see all alerts again.');
      };
      
      // Trigger credit review workflow manually
      function triggerCreditReview() {
        if (!window.excessPaymentsForCredit || window.excessPaymentsForCredit.length === 0) {
          return;
        }
        
        // Group by student
        const byStudent = {};
        window.excessPaymentsForCredit.forEach(item => {
          const studentName = item.studentName || 'Unknown';
          if (!byStudent[studentName]) {
            byStudent[studentName] = [];
          }
          byStudent[studentName].push(item);
        });
        
        // Convert to array and sort by student name
        const studentArray = Object.keys(byStudent).sort().map(name => ({
          name,
          payments: byStudent[name]
        }));
        
        // Show modal for first student
        showCreditModalForStudent(studentArray, 0);
      }
      
      // Format currency with commas
      function formatCurrency(amount) {
        return amount.toFixed(2).replace(/\B(?=(\d{3})+(?!\d))/g, ',');
      }
      
      // Show credit modal for a specific student
      function showCreditModalForStudent(studentArray, currentIndex) {
        if (currentIndex >= studentArray.length) {
          // All students processed - hide notification bell
          updateCreditNotificationBell(0);
          window.excessPaymentsForCredit = [];
          return;
        }
        
        // Update bell to show remaining students
        const remainingStudents = studentArray.length - currentIndex;
        updateCreditNotificationBell(remainingStudents);
        
        const student = studentArray[currentIndex];
        const totalStudents = studentArray.length;
        const studentTotal = student.payments.reduce((sum, p) => sum + p.amount, 0);
        
        // Build modal content for this student
        let modalHTML = `
          <div class="credit-summary">
            <div class="credit-summary-info">
              <h3>${student.name}</h3>
              <p>${student.payments.length} excess payment(s) • Student ${currentIndex + 1} of ${totalStudents}</p>
            </div>
            <div class="credit-summary-total">$${formatCurrency(studentTotal)}</div>
          </div>
          
          <div class="credit-student-list">
            <div class="credit-student-card">
              <div class="credit-payment-list">
        `;
        
        student.payments.forEach(p => {
          modalHTML += `
            <div class="credit-payment-item">
              <span class="credit-payment-date">${p.date}</span>
              <span class="credit-payment-amount">$${formatCurrency(p.amount)}</span>
            </div>
          `;
        });
        
        modalHTML += `
              </div>
            </div>
          </div>
        `;
        
        // Show modal
        const modal = document.getElementById('creditModal');
        const modalBody = document.getElementById('creditModalBody');
        const applyBtn = document.getElementById('applyCreditBtn');
        
        modalBody.innerHTML = modalHTML;
        
        // Update button text to show progress
        if (totalStudents > 1) {
          applyBtn.textContent = `Confirm (${currentIndex + 1}/${totalStudents})`;
        } else {
          applyBtn.textContent = 'Confirm';
        }
        
        modal.classList.add('active');
        
        // Setup event listeners
        const closeBtn = document.getElementById('closeCreditModal');
        const cancelBtn = document.getElementById('cancelCreditBtn');
        const skipAllBtn = document.getElementById('skipAllCreditBtn');
        
        const skipStudent = () => {
          modal.classList.remove('active');
          
          // Mark THIS student's payments as dismissed permanently
          try {
            const paymentKeys = student.payments.map(p => 
              `${p.studentId}_${p.paymentId}_${p.date}_${p.amount}`
            );
            const existingDismissed = JSON.parse(localStorage.getItem('dismissedExcessPayments') || '[]');
            const updatedDismissed = [...new Set([...existingDismissed, ...paymentKeys])];
            localStorage.setItem('dismissedExcessPayments', JSON.stringify(updatedDismissed));
            
            // Remove these payments from the global list
            window.excessPaymentsForCredit = window.excessPaymentsForCredit.filter(p => {
              const key = `${p.studentId}_${p.paymentId}_${p.date}_${p.amount}`;
              return !paymentKeys.includes(key);
            });
          } catch (e) {
            console.error('Failed to save dismissed payments:', e);
          }
          
          // Show next student after a short delay
          setTimeout(() => {
            showCreditModalForStudent(studentArray, currentIndex + 1);
          }, 300);
        };
        
        const skipAllStudents = () => {
          modal.classList.remove('active');
          
          // Mark ALL remaining students' payments as dismissed permanently
          try {
            const allPaymentKeys = [];
            
            // Collect payment keys from current student and all remaining students
            for (let i = currentIndex; i < studentArray.length; i++) {
              const s = studentArray[i];
              s.payments.forEach(p => {
                allPaymentKeys.push(`${p.studentId}_${p.paymentId}_${p.date}_${p.amount}`);
              });
            }
            
            const existingDismissed = JSON.parse(localStorage.getItem('dismissedExcessPayments') || '[]');
            const updatedDismissed = [...new Set([...existingDismissed, ...allPaymentKeys])];
            localStorage.setItem('dismissedExcessPayments', JSON.stringify(updatedDismissed));
            
            // Remove all these payments from the global list
            window.excessPaymentsForCredit = window.excessPaymentsForCredit.filter(p => {
              const key = `${p.studentId}_${p.paymentId}_${p.date}_${p.amount}`;
              return !allPaymentKeys.includes(key);
            });
            
            // Hide notification bell since all are dismissed
            updateCreditNotificationBell(0);
          } catch (e) {
            console.error('Failed to save dismissed payments:', e);
          }
        };
        
        const applyCredit = () => {
          modal.classList.remove('active');
          
          // Apply credit for THIS student only
          applyCreditForStudent(student.payments, () => {
            // After successful application, show next student
            setTimeout(() => {
              showCreditModalForStudent(studentArray, currentIndex + 1);
            }, 300);
          });
        };
        
        // Remove old event listeners by cloning buttons
        const newCloseBtn = closeBtn.cloneNode(true);
        const newCancelBtn = cancelBtn.cloneNode(true);
        const newSkipAllBtn = skipAllBtn.cloneNode(true);
        const newApplyBtn = applyBtn.cloneNode(true);
        
        closeBtn.parentNode.replaceChild(newCloseBtn, closeBtn);
        cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);
        skipAllBtn.parentNode.replaceChild(newSkipAllBtn, skipAllBtn);
        applyBtn.parentNode.replaceChild(newApplyBtn, applyBtn);
        
        newCloseBtn.onclick = skipStudent;
        newCancelBtn.onclick = skipStudent;
        newSkipAllBtn.onclick = skipAllStudents;
        newApplyBtn.onclick = applyCredit;
        
        // Close on overlay click
        modal.onclick = (e) => {
          if (e.target === modal) skipStudent();
        };
      }
      
      // Apply credit for a single student
      async function applyCreditForStudent(payments, onSuccess) {
        const creditRecords = payments.map(item => ({
          student_id: item.studentId,
          amount: item.amount,
          date: item.date,
          notes: `Auto-applied from excess payment (${item.reason})`,
          created_at: new Date().toISOString()
        }));
        
        try {
          const { data, error } = await supabase
            .from('credit_payments')
            .insert(creditRecords);
          
          if (error) {
            console.error('❌ Failed to apply credits:', error);
            alert(`Failed to apply credits: ${error.message}`);
            return;
          }
          
          // Clear dismissed payments for these specific payments
          try {
            const appliedKeys = payments.map(p => 
              `${p.studentId}_${p.paymentId}_${p.date}_${p.amount}`
            );
            const existingDismissed = JSON.parse(localStorage.getItem('dismissedExcessPayments') || '[]');
            const updatedDismissed = existingDismissed.filter(key => !appliedKeys.includes(key));
            localStorage.setItem('dismissedExcessPayments', JSON.stringify(updatedDismissed));
            
            // Also remove from global excess payments list
            window.excessPaymentsForCredit = window.excessPaymentsForCredit.filter(p => {
              const key = `${p.studentId}_${p.paymentId}_${p.date}_${p.amount}`;
              return !appliedKeys.includes(key);
            });
          } catch (e) {
            console.error('Failed to update dismissed payments list:', e);
          }
          
          // Show success message
          const studentName = payments[0].studentName;
          alert(`✅ Applied $${formatCurrency(total)} as credit for ${studentName}`);
          
          // Call success callback to show next student
          if (onSuccess) onSuccess();
          
        } catch (err) {
          console.error('❌ Error applying credits:', err);
          alert(`Error: ${err.message}`);
        }
      }
      
      function renderCalendar() {
        const { year, month } = getCurrentViewYearMonth();

        // ⚡ Performance: Check if month data is already cached
        let monthData = DataCache.getMonth(year, month);
        if (!monthData) {
          monthData = getMonthData(year, month) || {};
          DataCache.setMonth(year, month, monthData);
        }

        // Update header using cached elements
        document.getElementById('currentMonth').textContent = monthNames[month];
        document.getElementById('currentYear').textContent = year;
        const firstDay =
          monthData.firstDay ?? getLAWeekdayIndex(createDateFromParts(year, month, 1)) ?? 0;
        const daysInMonth = monthData.daysInMonth ?? new Date(year, month + 1, 0).getDate();
        const daysInPrevMonth = new Date(year, month, 0).getDate();

        calendarBaseEvents = [...(monthData.eventsFlat || [])];
        currentMonthEventMap = monthData.dayMap || {};
        currentMonthEventsFlat = [...(monthData.eventsFlat || [])];
        lastMergedEventsCount = currentMonthEventsFlat.length;

        const calendarDays = document.getElementById('calendarDays');
        calendarDays.innerHTML = '';

        const todayParts = getTodayLAParts();
        const isCurrentMonth =
          todayParts && Number(todayParts.year) === year && Number(todayParts.month) - 1 === month;
        const todayDate = todayParts ? Number(todayParts.day) : null;

        // Previous month days
        for (let i = firstDay - 1; i >= 0; i--) {
          const day = daysInPrevMonth - i;
          const prevDate = createDateFromParts(year, month - 1, day);
          const dayEl = createDayElement({ dayNumber: day, isOtherMonth: true, dateObj: prevDate });
          calendarDays.appendChild(dayEl);
        }

        // Current month days
        for (let day = 1; day <= daysInMonth; day++) {
          const dayData = monthData.dayMap ? monthData.dayMap[day] : null;
          const dayEl = createDayElement({
            dayNumber: day,
            dayData,
            isToday: isCurrentMonth && day === todayDate,
          });

          applyDayStateClasses(dayEl, dayData);
          addIndicators(dayEl, dayData);
          calendarDays.appendChild(dayEl);
        }

        // Next month days
        const totalCells = calendarDays.children.length;
        const remainingCells = 42 - totalCells; // 6 rows × 7 days
        for (let day = 1; day <= remainingCells; day++) {
          const nextDate = createDateFromParts(year, month + 1, day);
          const dayEl = createDayElement({ dayNumber: day, isOtherMonth: true, dateObj: nextDate });
          calendarDays.appendChild(dayEl);
        }

        updateStats();
        updateCalendarStats();
        renderSidebarAlerts(monthData);

        if (monthData) {
          if (
            monthData.paymentAllocationSource &&
            (!window.paymentAllocationReviewSource || window.paymentAllocationReviewSource.monthKey !== monthData.key)
          ) {
            window.paymentAllocationReviewSource = {
              monthKey: monthData.key,
              raw: monthData.paymentAllocationSource || [],
              unresolved: monthData.ambiguousPaymentAllocations || [],
            };
          } else if (window.paymentAllocationReviewSource && monthData.paymentAllocationSource) {
            window.paymentAllocationReviewSource.raw = monthData.paymentAllocationSource || [];
            window.paymentAllocationReviewSource.unresolved = monthData.ambiguousPaymentAllocations || [];
          }

          updatePaymentAllocationReviewUI(
            window.paymentAllocationReviewSource?.unresolved || monthData.ambiguousPaymentAllocations || [],
            monthData.key || `${year}-${String(month + 1).padStart(2, '0')}`
          );
        }
        
        // Check for excess payments that could be applied as credit
        checkAndNotifyExcessPayments();
      }

      // Create Day Element
      function createDayElement({ dayNumber, dayData = null, isOtherMonth = false, isToday = false, dateObj = null }) {
        const dayEl = document.createElement('div');
        dayEl.className = 'day';
        if (isOtherMonth) dayEl.classList.add('other-month');
        if (isToday) dayEl.classList.add('today');

        // Create header container
        const dayHeader = document.createElement('div');
        dayHeader.className = 'day-header';

        // Create day number
        const dayNumberEl = document.createElement('div');
        dayNumberEl.className = 'day-number';
        dayNumberEl.textContent = dayNumber;
        dayHeader.appendChild(dayNumberEl);

        if (dayData && dayData.totals) {
          const paid = Number(dayData.totals.paid || 0);
          const unpaid = Number(dayData.totals.unpaid || 0);
          if (paid > 0 || unpaid > 0) {
            const paymentSummary = document.createElement('div');
            paymentSummary.className = 'day-payment-summary';

            // Paid amount
            const paidSpan = document.createElement('span');
            paidSpan.className = 'day-payment-paid';
            paidSpan.textContent = `${formatCurrency(paid)} $`;
            paymentSummary.appendChild(paidSpan);

            // Divider
            const divider = document.createElement('span');
            divider.className = 'day-payment-divider';
            divider.textContent = '/';
            paymentSummary.appendChild(divider);

            // Unpaid amount
            const unpaidSpan = document.createElement('span');
            unpaidSpan.className = 'day-payment-unpaid';
            unpaidSpan.textContent = `${formatCurrency(unpaid)} $`;
            paymentSummary.appendChild(unpaidSpan);

            dayHeader.appendChild(paymentSummary);
          }
        }

        dayEl.appendChild(dayHeader);

        const indicatorContainer = document.createElement('div');
        indicatorContainer.className = 'day-indicator';
        dayEl.appendChild(indicatorContainer);

        const dateStr = dayData?.dateStr || (dateObj instanceof Date ? formatDateYYYYMMDD(dateObj) : null);
        if (dateStr) {
          dayEl.dataset.date = dateStr;
        }

        // Add click handler
        dayEl.addEventListener('click', () => {
          if (!isOtherMonth && dayEl.dataset.date) {
            openDayModal(dayEl.dataset.date);
          }
        });

        return dayEl;
      }

      // Add Indicators to Day
      function addIndicators(dayEl, dayData) {
        const indicatorContainer = dayEl.querySelector('.day-indicator');
        indicatorContainer.innerHTML = '';
        if (!dayData) return;

        const maxDotsPerGroup = 20;
        let totalDots = 0;

        // Group dots by group with group label - ONLY based on scheduled classes
        (dayData.groups || []).forEach((group, groupIndex) => {
          const groupRow = document.createElement('div');
          groupRow.className = 'group-dots-row';
          
          // Add group label FIRST
          const groupLabel = document.createElement('span');
          groupLabel.className = 'group-label';
          
          // Add canceled/skipped class if the group is canceled
          if (group.skipped) {
            groupLabel.classList.add(group.skipInfo?.type === 'class-canceled' ? 'canceled' : 'skipped');
          }
          
          // Extract group letter from groupCode or groupName (e.g., "Group A" -> "A")
          const groupCode = group.groupCode || canonicalizeGroupCode(group.groupName || '');
          const displayLetter = groupCode || (group.groupName || 'Group').replace(/^Group\s*/i, '').charAt(0) || '?';
          groupLabel.textContent = displayLetter.toUpperCase();
          groupLabel.title = group.groupName || 'Group';
          groupRow.appendChild(groupLabel);
          
          // Add warning emoji AFTER group label if class is canceled
          if (group.skipped && group.skipInfo?.type === 'class-canceled') {
            const warningEmoji = document.createElement('span');
            warningEmoji.textContent = '⚠️';
            warningEmoji.style.fontSize = '10px';
            warningEmoji.style.marginRight = '4px';
            warningEmoji.style.marginLeft = '2px';
            groupRow.appendChild(warningEmoji);
          }
          
          let groupDotCount = 0;
          
          // Sort students alphabetically by name
          const sortedStudents = [...(group.students || [])].sort((a, b) => {
            const nameA = (a.name || '').toLowerCase();
            const nameB = (b.name || '').toLowerCase();
            return nameA.localeCompare(nameB);
          });
          
          sortedStudents.forEach(student => {
            if (groupDotCount >= maxDotsPerGroup) return;
            
            const className = getDotClassForStudent(student);
            const tooltip = `${student.name} — ${student.statusLabel || student.status || ''}`;
            
            const dot = document.createElement('div');
            dot.className = `indicator-dot ${className}`;
            dot.textContent = '';
            if (tooltip) {
              dot.setAttribute('data-tooltip', tooltip);
              dot.style.cursor = 'pointer';
            }
            
            // Add data attributes for payment reminder email calculations
            dot.setAttribute('data-student-id', student.id);
            dot.setAttribute('data-student-name', student.name);
            dot.setAttribute('data-status', student.status || 'unpaid');
            dot.setAttribute('data-price', student.pricePerClass || student.price_per_class || 50);
            dot.setAttribute('data-date', dayData.dateStr);
            
            // Add click handler to open individual student details
            dot.addEventListener('click', (e) => {
              e.stopPropagation(); // Prevent day modal from opening
              const classDate = dayData.dateStr;
              openStudentDetails(student, classDate);
            });
            
            // Add hover handlers for custom tooltip
            dot.addEventListener('mouseenter', showCustomTooltip);
            dot.addEventListener('mouseleave', hideCustomTooltip);
            
            groupRow.appendChild(dot);
            groupDotCount++;
            totalDots++;
          });
          
          // Only add the row if it has dots
          if (groupDotCount > 0) {
            indicatorContainer.appendChild(groupRow);
          }
        });

        // If no dots were added, show generic indicators
        if (totalDots === 0 && indicatorContainer.children.length === 0) {
          const fallbackRow = document.createElement('div');
          fallbackRow.className = 'group-dots-row';
          
          Array.from(dayData.indicators || []).forEach(type => {
            const style = EVENT_STYLE_MAP[type];
            const className = style?.dotClass || `dot-${type}`;
            const dot = document.createElement('div');
            dot.className = `indicator-dot ${className}`;
            dot.setAttribute('data-tooltip', type.replace(/([A-Z])/g, ' $1').trim());
            dot.style.cursor = 'pointer';
            
            // Add hover handlers for custom tooltip
            dot.addEventListener('mouseenter', showCustomTooltip);
            dot.addEventListener('mouseleave', hideCustomTooltip);
            
            fallbackRow.appendChild(dot);
          });
          
          if (fallbackRow.children.length > 0) {
            indicatorContainer.appendChild(fallbackRow);
          }
        }
      }

      function applyDayStateClasses(dayEl, dayData) {
        dayEl.classList.remove('has-class', 'has-payment', 'has-absence', 'skipped');
        if (!dayData) return;
        if (filters.classes && dayData.stats?.classes) {
          dayEl.classList.add('has-class');
        }
        if (filters.payments && (dayData.stats?.payments || dayData.stats?.credits)) {
          dayEl.classList.add('has-payment');
        }
        if (filters.absences && dayData.stats?.absences) {
          dayEl.classList.add('has-absence');
        }
        if (filters.skipped && dayData.stats?.skipped) {
          dayEl.classList.add('skipped');
        }
      }

      function getDotClassForStudent(student) {
        if (!student) return 'dot-class';
        
        // Check status in priority order
        if (student.status === 'canceled') return 'dot-canceled';
        if (student.status === 'skipped') return 'dot-skipped';
        if (student.absent || student.status === 'absent') return 'dot-absent';
        if (student.status === 'credit') return 'dot-credit';
        if (student.paid || student.status === 'paid') return 'dot-payment';
        if (student.status === 'partial') return 'dot-partial';
        if (student.status === 'upcoming') return 'dot-future';
        if (student.status === 'unpaid') return 'dot-unpaid';
        
        // Default for scheduled classes
        return 'dot-class';
      }

      // Custom Tooltip Functions (using fixed positioning to escape stacking context)
      let tooltipElement = null;
      let activeTooltipDot = null;

      function updateTooltipPosition() {
        if (!tooltipElement || !activeTooltipDot) return;

        const rect = activeTooltipDot.getBoundingClientRect();
        const tooltipWidth = tooltipElement.offsetWidth;
        const tooltipHeight = tooltipElement.offsetHeight;
        
        // Get viewport dimensions
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;
        
        // Calculate initial position (centered above the dot)
        let left = rect.left + (rect.width / 2) - (tooltipWidth / 2);
        let top = rect.top - tooltipHeight - 10; // 10px gap above
        
        // Check right boundary
        if (left + tooltipWidth > viewportWidth - 10) {
          left = viewportWidth - tooltipWidth - 10; // 10px margin from right edge
        }
        
        // Check left boundary
        if (left < 10) {
          left = 10; // 10px margin from left edge
        }
        
        // Check top boundary - if tooltip would go above viewport, show it below the dot instead
        if (top < 10) {
          top = rect.bottom + 10; // 10px gap below the dot
        }
        
        // Check bottom boundary - if tooltip would go below viewport when positioned below, keep it above but adjust
        if (top + tooltipHeight > viewportHeight - 10) {
          top = rect.top - tooltipHeight - 10; // Try above again
          // If still doesn't fit, align to top of viewport
          if (top < 10) {
            top = 10;
          }
        }

        tooltipElement.style.left = `${left}px`;
        tooltipElement.style.top = `${top}px`;
      }

      function showCustomTooltip(event) {
        const dotElement = event.currentTarget;
        const tooltipText = dotElement.getAttribute('data-tooltip');
        
        if (!tooltipText) return;

        // Create tooltip element if it doesn't exist
        if (!tooltipElement) {
          tooltipElement = document.createElement('div');
          tooltipElement.className = 'custom-tooltip';
          document.body.appendChild(tooltipElement);
          
          // Update tooltip position on scroll
          window.addEventListener('scroll', updateTooltipPosition, true);
        }

        // Store reference to active dot
        activeTooltipDot = dotElement;

        // Set tooltip content
        tooltipElement.textContent = tooltipText;
        
        // Reset and show
        tooltipElement.classList.remove('visible');
        tooltipElement.style.display = 'block';
        
        // Force a reflow to ensure dimensions are calculated
        void tooltipElement.offsetHeight;

        // Position tooltip
        updateTooltipPosition();

        // Show tooltip with animation
        requestAnimationFrame(() => {
          tooltipElement.classList.add('visible');
        });
      }

      function hideCustomTooltip() {
        if (tooltipElement) {
          tooltipElement.classList.remove('visible');
          setTimeout(() => {
            if (!tooltipElement.classList.contains('visible')) {
              tooltipElement.style.display = 'none';
            }
          }, 200); // Wait for fade out animation
          activeTooltipDot = null;
        }
      }

      function formatCurrency(value) {
        const amount = Number(value) || 0;
        const hasCents = Math.abs(amount % 1) > 0;
        return amount.toLocaleString(undefined, {
          minimumFractionDigits: hasCents ? 2 : 0,
          maximumFractionDigits: hasCents ? 2 : 0,
        });
      }

      // Event Listeners
      function attachEventListeners() {
        // Navigation
        document.getElementById('prevMonth').addEventListener('click', () => {
          shiftCurrentView(-1);
          renderCalendar();
        });

        document.getElementById('nextMonth').addEventListener('click', () => {
          shiftCurrentView(1);
          renderCalendar();
        });

        document.getElementById('todayBtn').addEventListener('click', () => {
          syncCurrentDateToLAToday();
          renderCalendar();
        });

        // Credit notification bell
        const creditBell = document.getElementById('creditNotificationBell');
        if (creditBell) {
          creditBell.addEventListener('click', () => {
            triggerCreditReview();
          });
        }

        // Filters
        document.querySelectorAll('.filter-item').forEach(item => {
          item.addEventListener('click', () => {
            const filterType = item.getAttribute('data-filter');
            filters[filterType] = !filters[filterType];
            item.classList.toggle('active');
            renderCalendar();
          });
        });

        // Quick Actions
        document.querySelectorAll('.action-btn').forEach(btn => {
          btn.addEventListener('click', () => {
            debugLog('Action clicked:', btn.textContent.trim());
            // Add your action handlers here
          });
        });

        // Modal close handlers
        document.getElementById('closeModal').addEventListener('click', closeDayModal);
        document.getElementById('dayModal').addEventListener('click', e => {
          if (e.target.id === 'dayModal') {
            closeDayModal();
          }
        });

        // Confirm modal close handlers
        document.getElementById('closeConfirmModal').addEventListener('click', () => {
          document.getElementById('confirmModal').classList.remove('active');
        });
        document.getElementById('confirmModal').addEventListener('click', e => {
          if (e.target.id === 'confirmModal') {
            document.getElementById('confirmModal').classList.remove('active');
          }
        });

        // ESC key to close modal
        document.addEventListener('keydown', e => {
          if (e.key === 'Escape') {
            closeDayModal();
            document.getElementById('confirmModal').classList.remove('active');
          }
        });

        // Sidebar toggle
        document.getElementById('sidebarToggle').addEventListener('click', toggleSidebar);
        document.getElementById('floatingToggle').addEventListener('click', toggleSidebar);

        initPaymentReviewUI();
      }

      // Toggle Sidebar
      function toggleSidebar() {
        const sidebar = document.getElementById('sidebar');
        const container = document.querySelector('.container');
        const floatingToggle = document.getElementById('floatingToggle');

        sidebar.classList.toggle('expanded');
        container.classList.toggle('sidebar-expanded');
        floatingToggle.classList.toggle('hidden');
      }

      // Open Day Modal
      function openDayModal(dateInput) {
        let targetDate = null;
        if (typeof dateInput === 'string') {
          targetDate = createDateFromDateStr(dateInput) || new Date(dateInput);
        } else {
          const numericDay = Number(dateInput);
          const { year, month } = getCurrentViewYearMonth();
          targetDate = createDateFromParts(year, month, numericDay);
        }

        if (!targetDate || isNaN(targetDate.getTime())) return;

        const targetDateStr = formatDateYYYYMMDD(targetDate);
        const targetParts = parseDateParts(targetDateStr);
        if (!targetParts) return;

        const formattedDate = formatHumanDateInLA(targetDate);
        const dayOfWeek = getLAWeekdayName(targetDate);

        document.getElementById('modalDate').textContent = formattedDate;
        document.getElementById('modalDayOfWeek').textContent = dayOfWeek;

        const monthData = getMonthData(targetParts.year, targetParts.month - 1);
        const dayEntry = monthData?.dayMap?.[targetParts.day];
        const modalBody = document.getElementById('modalBody');

        if (!dayEntry) {
          modalBody.innerHTML = `<div class="modal-tab-content">${renderEmptyState('No events recorded for this day')}</div>`;
          showModal();
          return;
        }

        const groups = dayEntry.groups || [];
        const payments = dayEntry.payments || [];
        const credits = dayEntry.credits || [];
        const studentEvents = dayEntry.studentEvents || [];

        // Create tabs structure
        let tabsHtml = '';
        let tabPanelsHtml = '';

        if (groups.length) {
          // Collect all unpaid students from all groups
          let unpaidStudents = [];
          groups.forEach(group => {
            if (group.students && group.students.length) {
              group.students.forEach((student, idx) => {
                if (student.status === 'unpaid' || student.status === 'upcoming') {
                  unpaidStudents.push({
                    student: student,
                    group: group,
                    index: idx
                  });
                }
              });
            }
          });

          // Add "Unpaid" tab
          const unpaidCount = unpaidStudents.length;
          tabsHtml += `<div class="modal-tab active" onclick="switchModalTab(event, 'unpaid')">Unpaid (${unpaidCount})</div>`;
          
          let unpaidContent = '';
          if (unpaidStudents.length > 0) {
            const unpaidStudentsHtml = unpaidStudents
              .map(item => renderStudentCard(item.student, item.group, formattedDate, item.index))
              .join('');
            
            unpaidContent = `
              <div class="group-section">
                <div class="group-header">
                  <div class="group-header-content">
                    <div class="group-icon">�</div>
                    <div class="group-info">
                      <h3>Unpaid Students</h3>
                      <div class="group-time">${unpaidCount} student${unpaidCount === 1 ? '' : 's'} need payment</div>
                    </div>
                  </div>
                </div>
                <div class="students-list">
                  ${unpaidStudentsHtml}
                </div>
              </div>
            `;
          } else {
            unpaidContent = renderEmptyState('All students are paid! 🎉');
          }
          
          tabPanelsHtml += `<div class="tab-panel active" data-tab="unpaid">${unpaidContent}</div>`;

          // Add individual group tabs
          groups.forEach((group, groupIndex) => {
            const groupName = group.groupName || group.group || 'Group';
            const tabId = `group-${groupIndex}`;
            const studentCount = group.students?.length || 0;
            
            tabsHtml += `<div class="modal-tab" onclick="switchModalTab(event, '${tabId}')">${groupName} (${studentCount})</div>`;
            
            const studentsHtml = group.students && group.students.length
              ? group.students.map((student, idx) => renderStudentCard(student, group, formattedDate, idx)).join('')
              : renderEmptyState(group.skipInfo?.note || 'Class canceled - no students');

            const laTime = group.laTime ? `${group.laTime} LA` : '';
            const times = [group.day, laTime].filter(Boolean).join(' • ');
            const skipBadge = group.skipped
              ? `<span class="badge absent">${group.skipInfo?.note || (group.skipInfo?.type === 'class-canceled' ? 'Class canceled' : 'Class skipped')}</span>`
              : '';
            
            const cancelButton = group.skipped
              ? `<button class="quick-action-btn secondary" onclick="uncancelClass('${group.groupName}', '${targetDateStr}')" style="padding: 8px 16px; font-size: 12px;">↩️ Uncancel</button>`
              : `<button class="quick-action-btn tertiary" onclick="cancelClass('${group.groupName}', '${targetDateStr}')" style="padding: 8px 16px; font-size: 12px;">🚫 Cancel Class</button>`;

            const groupContent = `
              <div class="group-section">
                <div class="group-header">
                  <div class="group-header-content">
                    <div class="group-icon">👥</div>
                    <div class="group-info">
                      <h3>${groupName}</h3>
                      <div class="group-time">${times || group.day || ''}</div>
                    </div>
                    ${skipBadge}
                  </div>
                  <div class="group-header-actions">
                    ${cancelButton}
                  </div>
                </div>
                <div class="students-list">
                  ${studentsHtml}
                </div>
              </div>
            `;
            
            tabPanelsHtml += `<div class="tab-panel" data-tab="${tabId}">${groupContent}</div>`;
          });
        }

        if (studentEvents.length) {
          const eventsHtml = studentEvents
            .map(event => {
              const icon = getEventIcon(event.type);
              return `
                <div class="student-card">
                  <div class="student-info">
                    <div class="student-avatar">${icon}</div>
                    <div class="student-details">
                      <div class="student-name">${event.studentName}</div>
                      <div class="student-status">${event.label || 'Milestone'}</div>
                    </div>
                  </div>
                </div>
              `;
            })
            .join('');

          const eventsContent = `
            <div class="group-section">
              <div class="group-header">
                <div class="group-icon">🎉</div>
                <div class="group-info">
                  <h3>Student Events</h3>
                  <div class="group-time">${studentEvents.length} event${studentEvents.length === 1 ? '' : 's'}</div>
                </div>
              </div>
              <div class="students-list">
                ${eventsHtml}
              </div>
            </div>
          `;
          
          // Add events tab if there are any
          if (tabsHtml) {
            tabsHtml += `<div class="modal-tab" onclick="switchModalTab(event, 'events')">Events (${studentEvents.length})</div>`;
            tabPanelsHtml += `<div class="tab-panel" data-tab="events">${eventsContent}</div>`;
          } else {
            // If only events, no tabs needed
            modalBody.innerHTML = `<div class="modal-tab-content">${eventsContent}</div>`;
            showModal();
            return;
          }
        }

        if (!tabsHtml) {
          modalBody.innerHTML = `<div class="modal-tab-content">${renderEmptyState('No classes, payments, or events for this day')}</div>`;
          showModal();
          return;
        }

        // Build final modal structure with tabs
        modalBody.innerHTML = `
          <div class="modal-tabs">
            ${tabsHtml}
          </div>
          <div class="modal-tab-content">
            ${tabPanelsHtml}
          </div>
        `;

        showModal();

        function renderStudentCard(student, group, classDate, index) {
          const displayName = student.name || 'Student';
          const initials = displayName
            .split(' ')
            .map(n => n[0])
            .join('');
          const normalizedId = `student-${dayEntry.dateStr}-${student.id || `${group.groupName || 'group'}-${index}`}`
            .replace(/[^a-zA-Z0-9-_]/g, '_');
          const safeName = displayName.replace(/'/g, "\\'");
          const studentId = student.id;
          const dateStr = dayEntry.dateStr;
          const pricePerClass = student.pricePerClass || 0;
          const studentBalance = student.balance || 0;
          
          // Debug log
          debugLog('💳 Student Card DEBUG:', {
            name: displayName,
            id: studentId,
            balance: studentBalance,
            rawBalance: student.balance,
            pricePerClass,
            status: student.status,
            showCredit: studentBalance >= pricePerClass && pricePerClass > 0,
            studentObject: student
          });

          let badges = '';
          if (student.status === 'canceled') {
            badges += '<span class="badge absent">Class canceled</span>';
          } else if (student.status === 'skipped') {
            badges += '<span class="badge absent">Class skipped</span>';
          } else if (student.status === 'absent' || student.absent) {
            badges += '<span class="badge absent">Absent</span>';
          } else if (student.status === 'paid' || student.paid) {
            badges += `<span class="badge paid">Paid ${formatCurrency(student.paidAmount || student.pricePerClass)} $</span>`;
          } else if (student.status === 'credit') {
            badges += `<span class="badge paid">Credit</span>`;
          } else if (student.status === 'upcoming') {
            badges += '<span class="badge unpaid">Upcoming</span>';
          } else {
            badges += '<span class="badge unpaid">Unpaid</span>';
          }

          // Build action buttons based on student status
          let actionButtons = '';
          
          if (student.status === 'canceled' || student.status === 'skipped') {
            // No action buttons for canceled/skipped classes
            actionButtons = '';
          } else if (student.status === 'absent' || student.absent) {
            // Show unmark absent button
            actionButtons = `
              <div class="student-actions">
                <button class="action-icon-btn"
                        data-tooltip="Unmark Absent"
                        onclick="event.stopPropagation(); unmarkAbsent(${studentId}, '${dateStr}')">
                  ↩️
                </button>
              </div>
            `;
          } else if (student.status === 'unpaid' || student.status === 'upcoming') {
            // Show full action buttons for unpaid students
            let actionButtonsHtml = `
              <button class="action-icon-btn pause ${student.autoPaused ? 'paused' : ''}"
                      data-student-id="${normalizedId}"
                      data-tooltip="${student.autoPaused ? 'Resume Auto Reminder' : 'Pause Auto Reminder'}"
                      onclick="event.stopPropagation(); toggleAutoReminder('${normalizedId}', '${safeName}')">
                ${student.autoPaused ? '▶' : '⏸'}
              </button>
              <button class="action-icon-btn send"
                      data-student-id="${normalizedId}"
                      data-tooltip="Email"
                      onclick="event.stopPropagation(); sendManualReminder(${studentId}, '${safeName}')">
                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                  <path d="M5 12h14M12 5l7 7-7 7"/>
                </svg>
              </button>
              <button class="action-icon-btn mark-paid"
                      data-tooltip="Cash"
                      onclick="event.stopPropagation(); markPaidManually(${studentId}, '${dateStr}', ${pricePerClass}, '${safeName}')">
                💵
              </button>
              <button class="action-icon-btn"
                      data-tooltip="Absent"
                      onclick="event.stopPropagation(); markAsAbsent(${studentId}, '${dateStr}')">
                ⚪
              </button>
            `;
            
            // Add credit button if student has sufficient balance
            if (studentBalance >= pricePerClass && pricePerClass > 0) {
              actionButtonsHtml += `
                <button class="action-icon-btn"
                        data-tooltip="From Credit"
                        onclick="event.stopPropagation(); applyFromCredit(${studentId}, '${dateStr}', ${pricePerClass})">
                  💳
                </button>
              `;
            }
            
            actionButtons = `<div class="student-actions">${actionButtonsHtml}</div>`;
          } else if (student.status === 'paid' || student.status === 'credit') {
            // Show absent button even for paid students (allow marking paid students as absent)
            actionButtons = `
              <div class="student-actions">
                <button class="action-icon-btn"
                        data-tooltip="Mark Absent"
                        onclick="event.stopPropagation(); markAsAbsent(${studentId}, '${dateStr}')">
                  ⚪
                </button>
              </div>
            `;
          }

          const studentPayload = JSON.stringify(student).replace(/"/g, '&quot;');

          return `
            <div class="student-card">
              <div class="student-info">
                <div class="student-avatar">${initials}</div>
                <div class="student-details">
                  <div class="student-name student-name-clickable" onclick="openStudentDetails(${studentPayload}, '${classDate}')">${displayName}</div>
                  <div class="student-status">${student.statusLabel || 'Active student'}</div>
                </div>
              </div>
              <div style="display: flex; align-items: center; gap: 10px; flex-wrap: wrap;">
                ${actionButtons}
                <div class="student-badges">
                  ${badges}
                </div>
              </div>
            </div>
          `;
        }

        function renderEmptyState(text) {
          return `
            <div class="empty-state">
              <div class="empty-state-icon">📅</div>
              <div class="empty-state-text">${text}</div>
            </div>
          `;
        }

        function getEventIcon(type) {
          return EVENT_STYLE_MAP[type]?.icon || '📌';
        }

        function showModal() {
          const modal = document.getElementById('dayModal');
          modal.classList.add('active');
          document.body.style.overflow = 'hidden';
        }
      }

      // Close Day Modal
      function closeDayModal() {
        const modal = document.getElementById('dayModal');
        modal.classList.remove('active');
        document.body.style.overflow = '';
      }

      // Switch Modal Tab
      function switchModalTab(event, tabId) {
        // Remove active class from all tabs and panels
        const tabs = document.querySelectorAll('.modal-tab');
        const panels = document.querySelectorAll('.tab-panel');
        
        tabs.forEach(tab => tab.classList.remove('active'));
        panels.forEach(panel => panel.classList.remove('active'));
        
        // Add active class to clicked tab and corresponding panel
        event.currentTarget.classList.add('active');
        const targetPanel = document.querySelector(`[data-tab="${tabId}"]`);
        if (targetPanel) {
          targetPanel.classList.add('active');
        }
      }

      // Toggle Auto Reminder
      function toggleAutoReminder(studentId, studentName) {
        const button = document.querySelector(`[data-student-id="${studentId}"].pause`);
        if (!button) {
          // console.warn('Toggle auto reminder button not found for', studentId);
          return;
        }
        const isPaused = button.classList.contains('paused');

        button.classList.toggle('paused');
        button.innerHTML = isPaused ? '⏸' : '▶';
        button.setAttribute('data-tooltip', isPaused ? 'Pause Auto Reminder' : 'Resume Auto Reminder');

        debugLog(`${isPaused ? 'Resumed' : 'Paused'} auto reminder for ${studentName}`);

        // Here you would make an API call to update the student's auto-reminder status
        // Example: await updateAutoReminder(studentId, !isPaused);
      }

      // Pause Student
      async function pauseStudent(studentId, studentName) {
        try {
          debugLog(`Preparing to pause student ${studentName}`, { studentId });

          // Show confirmation dialog
          const confirmed = await showConfirmDialog(
            'Pause Student?',
            `
              <div style="text-align: left; line-height: 1.6;">
                <div style="margin-bottom: 12px;"><strong>Student:</strong> ${studentName}</div>
                <div style="margin-top: 16px; padding: 12px; background: rgba(255,193,7,0.1); border-radius: 8px; font-size: 13px; color: rgba(255,255,255,0.8);">
                  This will temporarily pause all classes for this student. They won't appear on the calendar until resumed.
                </div>
              </div>
            `
          );

          if (!confirmed) return;

          // Update student status to paused
          try {
            const { error } = await window.supabaseClient
              .from('students')
              .update({ status: 'paused' })
              .eq('id', studentId);

            if (error) throw error;

            showSuccessToast(`⏸ ${studentName} has been paused`);
            debugLog(`✅ Student paused: ${studentName}`);
            
            // Refresh calendar
            await loadAllData();
            renderCalendar(currentDate);
          } catch (dbErr) {
            console.error('❌ Failed to pause student:', dbErr);
            showErrorToast(`❌ Failed to pause student: ${dbErr.message}`);
          }
        } catch (err) {
          console.error('❌ Error pausing student:', err);
          showErrorToast('❌ Error pausing student. Please try again.');
        }
      }

      // Forward Student to Next Payment Cycle
      async function forwardStudent(studentId, studentName) {
        try {
          debugLog(`Preparing to forward student ${studentName}`, { studentId });

          // Show confirmation dialog
          const confirmed = await showConfirmDialog(
            'Forward to Next Cycle?',
            `
              <div style="text-align: left; line-height: 1.6;">
                <div style="margin-bottom: 12px;"><strong>Student:</strong> ${studentName}</div>
                <div style="margin-top: 16px; padding: 12px; background: rgba(38,255,230,0.1); border-radius: 8px; font-size: 13px; color: rgba(255,255,255,0.8);">
                  This will move the student to the next payment cycle, clearing current unpaid classes.
                </div>
              </div>
            `
          );

          if (!confirmed) return;

          // Update last payment date to current date
          try {
            const today = new Date().toISOString().split('T')[0];
            const { error } = await window.supabaseClient
              .from('students')
              .update({ last_payment_date: today })
              .eq('id', studentId);

            if (error) throw error;

            showSuccessToast(`⏭ ${studentName} forwarded to next cycle`);
            debugLog(`✅ Student forwarded: ${studentName}`);
            
            // Refresh calendar
            await loadAllData();
            renderCalendar(currentDate);
          } catch (dbErr) {
            console.error('❌ Failed to forward student:', dbErr);
            showErrorToast(`❌ Failed to forward student: ${dbErr.message}`);
          }
        } catch (err) {
          console.error('❌ Error forwarding student:', err);
          showErrorToast('❌ Error forwarding student. Please try again.');
        }
      }

      // Send Manual Reminder
      async function sendManualReminder(studentId, studentName) {
        try {
          debugLog(`Preparing to send manual payment reminder to ${studentName}`, { studentId });

          // Show confirmation dialog
          const confirmed = await showConfirmDialog(
            'Send Payment Reminder?',
            `
              <div style="text-align: left; line-height: 1.6;">
                <div style="margin-bottom: 12px;"><strong>Student:</strong> ${studentName}</div>
                <div style="margin-top: 16px; padding: 12px; background: rgba(38,255,230,0.1); border-radius: 8px; font-size: 13px; color: rgba(255,255,255,0.8);">
                  This will send a payment reminder email to the student.
                </div>
              </div>
            `
          );

          if (!confirmed) return;

          // Send payment reminder email
          try {
            await sendPaymentReminderEmail(studentId);
            showSuccessToast(`✅ Payment reminder sent to ${studentName}!`);
            debugLog(`✅ Manual reminder sent to ${studentName}`);
          } catch (emailErr) {
            console.error('❌ Failed to send payment reminder email:', emailErr);
            showErrorToast(`❌ Failed to send email: ${emailErr.message}`);
          }
        } catch (err) {
          console.error('❌ Error sending reminder:', err);
          showErrorToast('❌ Error sending reminder. Please try again.');
        }
      }

      // Show Cash Payment Dialog with Amount Selection
      function showCashPaymentDialog(student, dateStr, defaultAmount) {
        debugLog('🔔 showCashPaymentDialog called', { student, dateStr, defaultAmount });
        return new Promise((resolve) => {
          const modal = document.getElementById('confirmModal');
          const title = document.getElementById('confirmTitle');
          const message = document.getElementById('confirmMessage');
          const confirmBtn = document.getElementById('confirmBtn');
          const cancelBtn = document.getElementById('cancelBtn');
          
          debugLog('📦 Modal elements:', { modal, title, message, confirmBtn, cancelBtn });
          
          if (!modal || !title || !message || !confirmBtn || !cancelBtn) {
            console.error('❌ Missing modal elements!');
            resolve({ confirmed: false });
            return;
          }
          
          let selectedAmount = defaultAmount;
          
          title.textContent = 'Cash Payment - Select Amount';
          
          message.innerHTML = `
            <div style="text-align: left; line-height: 1.6;">
              <div style="margin-bottom: 12px;"><strong>Student:</strong> ${student.name}</div>
              <div style="margin-bottom: 12px;"><strong>Class Date:</strong> ${dateStr}</div>
              <div style="margin-bottom: 12px;"><strong>Expected:</strong> ${formatCurrency(defaultAmount)} $ (per class rate)</div>
              
              <div style="margin-top: 20px; margin-bottom: 12px;">
                <strong>Select Payment Amount:</strong>
              </div>
              
              <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin-bottom: 16px;">
                <button class="amount-btn" data-amount="25" style="padding: 12px; background: rgba(255,255,255,0.1); border: 2px solid rgba(255,255,255,0.2); border-radius: 8px; color: white; cursor: pointer; font-size: 16px; font-weight: 600; transition: all 0.2s;">
                  $25
                </button>
                <button class="amount-btn" data-amount="50" style="padding: 12px; background: rgba(255,255,255,0.1); border: 2px solid rgba(255,255,255,0.2); border-radius: 8px; color: white; cursor: pointer; font-size: 16px; font-weight: 600; transition: all 0.2s;">
                  $50
                </button>
                <button class="amount-btn" data-amount="75" style="padding: 12px; background: rgba(255,255,255,0.1); border: 2px solid rgba(255,255,255,0.2); border-radius: 8px; color: white; cursor: pointer; font-size: 16px; font-weight: 600; transition: all 0.2s;">
                  $75
                </button>
                <button class="amount-btn" data-amount="100" style="padding: 12px; background: rgba(255,255,255,0.1); border: 2px solid rgba(255,255,255,0.2); border-radius: 8px; color: white; cursor: pointer; font-size: 16px; font-weight: 600; transition: all 0.2s;">
                  $100
                </button>
                <button class="amount-btn" data-amount="150" style="padding: 12px; background: rgba(255,255,255,0.1); border: 2px solid rgba(255,255,255,0.2); border-radius: 8px; color: white; cursor: pointer; font-size: 16px; font-weight: 600; transition: all 0.2s;">
                  $150
                </button>
                <button class="amount-btn" data-amount="200" style="padding: 12px; background: rgba(255,255,255,0.1); border: 2px solid rgba(255,255,255,0.2); border-radius: 8px; color: white; cursor: pointer; font-size: 16px; font-weight: 600; transition: all 0.2s;">
                  $200
                </button>
              </div>
              
              <div style="margin-bottom: 16px;">
                <label style="display: block; margin-bottom: 8px; color: rgba(255,255,255,0.7); font-size: 14px;">Or enter custom amount:</label>
                <input type="number" id="customAmount" min="0" step="0.01" placeholder="Enter amount" 
                       style="width: 100%; padding: 10px; background: rgba(255,255,255,0.1); border: 2px solid rgba(255,255,255,0.2); border-radius: 8px; color: white; font-size: 16px;"
                       value="${defaultAmount}">
              </div>
              
              <div id="selectedAmountDisplay" style="margin-top: 16px; padding: 12px; background: rgba(5,150,105,0.2); border-radius: 8px; font-size: 14px; color: rgba(255,255,255,0.9);">
                💵 Selected amount: <strong>${formatCurrency(selectedAmount)} $</strong>
              </div>
            </div>
          `;
          
          // Handle amount button clicks
          const amountBtns = message.querySelectorAll('.amount-btn');
          const customInput = message.querySelector('#customAmount');
          const displayDiv = message.querySelector('#selectedAmountDisplay');
          
          function updateSelection(amount) {
            selectedAmount = parseFloat(amount);
            customInput.value = amount;
            displayDiv.innerHTML = `💵 Selected amount: <strong>${formatCurrency(selectedAmount)} $</strong>`;
            
            // Update button styles
            amountBtns.forEach(btn => {
              if (parseFloat(btn.dataset.amount) === selectedAmount) {
                btn.style.background = 'rgba(34,197,94,0.3)';
                btn.style.borderColor = 'rgba(34,197,94,0.8)';
                btn.style.transform = 'scale(1.05)';
              } else {
                btn.style.background = 'rgba(255,255,255,0.1)';
                btn.style.borderColor = 'rgba(255,255,255,0.2)';
                btn.style.transform = 'scale(1)';
              }
            });
          }
          
          amountBtns.forEach(btn => {
            btn.addEventListener('click', (e) => {
              e.preventDefault();
              e.stopPropagation();
              updateSelection(btn.dataset.amount);
            });
            
            // Highlight default amount button
            if (parseFloat(btn.dataset.amount) === defaultAmount) {
              btn.style.background = 'rgba(34,197,94,0.3)';
              btn.style.borderColor = 'rgba(34,197,94,0.8)';
            }
          });
          
          customInput.addEventListener('input', (e) => {
            const value = parseFloat(e.target.value) || 0;
            updateSelection(value);
          });
          
          confirmBtn.textContent = 'Confirm Payment';
          
          const handleConfirm = () => {
            cleanup();
            resolve({ confirmed: true, amount: selectedAmount });
          };
          
          const handleCancel = () => {
            cleanup();
            resolve({ confirmed: false });
          };
          
          const cleanup = () => {
            confirmBtn.removeEventListener('click', handleConfirm);
            cancelBtn.removeEventListener('click', handleCancel);
            modal.classList.remove('active');
          };
          
          confirmBtn.addEventListener('click', handleConfirm);
          cancelBtn.addEventListener('click', handleCancel);
          
          debugLog('🎭 About to show modal, adding active class');
          modal.classList.add('active');
          debugLog('✅ Modal classes:', modal.className);
        });
      }

      // Mark Student as Absent
      async function markAsAbsent(studentId, dateStr) {
        try {
          // Get student info for confirmation
          const students = window.studentsCache || [];
          const student = students.find(s => s.id === studentId);
          
          if (!student) {
            showErrorToast('❌ Student not found');
            return;
          }

          // Show confirmation dialog
          const confirmed = await showConfirmDialog(
            'Mark Student as Absent?',
            `
              <div style="text-align: left; line-height: 1.6;">
                <div style="margin-bottom: 12px;"><strong>Student:</strong> ${student.name}</div>
                <div style="margin-bottom: 12px;"><strong>Class Date:</strong> ${dateStr}</div>
                <div style="margin-top: 16px; padding: 12px; background: rgba(100,116,139,0.2); border-radius: 8px; font-size: 13px; color: rgba(255,255,255,0.8);">
                  The student will be marked as absent for this class.
                </div>
              </div>
            `
          );

          if (!confirmed) return;

          // Use AbsentManager for cloud sync
          if (window.AbsentManager) {
            await window.AbsentManager.markAbsent(studentId, dateStr);
            debugLog('✅ Marked absent via AbsentManager:', { studentId, dateStr });
            
            // Show success message
            showSuccessToast('⚪ Marked as absent');
            
            // Reload absences data from database to ensure fresh data
            absencesData = await loadAbsences();
            
            // Force complete calendar refresh
            clearMonthCache();
            
            // Re-render calendar with fresh data
            await renderCalendar();
            
            // Refresh the day modal to show updated status
            openDayModal(dateStr);
          } else {
            throw new Error('AbsentManager not available');
          }
        } catch (err) {
          console.error('❌ Error marking absent:', err);
          showErrorToast('❌ Error marking absent. Please try again.');
        }
      }

      // Unmark Student as Absent
      async function unmarkAbsent(studentId, dateStr) {
        try {
          // Get student info for confirmation
          const students = window.studentsCache || [];
          const student = students.find(s => s.id === studentId);
          
          if (!student) {
            showErrorToast('❌ Student not found');
            return;
          }

          // Show confirmation dialog
          const confirmed = await showConfirmDialog(
            'Remove Absent Status?',
            `
              <div style="text-align: left; line-height: 1.6;">
                <div style="margin-bottom: 12px;"><strong>Student:</strong> ${student.name}</div>
                <div style="margin-bottom: 12px;"><strong>Class Date:</strong> ${dateStr}</div>
                <div style="margin-top: 16px; padding: 12px; background: rgba(34,197,94,0.2); border-radius: 8px; font-size: 13px; color: rgba(255,255,255,0.8);">
                  The absent status will be removed for this class.
                </div>
              </div>
            `
          );

          if (!confirmed) return;

          // Use AbsentManager for cloud sync
          if (window.AbsentManager) {
            await window.AbsentManager.removeAbsent(studentId, dateStr);
            debugLog('✅ Unmarked absent via AbsentManager:', { studentId, dateStr });
            
            // Show success message
            showSuccessToast('↩️ Unmarked as absent');
            
            // Reload absences data from database to ensure fresh data
            absencesData = await loadAbsences();
            
            // Force complete calendar refresh
            clearMonthCache();
            
            // Re-render calendar with fresh data
            await renderCalendar();
            
            // Refresh the day modal to show updated status
            openDayModal(dateStr);
          } else {
            throw new Error('AbsentManager not available');
          }
        } catch (err) {
          console.error('❌ Error unmarking absent:', err);
          showErrorToast('❌ Error unmarking absent. Please try again.');
        }
      }

  // Mark Paid Manually
  // TODO (Payment Revamp): Reconcile this cash-payment path with the credit top-up model.
  // For now we still drop records directly into payments, but long-term this should
  // credit the student's balance and let CreditPaymentManager create the coverage entry.
      async function markPaidManually(studentId, dateStr, pricePerClass, studentName) {
        debugLog('💵 markPaidManually called', { studentId, dateStr, pricePerClass, studentName });
        try {
          // Get student info for confirmation
          const students = window.studentsCache || [];
          const student = students.find(s => s.id === studentId);
          
          debugLog('👤 Found student:', student);
          
          if (!student) {
            showErrorToast('❌ Student not found');
            return;
          }

          debugLog('📞 Calling showCashPaymentDialog...');
          // Show custom dialog with amount selection
          const result = await showCashPaymentDialog(student, dateStr, pricePerClass);
          
          debugLog('✅ Dialog result:', result);
          
          if (!result || !result.confirmed) {
            debugLog('❌ User cancelled or dialog failed');
            return;
          }
          
          const paymentAmount = result.amount;

          // Create a manual payment record with LA timezone date
          const paymentRecord = {
            student_id: studentId,
            student_name: student.name,
            amount: paymentAmount,
            date: dateStr, // Use the class date as payment date
            email_date: dateStr + 'T12:00:00', // Set to noon on class date in LA time
            timestamp: new Date().toISOString(),
            payer_name: student.name,
            message: 'Cash payment',
            source: 'manual',
            is_manual: true,
            ignored: false
          };

          // Insert into Supabase payments table
          const { error } = await supabase
            .from('payments')
            .insert([paymentRecord]);

          if (error) {
            console.error('❌ Error creating manual payment:', error);
            showErrorToast('❌ Failed to create payment record');
            return;
          }

          debugLog('✅ Manual cash payment created:', paymentRecord);
          
          // Show success message
          showSuccessToast('💵 Cash payment recorded');
          
          // Close the modal
          closeDayModal();
          
          // Reload payment data and refresh calendar
          await loadPayments();
          clearMonthCache();
          renderCalendar();
          
        } catch (err) {
          console.error('❌ Error marking paid manually:', err);
          showErrorToast('❌ Error creating payment. Please try again.');
        }
      }

      // Apply Credit Payment
      async function applyFromCredit(studentId, dateStr, pricePerClass) {
        try {
          // Get student from cache
          const students = window.studentsCache || [];
          const student = students.find(s => s.id === studentId);

          if (!student) {
            showErrorToast('❌ Student not found');
            return;
          }

          const currentBalance = parseFloat(student.balance) || 0;

          // Check if student has enough credit
          if (currentBalance < pricePerClass) {
            showErrorToast(
              `❌ Insufficient credit! Need ${formatCurrency(pricePerClass - currentBalance)} $ more.`
            );
            return;
          }

          // Show custom confirm dialog
          const newBalance = currentBalance - pricePerClass;
          const confirmed = await showConfirmDialog(
            'Apply Credit Payment?',
            `
              <div style="text-align: left; line-height: 1.6;">
                <div style="margin-bottom: 12px;"><strong>Student:</strong> ${student.name}</div>
                <div style="margin-bottom: 12px;"><strong>Class Date:</strong> ${dateStr}</div>
                <div style="margin-bottom: 12px;"><strong>Class Price:</strong> ${formatCurrency(pricePerClass)} $</div>
                <div style="margin-bottom: 12px; padding-top: 12px; border-top: 1px solid rgba(255,255,255,0.1);">
                  <strong>Current Balance:</strong> ${formatCurrency(currentBalance)} $
                </div>
                <div style="color: #22c55e; font-weight: 700;">
                  <strong>New Balance:</strong> ${formatCurrency(newBalance)} $
                </div>
              </div>
            `
          );

          if (!confirmed) return;

          // Deduct from balance
          student.balance = newBalance;

          // Save to Supabase
          const { error: updateError } = await supabase
            .from('students')
            .update({ balance: newBalance })
            .eq('id', studentId);

          if (updateError) {
            throw new Error(`Failed to update student balance: ${updateError.message}`);
          }

          // Store credit payment using CreditPaymentManager for cloud sync
          if (window.CreditPaymentManager) {
            await window.CreditPaymentManager.applyCreditPayment(studentId, dateStr, pricePerClass, newBalance);
            debugLog('✅ Applied credit payment (Supabase):', { studentId, dateStr, amount: pricePerClass });
          } else {
            throw new Error('CreditPaymentManager not available');
          }

          showSuccessToast(
            `✅ Applied ${formatCurrency(pricePerClass)} $ from credit • New Balance: ${formatCurrency(newBalance)} $`
          );

          // Close the modal
          closeDayModal();

          // Reload credit data and refresh calendar
          creditPaymentsLookup = await loadCreditPayments();
          clearMonthCache();
          renderCalendar();
        } catch (error) {
          console.error('❌ Failed to apply credit:', error);
          showErrorToast('❌ Failed to apply credit: ' + error.message);
        }
      }

      // Cancel Class
      async function cancelClass(groupName, dateStr) {
        try {
          // Get students in this group
          const groups = window.groupsCache || [];
          const targetCode = canonicalizeGroupCode(groupName);
          const group = groups.find(g => {
            const candidateCode = g.group_code || canonicalizeGroupCode(g.group_name || g.name || '');
            if (targetCode) return candidateCode === targetCode;
            const normalizedLabel = (g.group_name || g.name || '').trim().toLowerCase();
            return !candidateCode && normalizedLabel === (groupName || '').trim().toLowerCase();
          });
          
          if (!group) {
            showErrorToast('❌ Group not found');
            return;
          }

          // Get students for this group
          const students = window.studentsCache || [];
          const groupStudents = students.filter(s => {
            const sources = [
              s.group_code,
              s.group_display,
              s.group_name,
              s.group,
              s.groupName,
            ];
            if (Array.isArray(s.groups)) {
              sources.push(...s.groups);
            }

            return sources.some(value => {
              if (!value) return false;
              if (!targetCode) {
                return !canonicalizeGroupCode(value);
              }
              const candidate = canonicalizeGroupCode(value);
              return candidate === targetCode;
            });
          });

          // Show confirmation dialog
          const confirmed = await showConfirmDialog(
            'Cancel Class?',
            `
              <div style="text-align: left; line-height: 1.6;">
                <div style="margin-bottom: 12px;"><strong>Group:</strong> ${groupName}</div>
                <div style="margin-bottom: 12px;"><strong>Date:</strong> ${dateStr}</div>
                <div style="margin-bottom: 12px;"><strong>Students:</strong> ${groupStudents.length}</div>
                <div style="margin-top: 16px; padding: 12px; background: rgba(239,68,68,0.2); border-radius: 8px; font-size: 13px; color: rgba(255,255,255,0.8);">
                  📧 Cancellation emails will be sent to all students in this class
                </div>
              </div>
            `
          );

          if (!confirmed) return;

          // Save to Supabase
          const { error: insertError } = await supabase
            .from('skipped_classes')
            .insert({
              group_name: groupName,
              class_date: dateStr,
              skip_type: 'class-canceled',
              note: 'Class canceled'
            });

          if (insertError) {
            throw new Error(`Failed to cancel class: ${insertError.message}`);
          }

          // Send cancellation emails to all students
          let emailsSent = 0;
          for (const student of groupStudents) {
            if (student.email) {
              try {
                // TODO: Replace with actual email sending function
                debugLog(`📧 Sending cancellation email to ${student.name} (${student.email})`);
                // await sendCancellationEmail(student, groupName, dateStr);
                emailsSent++;
              } catch (emailError) {
                console.error(`⚠️ Failed to send email to ${student.name}:`, emailError);
              }
            }
          }

          showSuccessToast(
            `✅ Class canceled • ${emailsSent} email${emailsSent !== 1 ? 's' : ''} sent`
          );

          // Close the modal
          closeDayModal();

          // Reload skipped classes and refresh calendar
          skippedClassesData = await loadSkippedClasses();
          clearMonthCache();
          renderCalendar();
        } catch (error) {
          console.error('❌ Failed to cancel class:', error);
          showErrorToast('❌ Failed to cancel class: ' + error.message);
        }
      }

      // Uncancel Class
      async function uncancelClass(groupName, dateStr) {
        try {
          // Show confirmation dialog
          const confirmed = await showConfirmDialog(
            'Restore Class?',
            `
              <div style="text-align: left; line-height: 1.6;">
                <div style="margin-bottom: 12px;"><strong>Group:</strong> ${groupName}</div>
                <div style="margin-bottom: 12px;"><strong>Date:</strong> ${dateStr}</div>
                <div style="margin-top: 16px; padding: 12px; background: rgba(34,197,94,0.2); border-radius: 8px; font-size: 13px; color: rgba(255,255,255,0.8);">
                  The class will be restored to the schedule
                </div>
              </div>
            `
          );

          if (!confirmed) return;

          // Delete from Supabase
          const { error: deleteError } = await supabase
            .from('skipped_classes')
            .delete()
            .eq('group_name', groupName)
            .eq('class_date', dateStr);

          if (deleteError) {
            throw new Error(`Failed to restore class: ${deleteError.message}`);
          }

          showSuccessToast('✅ Class restored to schedule');

          // Close the modal
          closeDayModal();

          // Reload skipped classes and refresh calendar
          skippedClassesData = await loadSkippedClasses();
          clearMonthCache();
          renderCalendar();
        } catch (error) {
          console.error('❌ Failed to restore class:', error);
          showErrorToast('❌ Failed to restore class: ' + error.message);
        }
      }

      // Open Student Details Modal
      function openStudentDetails(student, classDate) {
        const modalBody = document.getElementById('modalBody');
        const modalTitle = document.getElementById('modalDate');
        const modalSubtitle = document.getElementById('modalDayOfWeek');

        // Update modal header
        modalTitle.textContent = student.name;
        modalSubtitle.textContent = student.groupName || 'Student Details';

        // Get full student record from cache to get balance
        const students = window.studentsCache || [];
        const fullStudent = students.find(s => s.id === student.id) || student;
        const studentBalance = parseFloat(fullStudent.balance) || 0;
        const pricePerClass = student.pricePerClass || 0;
        const classesRemaining = pricePerClass > 0 ? Math.floor(studentBalance / pricePerClass) : 0;

        // Build action buttons based on status
        let actionButtons = '';
        
        if (student.status === 'absent' || student.absent) {
          actionButtons = `
            <div class="quick-actions-grid">
              <button class="quick-action-btn secondary" onclick="unmarkAbsent(${student.id}, '${classDate}')">
                ↩️ Unmark Absent
              </button>
            </div>
          `;
        } else if (student.status === 'unpaid' || student.status === 'upcoming') {
          const safeName = student.name.replace(/'/g, "\\'");
          let buttons = `
            <button class="quick-action-btn pause" 
                    onclick="event.stopPropagation(); pauseStudent(${student.id}, '${safeName}')"
                    title="Pause student">
              ⏸
            </button>
            <button class="quick-action-btn forward" 
                    onclick="event.stopPropagation(); forwardStudent(${student.id}, '${safeName}')"
                    title="Forward to next cycle">
              ⏭
            </button>
            <button class="quick-action-btn email-reminder" 
                    onclick="event.stopPropagation(); sendManualReminder(${student.id}, '${safeName}')"
                    title="Send payment reminder">
              💳
            </button>
            <button class="quick-action-btn tertiary" 
                    onclick="markAsAbsent(${student.id}, '${classDate}')"
                    title="Mark as absent">
              ⚪
            </button>
          `;
          
          // Add credit button if student has sufficient balance
          if (studentBalance >= pricePerClass && pricePerClass > 0) {
            buttons += `
              <button class="quick-action-btn secondary" onclick="applyFromCredit(${student.id}, '${classDate}', ${pricePerClass})">
                💳 Apply from Credit (${formatCurrency(studentBalance)} $)
              </button>
            `;
          }
          
          actionButtons = `<div class="quick-actions-grid">${buttons}</div>`;
        } else if (student.status === 'paid' || student.status === 'credit') {
          // Add action button for paid/credit status - can mark as absent
          actionButtons = `
            <div class="quick-actions-grid">
              <button class="quick-action-btn tertiary" onclick="markAsAbsent(${student.id}, '${classDate}')">
                ⚪ Mark Absent
              </button>
            </div>
          `;
        }

        // Build student details content
        const content = `
          <div class="student-detail-section">
            <div class="section-label">Class Date</div>
            <div class="section-content">${classDate}</div>
          </div>

          <div class="student-detail-section">
            <div class="section-label">Status</div>
            <div class="section-content">
              ${student.statusLabel || student.status || 'Active'}
            </div>
          </div>

          <div class="student-detail-section">
            <div class="section-label">Price Per Class</div>
            <div class="section-content">${formatCurrency(pricePerClass)} $</div>
          </div>

          <div class="student-detail-section">
            <div class="section-label">Balance</div>
            <div class="section-content balance">
              ${formatCurrency(studentBalance)} $
              ${studentBalance > 0 ? `<div class="balance-note">≈ ${classesRemaining} class${classesRemaining !== 1 ? 'es' : ''} remaining</div>` : ''}
            </div>
          </div>

          ${actionButtons ? `
          <div class="student-detail-section">
            <div class="section-label">Quick Actions</div>
            ${actionButtons}
          </div>
          ` : ''}
        `;

        modalBody.innerHTML = content;
        
        // Show the modal
        const modal = document.getElementById('dayModal');
        modal.classList.add('active');
        document.body.style.overflow = 'hidden';
      }

      // Quick Action Handlers
      function addPayment(studentName) {
        debugLog(`Adding payment for ${studentName}`);

        const amount = prompt(`Enter payment amount for ${studentName}:`, '50');
        if (amount && !isNaN(amount) && parseFloat(amount) > 0) {
          debugLog(`Payment of $${amount} recorded for ${studentName}`);
          showSuccessToast(`✅ Payment of $${amount} added for ${studentName}`);

          // In production: await PaymentStore.add({ student_id, amount, date, ... });
          // Then refresh calendar and close modal
        } else if (amount !== null) {
          showErrorToast('❌ Invalid amount entered');
        }
      }

      function applyCredit(studentName) {
        debugLog(`Applying credit for ${studentName}`);

        const amount = prompt(`Enter credit amount to apply for ${studentName}:`, '50');
        if (amount && !isNaN(amount) && parseFloat(amount) > 0) {
          const confirmed = confirm(`Apply $${amount} credit to ${studentName}'s balance?`);
          if (confirmed) {
            debugLog(`Credit of $${amount} applied for ${studentName}`);
            showSuccessToast(`✅ Credit of $${amount} applied for ${studentName}`);

            // In production: await CreditPaymentManager.add({ student_id, amount, class_date, ... });
            // Then refresh calendar and update student balance
          }
        } else if (amount !== null) {
          showErrorToast('❌ Invalid amount entered');
        }
      }

      function markAbsent(studentName, classDate) {
        debugLog(`Marking ${studentName} as absent for ${classDate}`);

        const confirmed = confirm(`Mark ${studentName} as absent for ${classDate}?`);
        if (confirmed) {
          debugLog(`${studentName} marked as absent for ${classDate}`);
          showSuccessToast(`✅ ${studentName} marked as absent for ${classDate}`);

          // In production: await AbsentManager.markAbsent(student_id, class_date);
          // Then refresh calendar to show gray dot
          // And dispatch absence:updated event
        }
      }

      // Toast Notifications
      function showSuccessToast(message) {
        showToast(message, '#22c55e');
      }

      function showErrorToast(message) {
        showToast(message, '#ef4444');
      }

      function showToast(message, color) {
        // Create toast element
        const toast = document.createElement('div');
        toast.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          background: ${color};
          color: white;
          padding: 16px 24px;
          border-radius: 12px;
          font-weight: 600;
          font-size: 0.9rem;
          box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
          z-index: 100000;
          animation: slideIn 0.3s ease-out;
          max-width: 400px;
        `;
        toast.textContent = message;

        // Add animation keyframes if not exists
        if (!document.getElementById('toast-animations')) {
          const style = document.createElement('style');
          style.id = 'toast-animations';
          style.textContent = `
            @keyframes slideIn {
              from { transform: translateX(400px); opacity: 0; }
              to { transform: translateX(0); opacity: 1; }
            }
            @keyframes slideOut {
              from { transform: translateX(0); opacity: 1; }
              to { transform: translateX(400px); opacity: 0; }
            }
          `;
          document.head.appendChild(style);
        }

        document.body.appendChild(toast);

        // Remove after 3 seconds
        setTimeout(() => {
          toast.style.animation = 'slideOut 0.3s ease-out';
          setTimeout(() => toast.remove(), 300);
        }, 3000);
      }

      // Custom Confirm Dialog
      function showConfirmDialog(title, message) {
        return new Promise((resolve) => {
          // Create overlay
          const overlay = document.createElement('div');
          overlay.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 99999;
            backdrop-filter: blur(4px);
            display: flex;
            align-items: center;
            justify-content: center;
          `;

          // Create dialog
          const dialog = document.createElement('div');
          dialog.style.cssText = `
            background: linear-gradient(135deg, rgba(30,30,46,0.98) 0%, rgba(42,42,62,0.98) 100%);
            border: 2px solid rgba(138,180,255,0.3);
            border-radius: 16px;
            padding: 24px;
            min-width: 400px;
            max-width: 500px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.7);
          `;

          dialog.innerHTML = `
            <h3 style="margin: 0 0 16px 0; font-size: 20px; font-weight: 900; color: white;">${title}</h3>
            <div style="margin-bottom: 24px; color: rgba(255,255,255,0.9); font-size: 14px;">
              ${message}
            </div>
            <div style="display: flex; gap: 12px; justify-content: flex-end;">
              <button id="confirmCancel" style="
                padding: 10px 20px;
                background: rgba(255,255,255,0.05);
                border: 1px solid rgba(255,255,255,0.2);
                border-radius: 8px;
                color: white;
                font-size: 14px;
                font-weight: 600;
                cursor: pointer;
                transition: all 0.2s;
              ">Cancel</button>
              <button id="confirmOk" style="
                padding: 10px 20px;
                background: #22c55e;
                border: 1px solid #22c55e;
                border-radius: 8px;
                color: white;
                font-size: 14px;
                font-weight: 600;
                cursor: pointer;
                transition: all 0.2s;
              ">Confirm</button>
            </div>
          `;

          overlay.appendChild(dialog);
          document.body.appendChild(overlay);

          // Add hover effects
          const cancelBtn = dialog.querySelector('#confirmCancel');
          const okBtn = dialog.querySelector('#confirmOk');
          
          cancelBtn.addEventListener('mouseover', () => {
            cancelBtn.style.background = 'rgba(255,255,255,0.1)';
          });
          cancelBtn.addEventListener('mouseout', () => {
            cancelBtn.style.background = 'rgba(255,255,255,0.05)';
          });
          
          okBtn.addEventListener('mouseover', () => {
            okBtn.style.background = '#16a34a';
          });
          okBtn.addEventListener('mouseout', () => {
            okBtn.style.background = '#22c55e';
          });

          // Handle responses
          const cleanup = (result) => {
            overlay.remove();
            resolve(result);
          };

          cancelBtn.addEventListener('click', () => cleanup(false));
          okBtn.addEventListener('click', () => cleanup(true));
          overlay.addEventListener('click', (e) => {
            if (e.target === overlay) cleanup(false);
          });
        });
      }

      // Initialize on load
      document.addEventListener('DOMContentLoaded', initCalendar);
    </script>
  </body>
</html>
