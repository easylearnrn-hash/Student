<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Hyper Modern Calendar - ARNOMA Design</title>
    
    <!-- Supabase Configuration -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.45.1"></script>
    <script>
      // Supabase Client Initialization
      const SUPABASE_URL = 'https://zlvnxvrzotamhpezqedr.supabase.co';
      const SUPABASE_ANON_KEY =
        'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Inpsdm54dnJ6b3RhbWhwZXpxZWRyIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjI4MTEzMTcsImV4cCI6MjA3ODM4NzMxN30.-IoSqKhDrA9NuG4j3GufIbfmodWqCoppEklE1nTmw38';
      const supabaseClient = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
      
      // ============================================================
      // NOTIFICATION SYSTEM
      // ============================================================
      async function createNotification(type, studentName = '') {
        try {
          console.log('üîî Creating notification:', { type, studentName });

          // Generate title and description based on type
          let title = '';
          let description = '';
          let category = 'payment';

          switch(type) {
            case 'payment_ignored':
              title = 'Payment Marked as Resolved';
              description = `Payment for ${studentName} has been marked as resolved and will no longer show as a fuchsia dot`;
              break;
            case 'credit_added':
              title = 'Credit Added to Account';
              description = `Credit has been added to ${studentName}'s account`;
              break;
            default:
              title = 'Payment Notification';
              description = `Notification for ${studentName}`;
          }

          const { data, error} = await supabaseClient
            .from('notifications')
            .insert([
              {
                type: type,
                category: category,
                title: title,
                description: description,
                student_name: studentName,
                read: false,
                is_read: false,
                timestamp: new Date().toISOString()
              }
            ])
            .select();

          if (error) {
            console.error('‚ùå Error creating notification:', error);
            return null;
          }

          console.log('‚úÖ Notification created:', data[0]);
          return data[0];

        } catch (err) {
          console.error('‚ùå Exception creating notification:', err);
          return null;
        }
      }

      // Make globally available
      window.createNotification = createNotification;
      
      // Global data caches
      window.studentsCache = [];
      window.groupsCache = [];
      window.paymentsCache = [];
  const studentPaymentMatchCache = new Map();
  window.studentPaymentMatchCache = studentPaymentMatchCache;
      
      // ‚ö° PERFORMANCE: Global index caches to prevent recalculation on every month render
      let cachedStudentIndexes = null;
      let cachedPaymentIndexes = null;
      let cachedStudentsByGroup = null;
      let lastStudentsCacheSize = 0;
      let lastPaymentsCacheSize = 0;
      
      function invalidateIndexCaches() {
        cachedStudentIndexes = null;
        cachedPaymentIndexes = null;
        cachedStudentsByGroup = null;
        lastStudentsCacheSize = 0;
        lastPaymentsCacheSize = 0;
        debugLog('‚ö° Index caches invalidated');
      }
      
      // ============================================================
      // ‚ö° PERFORMANCE UTILITIES
      // ============================================================
      
      // Production mode - set to false to disable debug logging
      const DEBUG_MODE = false;
      
      // Debug logging wrapper (only logs when DEBUG_MODE is true)
      function debugLog(...args) {
        if (DEBUG_MODE) console.log(...args);
      }
      
      // DOM Cache to eliminate repeated getElementById calls
      const DOMCache = {
        prevBtn: null,
        nextBtn: null,
        todayBtn: null,
        modals: {},
        
        init() {
          this.prevBtn = document.getElementById('prevMonth');
          this.nextBtn = document.getElementById('nextMonth');
          this.todayBtn = document.getElementById('todayBtn');
          
          debugLog('‚úÖ Calendar DOM Cache initialized');
        },
        
        get(key) {
          return this[key] || document.getElementById(key);
        },
        
        invalidate(key) {
          if (key) {
            this[key] = null;
          } else {
            Object.keys(this).forEach(k => {
              if (typeof this[k] !== 'function') this[k] = null;
            });
          }
        }
      };
      
      // Data Cache for expensive computations (month data, events, etc.)
      const DataCache = {
        monthData: new Map(), // Cache computed month data
        events: null,
        students: null,
        lastFetch: {},
        
        TTL: 5 * 60 * 1000, // 5 minutes
        
        set(key, value) {
          this[key] = value;
          this.lastFetch[key] = Date.now();
        },
        
        get(key) {
          const age = Date.now() - (this.lastFetch[key] || 0);
          if (age > this.TTL) {
            this[key] = null;
            delete this.lastFetch[key];
            return null;
          }
          return this[key];
        },
        
        invalidate(key) {
          if (key) {
            this[key] = null;
            delete this.lastFetch[key];
          } else {
            Object.keys(this).forEach(k => {
              if (typeof this[k] !== 'function' && k !== 'monthData') this[k] = null;
            });
            this.lastFetch = {};
          }
        },
        
        // Month-specific caching
        getMonth(year, month) {
          const key = `${year}-${month}`;
          return this.monthData.get(key);
        },
        
        setMonth(year, month, data) {
          const key = `${year}-${month}`;
          this.monthData.set(key, data);
        },
        
        invalidateMonth(year, month) {
          const key = `${year}-${month}`;
          this.monthData.delete(key);
        }
      };
      
      // RequestAnimationFrame wrapper for smooth updates
      let rafCallbacks = {};
      function scheduleRAF(key, callback) {
        if (rafCallbacks[key]) {
          cancelAnimationFrame(rafCallbacks[key]);
        }
        rafCallbacks[key] = requestAnimationFrame(callback);
      }
    </script>
    
    <style>
      /* ========================================================================
         ‚ö° PERFORMANCE OPTIMIZATIONS - GPU HEAT & LAG FIX
         ========================================================================
         
         ISSUE 1: Glassmorphism (backdrop-filter: blur) causes GPU overload
         - Each blur layer forces GPU to sample, blur, and composite pixels
         - With 35-42 day cells + sidebar + header, this meant 50+ blur layers
         - GPU was rendering this 60 times/second = extreme heat & lag
         
         SOLUTION: Strategic blur reduction
         ‚úÖ REMOVED blur from: .day cells (35-42 instances)
         ‚úÖ REDUCED blur on: modals (40px ‚Üí 20px), tooltips (12px ‚Üí 6px)
         ‚úÖ REMOVED blur from: panel-blur and card-blur (0px)
         ‚úÖ KEPT blur on: main containers only (header, sidebar, modal overlay)
         
         ISSUE 2: Animated floating orbs with filter: blur()
         - Two 400px orbs with blur(40-45px) moving every frame
         - Forces full background repaint 60 times/second
         - Gaussian blur on animated elements = GPU death
         
         SOLUTION: Replace filter blur with radial gradients
         ‚úÖ REMOVED: filter: blur(40px) and filter: blur(45px)
         ‚úÖ REPLACED: With multi-stop radial gradients (naturally soft edges)
         ‚úÖ RESULT: Same visual effect, ZERO blur cost
         
         ISSUE 3: "Lazy" transitions (transition: all)
         - `transition: all` forces browser to watch EVERY CSS property for changes
         - With 42 day cells √ó dozens of properties = thousands of checks/second
         - CPU calculates diff for background, border, width, height, filter, etc.
         - Most properties never change, wasted computation
         
         SOLUTION: Specific property transitions
         ‚úÖ REPLACED: transition: all ‚Üí transition: transform, border-color
         ‚úÖ OPTIMIZED: Only animate properties that actually change
         ‚úÖ RESULT: Browser can optimize rendering pipeline, skip unused checks
         
         ISSUE 4: "Thousands of Dots" problem (DOM node count)
         - Busy calendar: 5 groups/day √ó 4 students/group = 20 dots/day
         - 30 days √ó 20 dots = 600 tiny elements on the page
         - Each dot had box-shadow: 0 2px 4px rgba(0,0,0,0.3)
         - Browser calculates shadow rendering for 600 circles on every scroll/hover
         
         SOLUTION: Remove shadow from indicator dots
         ‚úÖ REMOVED: box-shadow from .indicator-dot (600+ instances)
         ‚úÖ KEPT: Border-radius and color (sufficient for 8px dots)
         ‚úÖ RESULT: Dots too small to need shadows, massive scroll performance boost
         
         ISSUE 5: "Fixed" background gradient on high-res displays
         - Body background: radial-gradient(...) fixed
         - On 4K/Retina displays (8M pixels), painting a complex fixed gradient is expensive
         - Browser repaints or composites weirdly when scrolling content over it
         - Fixed attachment prevents browser from optimizing scroll compositing
         
         SOLUTION: Remove 'fixed' attachment from background
         ‚úÖ REMOVED: 'fixed' from body background gradient
         ‚úÖ SIMPLIFIED: Let gradient scroll naturally (cheaper to composite)
         ‚úÖ RESULT: Eliminates expensive scroll-time repaints on high-DPI screens
         
         ISSUE 6: Event Listener Memory Leak (CRITICAL!)
         - Every day cell got click listener (42 listeners per render)
         - Every indicator dot got 3 listeners (600+ listeners for dots alone)
         - Navigating months didn't remove old listeners before creating new ones
         - After viewing 10 months: 4,200+ ghost listeners consuming RAM
         - Browser keeps track of every deleted element with attached listeners
         
         SOLUTION: Event Delegation Pattern
         ‚úÖ REMOVED: Individual listeners from .day cells (42 per render)
         ‚úÖ REMOVED: Individual listeners from .indicator-dot (600+ per render)
         ‚úÖ ADDED: ONE delegated click listener on .calendar-grid container
         ‚úÖ ADDED: ONE delegated mouseenter/leave listener for all dots
         ‚úÖ RESULT: Fixed memory leak, 99% reduction in event listeners
         
         TOTAL RESULT: ~95% GPU load reduction + optimized CPU + DOM simplified
         + scroll performance on high-res + NO memory leaks ‚Üí cool, smooth, responsive! ‚ùÑÔ∏è‚ö°
         ======================================================================== */
      
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      html {
        background: #05060a;
        color-scheme: dark;
      }

      :root {
        /* ARNOMA Glassmorphism + Neon Prism Hybrid */
        --glass-bg: rgba(255, 255, 255, 0.08);
        --glass-border: rgba(255, 255, 255, 0.2);
        --neon-cyan: #26ffe6;
        --neon-purple: #8a4dff;
        --primary-gradient: linear-gradient(135deg, var(--neon-cyan), var(--neon-purple));
        --secondary-gradient: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        --accent-gradient: linear-gradient(135deg, var(--neon-cyan), var(--neon-purple));
        --dark-bg: radial-gradient(circle at 20% 20%, #0f1120, #05060a 80%);
        --card-bg: var(--glass-bg);
        --card-border: var(--glass-border);
        --text-primary: #e8e8e8;
        --text-secondary: #9a9a9a;
        --text-light: #e8e8e8;
        --text-dim: #9a9a9a;
        --shadow-glow:
          0 0 35px rgba(0, 0, 0, 0.4), 0 0 12px rgba(30, 255, 230, 0.25), inset 0 0 25px rgba(255, 255, 255, 0.05);
        --shadow-soft: 0 4px 16px rgba(0, 0, 0, 0.2);
        --radius: 22px;
        --transition: 0.25s ease;
        --blur: 6px; /* ‚ö° REDUCED FROM 8px FOR BETTER GPU PERFORMANCE */
        
        /* ‚ö° PERFORMANCE: Heavily optimized blur values to prevent GPU overload */
        --panel-blur: 0px; /* REMOVED - was causing heat on repeated elements */
        --card-blur: 0px;  /* REMOVED - not needed for visual clarity */
        --modal-blur: 6px; /* REDUCED - only for modals that appear occasionally */
        --list-blur: 0px;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, 'Inter', 'Poppins', sans-serif;
        /* ‚ö° PERFORMANCE: Removed 'fixed' - on 4K/Retina displays, painting a fixed gradient 
           over 8M pixels causes expensive repaints on scroll. Simple gradient without fixed
           is cheaper to composite. */
        background: radial-gradient(circle at 20% 20%, #0f1120, #05060a 80%);
        min-height: 100vh;
        padding: 40px 20px;
        overflow-x: hidden;
        position: relative;
        color: var(--text-primary);
      }

      /* ‚ö° PERFORMANCE: Floating Neon Orbs - STATIC (Animation disabled for performance) */
      body::before {
        content: '';
        position: fixed;
        top: -120px;
        left: -80px;
        width: 380px;
        height: 380px;
        border-radius: 50%;
        /* ‚ö° Soft edge via radial-gradient instead of filter: blur() */
        background: radial-gradient(
          circle, 
          rgba(38, 255, 230, 0.25) 0%,
          rgba(38, 255, 230, 0.15) 30%,
          rgba(38, 255, 230, 0.05) 60%,
          transparent 100%
        );
        /* REMOVED: animation: float 8s ease-in-out infinite alternate; - causing constant GPU repaints */
        animation: none;
        opacity: 0.6;
        z-index: -1;
      }

      body::after {
        content: '';
        position: fixed;
        bottom: -140px;
        right: -100px;
        width: 400px;
        height: 400px;
        border-radius: 50%;
        /* ‚ö° Soft edge via radial-gradient instead of filter: blur() */
        background: radial-gradient(
          circle,
          rgba(138, 77, 255, 0.20) 0%,
          rgba(138, 77, 255, 0.12) 30%,
          rgba(138, 77, 255, 0.04) 60%,
          transparent 100%
        );
        /* REMOVED: animation: float2 10s ease-in-out infinite alternate; - causing constant GPU repaints */
        animation: none;
        opacity: 0.5;
        z-index: -1;
      }

      @keyframes float {
        from {
          transform: translateY(0);
        }
        to {
          transform: translateY(30px);
        }
      }

      @keyframes float2 {
        from {
          transform: translateY(0);
        }
        to {
          transform: translateY(-30px);
        }
      }

      .container {
        max-width: 1600px;
        margin: 0 auto;
        display: grid;
        grid-template-columns: 1fr;
        gap: 30px;
        transition: grid-template-columns 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .container.sidebar-expanded {
        grid-template-columns: 1fr 320px;
      } /* Sidebar */
      .sidebar {
        background: transparent;
        backdrop-filter: none;
        -webkit-backdrop-filter: none;
        border: none;
        border-radius: var(--radius);
        padding: 20px 15px;
        box-shadow: none;
        max-height: calc(100vh - 80px);
        overflow-y: auto;
        overflow-x: hidden;
        position: fixed;
        top: 20px;
        right: -80px;
        transition: right 0.4s cubic-bezier(0.4, 0, 0.2, 1), 
                    opacity 0.4s cubic-bezier(0.4, 0, 0.2, 1),
                    width 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        width: 60px;
        opacity: 0;
        pointer-events: none;
      }

      .sidebar.expanded {
        background: var(--glass-bg);
        backdrop-filter: blur(var(--blur));
        -webkit-backdrop-filter: blur(var(--blur));
        border: 1px solid var(--glass-border);
        box-shadow: var(--shadow-glow);
        padding: 30px;
        width: 320px;
        right: 20px;
        opacity: 1;
        pointer-events: all;
      }

      .sidebar .sidebar-content {
        opacity: 0;
        visibility: hidden;
        transform: translateX(20px);
      }

      .sidebar.expanded .sidebar-content {
        opacity: 1;
        visibility: visible;
        transform: translateX(0);
      }

      .sidebar-content {
        transition: opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .sidebar-toggle {
        width: 40px;
        height: 40px;
        border-radius: 12px;
        border: 1px solid var(--card-border);
        background: var(--card-bg);
        backdrop-filter: blur(var(--panel-blur));
        color: var(--text-primary);
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1.3rem;
        transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1),
                    background-color 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        margin-bottom: 0;
        position: relative;
        overflow: hidden;
      }

      .sidebar.expanded .sidebar-toggle {
        margin-bottom: 20px;
      }

      .sidebar-toggle::before {
        content: '';
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: var(--primary-gradient);
        transition: left 0.4s ease;
        z-index: -1;
      }

      .sidebar-toggle:hover::before {
        left: 0;
      }

      .sidebar-toggle:hover {
        transform: translateY(-2px);
        box-shadow: 0 0 18px rgba(38, 255, 230, 0.4);
        border-color: var(--neon-cyan);
      }

      .toggle-icon {
        transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .sidebar.expanded .toggle-icon {
        transform: rotate(180deg);
      }

      /* Floating toggle button when sidebar is collapsed */
      .floating-toggle {
        position: fixed;
        bottom: 40px;
        right: 40px;
        width: 50px;
        height: 50px;
        border-radius: 50%;
        border: 1px solid var(--card-border);
        background: var(--card-bg);
        backdrop-filter: blur(var(--panel-blur));
        color: var(--text-primary);
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1.5rem;
        transition: opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1),
                    transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        z-index: 1000;
        opacity: 1;
        pointer-events: all;
      }

      .floating-toggle.hidden {
        opacity: 0;
        pointer-events: none;
        transform: scale(0.8);
      }

      .floating-toggle:hover {
        transform: translateY(-2px) scale(1.05);
        box-shadow: 0 0 25px rgba(38, 255, 230, 0.5);
        border-color: var(--neon-cyan);
      }

      .sidebar::-webkit-scrollbar {
        width: 8px;
      }

      .sidebar::-webkit-scrollbar-track {
        background: rgba(255, 255, 255, 0.05);
        border-radius: 10px;
        margin: 10px 0;
      }

      .sidebar::-webkit-scrollbar-thumb {
        background: var(--primary-gradient);
        border-radius: 10px;
        transition: background 0.3s ease;
      }

      .sidebar::-webkit-scrollbar-thumb:hover {
        background: var(--primary-gradient);
        filter: brightness(1.2);
      }

      .sidebar-section {
        margin-bottom: 30px;
      }

      .sidebar-section:last-child {
        margin-bottom: 0;
      }

      .sidebar-title {
        font-size: 0.85rem;
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 1.5px;
        color: var(--text-secondary);
        margin-bottom: 15px;
        background: var(--primary-gradient);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
      }

      .filter-group {
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .filter-item {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 12px 16px;
        background: rgba(255, 255, 255, 0.03);
        border: 1px solid var(--card-border);
        border-radius: 12px;
        cursor: pointer;
        transition: background-color 0.3s ease, border-color 0.3s ease;
        position: relative;
        overflow: hidden;
      }

      .filter-item::before {
        content: '';
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: var(--primary-gradient);
        opacity: 0.1;
        transition: left 0.3s ease;
      }

      .filter-item:hover::before {
        left: 0;
      }

      .filter-item:hover {
        border-color: var(--neon-cyan);
        transform: translateX(4px);
      }

      .filter-item.active {
        background: rgba(38, 255, 230, 0.15);
        border-color: var(--neon-cyan);
      }

      .filter-label {
        display: flex;
        align-items: center;
        gap: 10px;
        font-size: 0.9rem;
        color: var(--text-primary);
      }

      .filter-checkbox {
        width: 20px;
        height: 20px;
        border-radius: 6px;
        border: 2px solid var(--card-border);
        display: flex;
        align-items: center;
        justify-content: center;
        transition: background-color 0.3s ease, border-color 0.3s ease;
      }

      .filter-item.active .filter-checkbox {
        background: var(--primary-gradient);
        border-color: transparent;
      }

      .filter-checkbox::after {
        content: '‚úì';
        color: white;
        font-size: 0.75rem;
        font-weight: 700;
        opacity: 0;
        transform: scale(0);
        transition: opacity 0.2s ease, transform 0.2s ease;
      }

      .filter-item.active .filter-checkbox::after {
        opacity: 1;
        transform: scale(1);
      }

      .filter-count {
        background: rgba(255, 255, 255, 0.1);
        padding: 4px 10px;
        border-radius: 8px;
        font-size: 0.8rem;
        font-weight: 600;
        color: var(--text-secondary);
      }

      .stats-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 12px;
      }

      .stat-card {
        background: rgba(255, 255, 255, 0.03);
        border: 1px solid var(--card-border);
        border-radius: 12px;
        padding: 16px;
        text-align: center;
        transition: transform 0.3s ease, border-color 0.3s ease;
      }

      .stat-card:hover {
        transform: translateY(-2px);
        border-color: var(--neon-cyan);
      }

      .stat-number {
        font-size: 1.8rem;
        font-weight: 700;
        background: var(--primary-gradient);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        display: block;
        margin-bottom: 4px;
      }

      .stat-label {
        font-size: 0.75rem;
        color: var(--text-secondary);
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      .quick-actions {
        display: flex;
        flex-direction: column;
        gap: 10px;
      }

      .action-btn {
        width: 100%;
        padding: 12px 20px;
        border-radius: 12px;
        border: 1px solid var(--glass-border);
        background: var(--glass-bg);
        color: var(--text-primary);
        font-weight: 600;
        cursor: pointer;
        transition: var(--transition);
        position: relative;
        overflow: hidden;
        font-size: 0.9rem;
      }

      .insight-list {
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .insight-card {
        padding: 12px 14px;
        border-radius: 14px;
        border: 1px solid var(--card-border);
        background: rgba(5, 6, 10, 0.3);
        box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.02);
        display: flex;
        flex-direction: column;
        gap: 6px;
      }

      .insight-title {
        font-size: 0.95rem;
        font-weight: 600;
        color: var(--text-primary);
      }

      .insight-meta {
        display: flex;
        align-items: center;
        justify-content: space-between;
        font-size: 0.8rem;
        color: var(--text-secondary);
        gap: 8px;
      }

      .insight-meta span {
        white-space: nowrap;
      }

      .insight-badge {
        padding: 4px 10px;
        border-radius: 999px;
        font-size: 0.7rem;
        letter-spacing: 0.5px;
        text-transform: uppercase;
        font-weight: 700;
        color: #05060a;
      }

      .insight-badge.upcoming {
        background: var(--primary-gradient);
      }

      .insight-badge.unpaid {
        background: linear-gradient(135deg, #f97316, #ef4444);
        color: #fff;
      }

      .insight-empty {
        padding: 14px;
        border-radius: 12px;
        border: 1px dashed var(--card-border);
        text-align: center;
        font-size: 0.8rem;
        color: var(--text-secondary);
      }

      .action-btn::before {
        content: '';
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: var(--primary-gradient);
        transition: left 0.4s ease;
        z-index: -1;
      }

      .action-btn:hover::before {
        left: 0;
      }

      .action-btn:hover {
        /* ‚ö° PERFORMANCE: Only GPU-accelerated properties */
        transform: translateY(-2px);
        /* Box-shadow removed to prevent layout thrashing */
      }

      .calendar-wrapper {
        display: flex;
        flex-direction: column;
        gap: 30px;
      }

      /* Header */
      .calendar-header {
        background: var(--glass-bg);
        backdrop-filter: blur(var(--blur));
        -webkit-backdrop-filter: blur(var(--blur));
        border: 1px solid var(--glass-border);
        border-radius: var(--radius);
        padding: 18px 30px;
        margin-bottom: 20px;
        box-shadow: var(--shadow-glow);
        display: flex;
        justify-content: space-between;
        align-items: center;
        position: relative;
        overflow: hidden;
      }

      .calendar-header::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 2px;
        background: var(--primary-gradient);
      }

      .month-year {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }

      .month-year h1 {
        font-size: 1.8rem;
        font-weight: 700;
        background: var(--primary-gradient);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        margin: 0;
      }

      .calendar-stats {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 10px;
        margin-top: 4px;
        font-size: 0.8rem;
        color: var(--text-secondary);
        flex-wrap: wrap;
      }

      .calendar-stats .stat-divider {
        color: rgba(255, 255, 255, 0.3);
      }

      .calendar-stats .stat-paid {
        color: #22c55e;
        font-weight: 600;
      }

      .calendar-stats .stat-pending {
        color: #ef4444;
        font-weight: 600;
      }

      .year-badge {
        background: var(--primary-gradient);
        padding: 4px 14px;
        border-radius: 10px;
        font-size: 0.85rem;
        font-weight: 600;
        color: #000;
        box-shadow: 0 0 18px rgba(38, 255, 230, 0.45);
      }

      /* Search Recap Section */
      .search-recap {
        background: rgba(138, 180, 255, 0.08);
        backdrop-filter: blur(var(--blur));
        -webkit-backdrop-filter: blur(var(--blur));
        border: 1px solid rgba(138, 180, 255, 0.25);
        border-radius: 14px;
        padding: 16px 24px;
        margin-bottom: 16px;
        display: none;
        align-items: center;
        gap: 20px;
        box-shadow: 0 4px 12px rgba(138, 180, 255, 0.15);
      }

      .search-recap.active {
        display: flex;
      }

      .search-recap-title {
        font-size: 14px;
        font-weight: 600;
        color: rgba(255, 255, 255, 0.9);
        margin-right: 8px;
      }

      .search-recap-stats {
        display: flex;
        align-items: center;
        gap: 16px;
        flex-wrap: wrap;
      }

      .search-recap-stat {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 6px 12px;
        background: rgba(255, 255, 255, 0.05);
        border-radius: 8px;
        font-size: 13px;
        font-weight: 500;
        transition: all 0.2s ease;
      }

      .search-recap-stat:hover {
        background: rgba(255, 255, 255, 0.1);
        transform: translateY(-1px);
      }

      .search-recap-dot {
        width: 10px;
        height: 10px;
        border-radius: 50%;
        flex-shrink: 0;
      }

      .search-recap-close {
        margin-left: auto;
        background: none;
        border: none;
        color: rgba(255, 255, 255, 0.6);
        font-size: 18px;
        cursor: pointer;
        padding: 4px 8px;
        border-radius: 6px;
        transition: all 0.2s ease;
      }

      .search-recap-close:hover {
        background: rgba(255, 255, 255, 0.1);
        color: rgba(255, 255, 255, 0.9);
      }

      .nav-controls {
        display: flex;
        gap: 12px;
      }

      .nav-btn {
        width: 40px;
        height: 40px;
        border-radius: 10px;
        border: 1px solid var(--glass-border);
        background: var(--glass-bg);
        backdrop-filter: blur(var(--panel-blur));
        color: var(--text-primary);
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1.3rem;
        transition: var(--transition);
        position: relative;
        overflow: hidden;
      }

      .nav-btn::before {
        content: '';
        position: absolute;
        top: 50%;
        left: 50%;
        width: 0;
        height: 0;
        border-radius: 50%;
        background: var(--primary-gradient);
        transition:
          width 0.6s,
          height 0.6s,
          top 0.6s,
          left 0.6s;
        transform: translate(-50%, -50%);
        z-index: -1;
      }

      .nav-btn:hover::before {
        width: 200%;
        height: 200%;
      }

      .nav-btn:hover {
        /* ‚ö° PERFORMANCE: Only GPU-accelerated properties */
        transform: translateY(-2px);
        border-color: var(--neon-cyan);
        /* Box-shadow removed to prevent layout thrashing */
      }

      .nav-btn:active {
        transform: translateY(0);
      }

      .today-btn {
        padding: 10px 20px;
        border-radius: 10px;
        border: none;
        background: var(--primary-gradient);
        color: #000;
        font-weight: 600;
        font-size: 0.9rem;
        cursor: pointer;
        transition: var(--transition);
        position: relative;
        overflow: hidden;
      }

      .today-btn:hover {
        /* ‚ö° PERFORMANCE: Only GPU-accelerated properties */
        transform: translateY(-2px);
        /* Box-shadow removed to prevent layout thrashing */
      }

      /* Elite Refresh Button */
      .refresh-btn {
        position: relative;
        width: 44px;
        height: 44px;
        border-radius: 12px;
        border: 1px solid rgba(38, 255, 230, 0.3);
        background: linear-gradient(135deg, rgba(38, 255, 230, 0.15), rgba(138, 77, 255, 0.15));
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1),
                    border-color 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        margin-left: 12px;
        overflow: hidden;
      }

      .refresh-btn::before {
        content: '';
        position: absolute;
        inset: 0;
        background: var(--primary-gradient);
        opacity: 0;
        transition: opacity 0.3s ease;
      }

      .refresh-btn:hover::before {
        opacity: 0.2;
      }

      .refresh-btn:hover {
        border-color: rgba(38, 255, 230, 0.6);
        transform: translateY(-2px);
        box-shadow: 0 8px 20px rgba(38, 255, 230, 0.3);
      }

      .refresh-btn:active {
        transform: translateY(0);
      }

      .refresh-btn.loading {
        pointer-events: none;
      }

      .refresh-btn.loading .refresh-icon {
        animation: spin 0.8s linear infinite;
      }

      .refresh-icon {
        width: 20px;
        height: 20px;
        fill: none;
        stroke: #26ffe6;
        stroke-width: 2;
        stroke-linecap: round;
        stroke-linejoin: round;
        transition: filter 0.3s ease;
        position: relative;
        z-index: 1;
      }

      .refresh-btn:hover .refresh-icon {
        stroke: #26ffe6;
        filter: drop-shadow(0 0 8px rgba(38, 255, 230, 0.6));
      }

      @keyframes spin {
        from {
          transform: rotate(0deg);
        }
        to {
          transform: rotate(360deg);
        }
      }

      /* Notification Bell */
      .notification-bell {
        position: relative;
        width: 44px;
        height: 44px;
        border-radius: 12px;
        border: 1px solid var(--glass-border);
        background: var(--glass-bg);
        color: var(--text-primary);
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1.3rem;
        transition: var(--transition);
        margin-left: 12px;
      }

      .notification-bell svg {
        width: 20px;
        height: 20px;
        fill: none;
        stroke: currentColor;
        stroke-width: 2;
        stroke-linecap: round;
        stroke-linejoin: round;
        transition: var(--transition);
      }

      .notification-bell:hover {
        background: rgba(255, 255, 255, 0.1);
        border-color: rgba(138,180,255,0.3);
        transform: translateY(-2px);
      }

      .notification-bell:active {
        transform: translateY(0);
      }

      .notification-bell.has-notifications {
        border-color: #22c55e;
        background: rgba(34, 197, 94, 0.1);
        /* Reduced frequency from 2s to 4s to reduce GPU load */
        animation: bellPulse 4s ease-in-out infinite;
      }

      .notification-bell.has-notifications svg {
        stroke: #22c55e;
      }

      @keyframes bellPulse {
        0%, 100% {
          box-shadow: 0 0 0 0 rgba(34, 197, 94, 0.4);
        }
        50% {
          box-shadow: 0 0 0 8px rgba(34, 197, 94, 0);
        }
      }

      .notification-badge {
        position: absolute;
        top: -6px;
        right: -6px;
        min-width: 20px;
        height: 20px;
        border-radius: 10px;
        background: linear-gradient(135deg, #22c55e 0%, #10b981 100%);
        color: #000;
        font-size: 0.7rem;
        font-weight: 700;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 0 6px;
        box-shadow: 0 2px 8px rgba(34, 197, 94, 0.4);
      }

      /* Calendar Grid */
      .calendar-grid {
        background: var(--glass-bg);
        backdrop-filter: blur(var(--blur));
        -webkit-backdrop-filter: blur(var(--blur));
        border: 1px solid var(--glass-border);
        border-radius: var(--radius);
        padding: 30px;
        box-shadow: var(--shadow-glow);
        position: relative;
        overflow: visible;
        animation: fadeIn 0.6s ease-out;
      }

      .calendar-grid::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 2px;
        background: var(--accent-gradient);
      }

      /* Weekday Headers */
      .weekdays {
        display: grid;
        grid-template-columns: repeat(7, 1fr);
        gap: 8px;
        margin-bottom: 15px;
      }

      .weekday {
        text-align: center;
        font-weight: 600;
        font-size: 0.85rem;
        color: var(--text-secondary);
        padding: 12px 0;
        text-transform: uppercase;
        letter-spacing: 1px;
        background: var(--primary-gradient);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
      }

      /* Days Grid */
      .days {
        display: grid;
        grid-template-columns: repeat(7, 1fr);
        gap: 8px;
        overflow: visible;
      }

      .day {
        height: 140px;
        border-radius: 14px;
        border: 1px solid var(--glass-border);
        background: var(--glass-bg);
        /* ‚ö° PERFORMANCE: Removed backdrop-filter to reduce GPU load on 35-42 day cells */
        display: flex;
        flex-direction: column;
        align-items: flex-start;
        justify-content: flex-start;
        padding: 8px;
        cursor: pointer;
        position: relative;
        overflow: visible;
        transition: transform 0.3s cubic-bezier(0.4, 0.2, 1), border-color 0.3s ease;
        animation: fadeIn 0.4s ease-out backwards;
        /* ‚ö° PERFORMANCE: will-change hint for GPU acceleration */
        will-change: transform;
      }

      .day::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: var(--primary-gradient);
        opacity: 0;
        transition: opacity 0.3s ease;
        z-index: 0;
      }

      .day:hover::before {
        opacity: 0.1;
      }

      .day:hover {
        /* ‚ö° PERFORMANCE: Only GPU-accelerated properties (no box-shadow changes) */
        transform: translateY(-4px) scale(1.02);
        border-color: var(--neon-cyan);
        /* Box-shadow removed to prevent layout recalculation on hover */
      }

      .day-header {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        width: 100%;
        z-index: 1;
        position: relative;
      }

      .day-number {
        font-size: 1.1rem;
        font-weight: 600;
        color: var(--text-primary);
        position: relative;
      }

      .day-payment-summary {
        font-size: 0.7rem;
        font-weight: 600;
        display: flex;
        flex-direction: row;
        align-items: center;
        gap: 4px;
        z-index: 1;
        white-space: nowrap;
      }

      .day-payment-paid {
        color: #22c55e;
      }

      .day-payment-unpaid {
        color: #ef4444;
      }

      .day-payment-divider {
        color: var(--text-secondary);
      }

      .day-number::after {
        display: none;
      }

      .day.today .day-number::after {
        background: white;
        opacity: 0.8;
        box-shadow: 0 0 8px rgba(255, 255, 255, 0.6);
      }

      .day.has-class .day-number::after,
      .day.has-payment .day-number::after,
      .day.has-absence .day-number::after {
        opacity: 0.6;
      }

      .day-indicator {
        display: flex;
        flex-direction: column;
        gap: 4px;
        z-index: 2;
        width: 100%;
        flex: 1;
        justify-content: center;
        align-items: flex-start;
        overflow: visible;
      }

      .group-dots-row {
        display: flex;
        gap: 3px;
        flex-wrap: wrap;
        align-items: center;
        padding: 2px 0;
        border-bottom: 1px solid rgba(255, 255, 255, 0.08);
        width: 100%;
        font-size: 0.65rem;
        overflow: visible;
        position: relative;
      }

      .group-dots-row:last-child {
        border-bottom: none;
      }

      .group-label {
        font-size: 0.65rem;
        font-weight: 600;
        color: var(--neon-cyan);
        margin-right: 4px;
        min-width: 15px;
        position: relative;
      }

      /* Scratch line through canceled group labels - diagonal like dots */
      .group-label.canceled::after,
      .group-label.skipped::after {
        content: '';
        position: absolute;
        top: 80%;
        left: 0%;
        width: 70%;
        height: 1.5px;
        background: rgba(251, 191, 36, 0.9); /* Yellow scratch */
        transform: rotate(-45deg);
        transform-origin: left center;
        pointer-events: none;
      }

      .indicator-dot {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        transition: all 0.2s ease;
        cursor: pointer;
        /* ‚ö° PERFORMANCE: box-shadow removed - too expensive for 600+ tiny dots */
        /* With 30 days √ó 20 dots = 600 elements, shadow rendering kills scroll performance */
        position: relative;
        /* ‚ö° PERFORMANCE: Pre-allocate GPU layer to prevent layout thrashing */
        will-change: transform;
      }

      .indicator-dot:hover {
        /* ‚ö° PERFORMANCE: Only transform (GPU-accelerated), no box-shadow changes */
        transform: scale(1.5);
        /* Box-shadow removed from hover to prevent layout recalculation */
      }

      /* Highlighted dot when search matches - subtle glow */
      .indicator-dot.search-highlight {
        transform: scale(1.4);
        box-shadow: 0 0 8px rgba(255, 255, 255, 0.3);
        z-index: 10;
        opacity: 1;
      }

      /* Tooltip for dots - using fixed position to escape stacking context */
      .indicator-dot[data-tooltip] {
        position: relative;
      }

      /* ========================================
         BRAND NEW STUDENT DOT POPUP MODAL
         Modern Card-Based Design with ARNOMA Styling
         ======================================== */
      
      #studentDotModal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.92);
        backdrop-filter: blur(6px); /* ‚ö° REDUCED from 12px for performance */
        -webkit-backdrop-filter: blur(6px);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 999999;
        opacity: 0;
        transition: opacity 0.25s ease-out;
      }

      #studentDotModal.active {
        display: flex;
        opacity: 1;
      }

      .dot-modal-container {
        background: linear-gradient(135deg, 
          rgba(15, 23, 42, 0.98) 0%, 
          rgba(30, 41, 59, 0.96) 100%);
        backdrop-filter: blur(20px);
        -webkit-backdrop-filter: blur(20px);
        border: 1px solid rgba(38, 255, 230, 0.25);
        border-radius: 24px;
        max-width: 480px;
        width: 94%;
        max-height: 90vh;
        overflow: hidden;
        box-shadow: 
          0 0 80px rgba(38, 255, 230, 0.2),
          0 25px 100px rgba(0, 0, 0, 0.7),
          inset 0 1px 0 rgba(255, 255, 255, 0.15);
        transform: scale(0.9) translateY(20px);
        transition: transform 0.35s cubic-bezier(0.34, 1.56, 0.64, 1);
        position: relative;
        pointer-events: auto;
        display: flex;
        flex-direction: column;
      }

      #studentDotModal.active .dot-modal-container {
        transform: scale(1) translateY(0);
      }

      /* Gradient accent bar */
      .dot-modal-accent {
        height: 5px;
        background: var(--primary-gradient);
        box-shadow: 0 0 30px rgba(38, 255, 230, 0.6);
        flex-shrink: 0;
      }

      /* Header with large status badge */
      .dot-modal-header {
        padding: 24px 24px 20px;
        background: linear-gradient(to bottom, rgba(255, 255, 255, 0.04), transparent);
        position: relative;
        flex-shrink: 0;
        border-bottom: 1px solid rgba(255, 255, 255, 0.05);
      }

      .dot-modal-close {
        position: absolute;
        top: 16px;
        right: 16px;
        width: 36px;
        height: 36px;
        border-radius: 10px;
        background: rgba(239, 68, 68, 0.1);
        border: 1px solid rgba(239, 68, 68, 0.2);
        color: rgba(239, 68, 68, 0.8);
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 20px;
        font-weight: 300;
        transition: all 0.2s ease;
        z-index: 10;
      }

      .dot-modal-close:hover {
        background: rgba(239, 68, 68, 0.2);
        border-color: rgba(239, 68, 68, 0.5);
        color: #ef4444;
        transform: scale(1.1) rotate(90deg);
        box-shadow: 0 0 20px rgba(239, 68, 68, 0.3);
      }

      /* Navigation arrows for cycling through dots */
      .dot-modal-nav-arrows {
        display: flex;
        align-items: center;
        gap: 12px;
        margin-bottom: 16px;
        justify-content: center;
        padding: 8px;
        background: rgba(255, 255, 255, 0.02);
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.05);
      }

      .dot-nav-arrow {
        width: 36px;
        height: 36px;
        border-radius: 10px;
        background: rgba(103, 126, 234, 0.1);
        border: 1px solid rgba(103, 126, 234, 0.2);
        color: #667eea;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 18px;
        font-weight: 700;
        transition: all 0.2s ease;
      }

      .dot-nav-arrow:not(.disabled):hover {
        background: rgba(103, 126, 234, 0.25);
        border-color: rgba(103, 126, 234, 0.5);
        color: #8b9dff;
        transform: scale(1.1);
        box-shadow: 0 4px 12px rgba(103, 126, 234, 0.3);
      }

      .dot-nav-arrow.disabled {
        opacity: 0.2;
        cursor: not-allowed;
        pointer-events: none;
        background: rgba(255, 255, 255, 0.02);
        border-color: rgba(255, 255, 255, 0.05);
        color: rgba(255, 255, 255, 0.3);
      }

      .dot-nav-position {
        font-size: 0.8rem;
        color: rgba(255, 255, 255, 0.7);
        font-weight: 700;
        letter-spacing: 1px;
        min-width: 70px;
        text-align: center;
        background: linear-gradient(135deg, #667eea, #764ba2);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
      }

      .dot-modal-status-badge {
        display: inline-flex;
        align-items: center;
        gap: 10px;
        padding: 10px 18px;
        border-radius: 12px;
        font-size: 0.8rem;
        font-weight: 800;
        text-transform: uppercase;
        letter-spacing: 1px;
        margin-bottom: 14px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      }

      .dot-modal-status-badge.paid {
        background: linear-gradient(135deg, rgba(34, 197, 94, 0.25), rgba(34, 197, 94, 0.15));
        border: 1.5px solid rgba(34, 197, 94, 0.5);
        color: #34d399;
      }

      .dot-modal-status-badge.unpaid {
        background: linear-gradient(135deg, rgba(239, 68, 68, 0.25), rgba(239, 68, 68, 0.15));
        border: 1.5px solid rgba(239, 68, 68, 0.5);
        color: #f87171;
      }

      .dot-modal-status-badge.absent {
        background: linear-gradient(135deg, rgba(255, 255, 255, 0.2), rgba(255, 255, 255, 0.1));
        border: 1.5px solid rgba(255, 255, 255, 0.4);
        color: #fff;
      }

      .dot-modal-status-badge.credit {
        background: linear-gradient(135deg, rgba(14, 165, 233, 0.25), rgba(14, 165, 233, 0.15));
        border: 1.5px solid rgba(14, 165, 233, 0.5);
        color: #38bdf8;
      }

      .dot-modal-status-badge.upcoming {
        background: linear-gradient(135deg, rgba(156, 163, 175, 0.25), rgba(156, 163, 175, 0.15));
        border: 1.5px solid rgba(156, 163, 175, 0.5);
        color: #d1d5db;
      }

      .dot-modal-student-name {
        font-size: 1.75rem;
        font-weight: 900;
        background: var(--primary-gradient);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        margin: 0 0 6px 0;
        line-height: 1.2;
        letter-spacing: -0.5px;
      }

      .dot-modal-group {
        font-size: 0.9rem;
        color: rgba(255, 255, 255, 0.6);
        font-weight: 600;
        letter-spacing: 0.3px;
      }

      /* Info Cards Grid */
      .dot-modal-body {
        padding: 0 24px 24px;
        overflow-y: auto;
        overflow-x: hidden;
        flex: 1;
        pointer-events: auto;
      }

      .dot-info-grid {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 10px;
        margin-bottom: 20px;
      }

      .dot-info-card {
        background: rgba(255, 255, 255, 0.04);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 14px;
        padding: 14px 16px;
        transition: all 0.2s ease;
      }

      .dot-info-card:hover {
        background: rgba(255, 255, 255, 0.06);
        border-color: rgba(38, 255, 230, 0.3);
        transform: translateY(-2px);
        box-shadow: 0 4px 16px rgba(38, 255, 230, 0.1);
      }

      .dot-info-card.full-width {
        grid-column: span 2;
      }

      .dot-info-card.clickable-balance {
        cursor: pointer;
        position: relative;
        border-color: rgba(16, 185, 129, 0.2);
        background: rgba(16, 185, 129, 0.05);
      }

      .dot-info-card.clickable-balance::after {
        content: '';
        position: absolute;
        inset: 0;
        border-radius: 14px;
        background: linear-gradient(135deg, rgba(16, 185, 129, 0.2), rgba(5, 150, 105, 0.1));
        opacity: 0;
        transition: opacity 0.2s ease;
      }

      .dot-info-card.clickable-balance:hover::after {
        opacity: 1;
      }

      .dot-info-card.clickable-balance:hover {
        border-color: rgba(16, 185, 129, 0.5);
        box-shadow: 0 4px 20px rgba(16, 185, 129, 0.3);
        transform: translateY(-3px);
      }

      .dot-info-label {
        font-size: 0.7rem;
        color: rgba(255, 255, 255, 0.5);
        text-transform: uppercase;
        letter-spacing: 0.8px;
        font-weight: 700;
        margin-bottom: 6px;
      }

      .dot-info-value {
        font-size: 1.2rem;
        font-weight: 800;
        color: var(--text-primary);
        letter-spacing: -0.3px;
      }

      .dot-info-value.highlight-green {
        color: #34d399;
        text-shadow: 0 0 15px rgba(52, 211, 153, 0.4);
      }

      .dot-info-value.highlight-red {
        color: #f87171;
        text-shadow: 0 0 15px rgba(248, 113, 113, 0.4);
      }

      .dot-info-value.highlight-cyan {
        color: #38bdf8;
        text-shadow: 0 0 15px rgba(56, 189, 248, 0.4);
      }

      /* Actions Section */
      .dot-actions-section {
        margin-top: 20px;
        pointer-events: auto;
      }

      .dot-actions-title {
        font-size: 0.75rem;
        color: rgba(255, 255, 255, 0.6);
        text-transform: uppercase;
        letter-spacing: 1px;
        font-weight: 800;
        margin-bottom: 12px;
        padding-left: 2px;
      }

      .dot-actions-grid {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 8px;
        pointer-events: auto;
      }

      .dot-action-btn {
        padding: 12px 14px;
        border-radius: 12px;
        border: 1.5px solid rgba(255, 255, 255, 0.15);
        background: rgba(255, 255, 255, 0.05);
        backdrop-filter: blur(10px);
        color: var(--text-primary);
        cursor: pointer;
        font-weight: 700;
        font-size: 0.8rem;
        transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
        position: relative;
        overflow: hidden;
        pointer-events: auto;
      }

      .dot-action-btn::before {
        content: '';
        position: absolute;
        inset: 0;
        background: var(--primary-gradient);
        opacity: 0;
        transition: opacity 0.2s ease;
      }

      .dot-action-btn:hover::before {
        opacity: 0.1;
      }

      .dot-action-btn:hover {
        border-color: rgba(38, 255, 230, 0.5);
        transform: translateY(-3px);
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3),
                    0 0 20px rgba(38, 255, 230, 0.2);
      }

      .dot-action-btn:active {
        transform: translateY(-1px);
      }

      .dot-action-btn .btn-icon {
        font-size: 1.1rem;
        position: relative;
        z-index: 1;
      }

      .dot-action-btn .btn-text {
        position: relative;
        z-index: 1;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        letter-spacing: 0.3px;
      }

      /* Variant Styles */
      .dot-action-btn.primary {
        background: linear-gradient(135deg, rgba(59, 130, 246, 0.2), rgba(59, 130, 246, 0.1));
        border-color: rgba(59, 130, 246, 0.4);
        color: #60a5fa;
      }

      .dot-action-btn.primary:hover {
        background: linear-gradient(135deg, #3b82f6, #2563eb);
        color: #fff;
        border-color: #3b82f6;
        box-shadow: 0 6px 20px rgba(59, 130, 246, 0.4);
      }

      .dot-action-btn.success {
        background: linear-gradient(135deg, rgba(34, 197, 94, 0.2), rgba(34, 197, 94, 0.1));
        border-color: rgba(34, 197, 94, 0.4);
        color: #34d399;
      }

      .dot-action-btn.success:hover {
        background: linear-gradient(135deg, #22c55e, #16a34a);
        color: #fff;
        border-color: #22c55e;
        box-shadow: 0 6px 20px rgba(34, 197, 94, 0.4);
      }

      .dot-action-btn.danger {
        background: linear-gradient(135deg, rgba(239, 68, 68, 0.2), rgba(239, 68, 68, 0.1));
        border-color: rgba(239, 68, 68, 0.4);
        color: #f87171;
      }

      .dot-action-btn.danger:hover {
        background: linear-gradient(135deg, #ef4444, #dc2626);
        color: #fff;
        border-color: #ef4444;
        box-shadow: 0 6px 20px rgba(239, 68, 68, 0.4);
      }

      .dot-action-btn.warning {
        background: linear-gradient(135deg, rgba(251, 191, 36, 0.2), rgba(251, 191, 36, 0.1));
        border-color: rgba(251, 191, 36, 0.4);
        color: #fcd34d;
      }

      .dot-action-btn.warning:hover {
        background: linear-gradient(135deg, #fbbf24, #f59e0b);
        color: #000;
        border-color: #fbbf24;
        box-shadow: 0 6px 20px rgba(251, 191, 36, 0.4);
      }

      .dot-action-btn.purple {
        background: linear-gradient(135deg, rgba(168, 85, 247, 0.2), rgba(168, 85, 247, 0.1));
        border-color: rgba(168, 85, 247, 0.4);
        color: #c084fc;
      }

      .dot-action-btn.purple:hover {
        background: linear-gradient(135deg, #a855f7, #9333ea);
        color: #fff;
        border-color: #a855f7;
        box-shadow: 0 6px 20px rgba(168, 85, 247, 0.4);
      }

      .dot-action-btn.wide {
        grid-column: span 2;
      }

      /* ========================================
         HOVER TOOLTIP FOR STUDENT DOTS
         Shows student name on hover using real DOM element
         ======================================== */
      
      .student-dot {
        position: relative;
        z-index: 1;
      }

      /* Hover tooltip container - positioned fixed to escape stacking context */
      .hover-tooltip {
        position: fixed;
        background: rgba(10, 18, 35, 0.98);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        color: #fff;
        padding: 10px 16px;
        border-radius: 9px;
        font-size: 0.95rem;
        font-weight: 600;
        white-space: nowrap;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.08s ease-out;
        z-index: 9999999;
        border: 1px solid rgba(38, 255, 230, 0.5);
        box-shadow: 
          0 6px 16px rgba(0, 0, 0, 0.55),
          0 0 26px rgba(38, 255, 230, 0.35);
        max-width: 320px;
        text-overflow: ellipsis;
        overflow: hidden;
      }

      .hover-tooltip.visible {
        opacity: 1;
      }

      .hover-tooltip::after {
        content: '';
        position: absolute;
        bottom: -10px;
        left: 50%;
        transform: translateX(-50%);
        border: 8px solid transparent;
        border-top-color: rgba(10, 18, 35, 0.98);
      }

      .hover-tooltip.below::after {
        bottom: auto;
        top: -10px;
        border-top-color: transparent;
        border-bottom-color: rgba(10, 18, 35, 0.98);
      }

      .dot-class {
        background: #94a3b8; /* Gray - Class Scheduled */
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
      }

      .dot-payment {
        background: #22c55e; /* Green - Paid */
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
      }

      .dot-credit {
        background: #ffeb3b; /* Bright vivid yellow - Paid via credit balance */
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
      }

      .dot-paid {
        background: #00ff41; /* Neon bright green - Paid */
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
      }

      .dot-absent {
        background: #ffffff; /* White - Absent */
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
      }

      .dot-unpaid {
        background: #ff1744; /* Bright neon red - Unpaid */
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
      }

      .dot-partial {
        background: #ff6d00; /* Bright vivid orange - Partial payment */
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        border: 1px solid #ff9100;
      }

      .dot-pending {
        background: #2979ff; /* Bright vivid blue - Future class with balance */
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
      }

      .dot-future {
        background: rgba(255, 255, 255, 0.15); /* Very light transparent - Future unpaid */
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
      }

      .dot-canceled {
        background: rgba(150, 150, 150, 0.4); /* Gray for canceled */
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        position: relative;
        border: 1px solid rgba(200, 200, 200, 0.5);
      }

      /* Scratch line for canceled classes */
      .dot-canceled::after {
        content: '';
        position: absolute;
        top: 50%;
        left: -2px;
        right: -2px;
        height: 1.5px;
        background: rgba(255, 255, 255, 0.9);
        transform: translateY(-50%) rotate(-45deg);
        pointer-events: none;
      }

      .dot-skipped {
        background: rgba(251, 146, 60, 0.6); /* Orange for skipped */
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        border: 1px solid rgba(251, 146, 60, 0.8);
      }

      .dot-fuchsia {
        background: linear-gradient(135deg, #ff00ff 0%, #ff66ff 100%); /* Fuchsia gradient - Misallocated payment */
        box-shadow: 0 0 8px rgba(255, 0, 255, 0.6), 0 2px 4px rgba(0, 0, 0, 0.3);
        border: 1px solid #ff00ff;
        cursor: pointer;
        animation: pulseFuchsia 2s ease-in-out infinite;
      }

      @keyframes pulseFuchsia {
        0%, 100% {
          box-shadow: 0 0 8px rgba(255, 0, 255, 0.6), 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        50% {
          box-shadow: 0 0 16px rgba(255, 0, 255, 0.9), 0 2px 8px rgba(255, 0, 255, 0.5);
        }
      }

      .dot-fuchsia:hover {
        transform: scale(1.2);
        box-shadow: 0 0 20px rgba(255, 0, 255, 1), 0 4px 12px rgba(255, 0, 255, 0.6);
      }

      .fuchsia-row {
        border-top: 1px solid rgba(255, 0, 255, 0.3);
        margin-top: 4px;
        padding-top: 4px;
      }

      .fuchsia-label {
        color: #ff00ff !important;
        font-weight: bold;
        animation: pulseFuchsiaLabel 2s ease-in-out infinite;
      }

      @keyframes pulseFuchsiaLabel {
        0%, 100% {
          opacity: 0.8;
        }
        50% {
          opacity: 1;
        }
      }

      /* Special Day States */
      .day.other-month {
        opacity: 0.3;
      }

      .day.today {
        background: linear-gradient(135deg, rgba(38, 255, 230, 0.15) 0%, rgba(138, 77, 255, 0.15) 100%);
        border-color: rgba(38, 255, 230, 0.6);
        box-shadow:
          0 0 25px rgba(38, 255, 230, 0.4),
          0 0 40px rgba(138, 77, 255, 0.3),
          inset 0 0 20px rgba(38, 255, 230, 0.1);
        transform: scale(1.02);
      }

      .day.today .day-number {
        color: #ffffff;
        font-weight: 800;
        font-size: 1.3rem;
        text-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
      }

      .day.today::before {
        opacity: 0;
      }

      .day.has-class {
        border-color: rgba(38, 255, 230, 0.4);
        background: rgba(38, 255, 230, 0.05);
      }

      .day.has-payment {
        border-color: rgba(16, 185, 129, 0.4);
        background: rgba(16, 185, 129, 0.05);
      }

      .day.skipped {
        background: rgba(100, 100, 100, 0.1);
        border-color: rgba(100, 100, 100, 0.3);
      }

      /* Legend */
      .legend {
        display: flex;
        justify-content: center;
        gap: 30px;
        margin-top: 30px;
        padding: 25px;
        background: var(--glass-bg);
        backdrop-filter: blur(var(--blur));
        border: 1px solid var(--glass-border);
        border-radius: var(--radius);
        flex-wrap: wrap;
        box-shadow: var(--shadow-glow);
      }

      .legend-item {
        display: flex;
        align-items: center;
        gap: 10px;
        font-size: 0.9rem;
        color: var(--text-secondary);
      }

      .legend-dot {
        width: 12px;
        height: 12px;
        border-radius: 50%;
      }

      /* Modal Styles */
      .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.85);
        backdrop-filter: blur(var(--panel-blur));
        -webkit-backdrop-filter: blur(var(--panel-blur));
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 1000;
        animation: fadeIn 0.2s ease-out forwards;
      }

      .modal-overlay.active {
        display: flex;
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
        }
        to {
          opacity: 1;
        }
      }

      .modal {
        background: var(--glass-bg);
        backdrop-filter: blur(var(--modal-blur));
        -webkit-backdrop-filter: blur(var(--modal-blur));
        border: 1px solid var(--glass-border);
        border-radius: var(--radius);
        max-width: 600px;
        width: 90%;
        max-height: 80vh;
        overflow: hidden;
        box-shadow: var(--shadow-glow);
        transform: scale(0.9) translateY(20px);
        transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        position: relative;
      }

      .modal-overlay.active .modal {
        transform: scale(1) translateY(0);
      }

      .modal::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 3px;
        background: var(--primary-gradient);
      }

      .modal-header {
        padding: 30px 30px 20px;
        border-bottom: 1px solid var(--card-border);
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .modal-title {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      .modal-title h2 {
        font-size: 1.8rem;
        font-weight: 700;
        background: var(--primary-gradient);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        margin: 0;
      }

      .modal-subtitle {
        font-size: 0.9rem;
        color: var(--text-secondary);
      }

      .modal-close {
        width: 40px;
        height: 40px;
        border-radius: 12px;
        border: 1px solid var(--glass-border);
        background: var(--glass-bg);
        color: var(--text-primary);
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1.5rem;
        transition: var(--transition);
        flex-shrink: 0;
      }

      .modal-close:hover {
        background: var(--primary-gradient);
        border-color: transparent;
        color: #000;
        transform: rotate(90deg);
      }

      .modal-body {
        padding: 0;
        max-height: calc(80vh - 180px);
        overflow-y: auto;
        overflow-x: hidden;
        display: flex;
        flex-direction: column;
      }

      .modal-body::-webkit-scrollbar {
        width: 8px;
      }

      .modal-body::-webkit-scrollbar-track {
        background: rgba(255, 255, 255, 0.05);
        border-radius: 10px;
      }

      .modal-body::-webkit-scrollbar-thumb {
        background: var(--primary-gradient);
        border-radius: 10px;
      }

      /* Tabs */
      .modal-tabs {
        display: flex;
        gap: 8px;
        padding: 20px 30px 0 30px;
        border-bottom: 2px solid rgba(255, 255, 255, 0.1);
        overflow-x: auto;
        flex-shrink: 0;
      }

      .modal-tabs::-webkit-scrollbar {
        height: 4px;
      }

      .modal-tabs::-webkit-scrollbar-track {
        background: rgba(255, 255, 255, 0.05);
      }

      .modal-tabs::-webkit-scrollbar-thumb {
        background: rgba(138,180,255,0.3);
        border-radius: 2px;
      }

      .modal-tab {
        padding: 12px 20px;
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 12px 12px 0 0;
        color: rgba(255, 255, 255, 0.6);
        cursor: pointer;
        transition: background-color 0.3s ease, color 0.3s ease, 
                    border-color 0.3s ease;
        font-size: 14px;
        font-weight: 500;
        white-space: nowrap;
        position: relative;
      }

      .modal-tab:hover {
        background: rgba(255, 255, 255, 0.08);
        color: rgba(255, 255, 255, 0.8);
        border-color: rgba(138,180,255,0.3);
      }

      .modal-tab.active {
        background: linear-gradient(135deg, rgba(138,180,255,0.15) 0%, rgba(138,180,255,0.08) 100%);
        border-color: rgba(138,180,255,0.4);
        color: #fff;
      }

      .modal-tab.active::after {
        content: '';
        position: absolute;
        bottom: -2px;
        left: 0;
        right: 0;
        height: 2px;
        background: var(--primary-gradient);
      }

      .modal-tab-content {
        padding: 30px;
        overflow-y: auto;
        flex: 1;
      }

      .modal-tab-content::-webkit-scrollbar {
        width: 8px;
      }

      .modal-tab-content::-webkit-scrollbar-track {
        background: rgba(255, 255, 255, 0.05);
        border-radius: 10px;
      }

      .modal-tab-content::-webkit-scrollbar-thumb {
        background: var(--primary-gradient);
        border-radius: 10px;
      }

      .tab-panel {
        display: none;
      }

      .tab-panel.active {
        display: block;
      }

      .group-section {
        margin-bottom: 25px;
      }

      .group-section:last-child {
        margin-bottom: 0;
      }

      .group-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        margin-bottom: 15px;
        padding: 16px 20px;
        background: linear-gradient(135deg, rgba(138,180,255,0.12) 0%, rgba(138,180,255,0.06) 100%);
        border: 1px solid rgba(138,180,255,0.25);
        border-radius: 16px;
      }

      .group-header-content {
        display: flex;
        align-items: center;
        gap: 12px;
        flex: 1;
      }

      .group-header-actions {
        margin-left: 12px;
      }

      .group-icon {
        width: 40px;
        height: 40px;
        border-radius: 12px;
        background: var(--primary-gradient);
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1.2rem;
        color: #000;
      }

      .group-info h3 {
        font-size: 1.1rem;
        color: var(--text-primary);
        margin: 0 0 4px;
      }

      .group-time {
        font-size: 0.85rem;
        color: var(--text-secondary);
      }

      .students-list {
        display: flex;
        flex-direction: column;
        gap: 10px;
      }

      .student-card {
        background: rgba(255, 255, 255, 0.03);
        border: 1px solid var(--card-border);
        border-radius: 14px;
        padding: 16px 20px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        transition: background-color 0.3s ease, border-color 0.3s ease, 
                    transform 0.3s ease;
        position: relative;
        overflow: hidden;
        gap: 10px;
      }

      .student-card::before {
        content: '';
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: var(--primary-gradient);
        opacity: 0.1;
        transition: left 0.3s ease;
      }

      .student-card:hover::before {
        left: 0;
      }

      .student-card:hover {
        border-color: var(--neon-cyan);
        transform: translateX(4px);
      }

      .student-info {
        display: flex;
        align-items: center;
        gap: 15px;
        flex: 1;
        min-width: 0;
      }

      .student-avatar {
        width: 45px;
        height: 45px;
        border-radius: 12px;
        background: var(--primary-gradient);
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1.1rem;
        font-weight: 700;
        color: #000;
      }

      .student-details {
        display: flex;
        flex-direction: column;
        flex: 1;
        min-width: 0;
      }

      .student-name {
        font-size: 1rem;
        font-weight: 600;
        color: var(--text-primary);
        margin-bottom: 4px;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        max-width: 100%;
      }

      .student-status {
        font-size: 0.8rem;
        color: var(--text-secondary);
      }

      .student-badges {
        display: flex;
        gap: 8px;
        align-items: center;
        flex-wrap: wrap;
      }

      .student-actions {
        display: flex;
        gap: 6px;
        margin-left: auto;
        flex-shrink: 0;
        align-items: center;
      }

      .action-icon-btn {
        min-width: 34px;
        height: 34px;
        padding: 0 10px;
        border-radius: 8px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        background: rgba(255, 255, 255, 0.03);
        backdrop-filter: blur(10px);
        color: var(--text-primary);
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 6px;
        font-size: 0.85rem;
        font-weight: 500;
        transition: all 0.2s ease;
        position: relative;
        overflow: hidden;
        white-space: nowrap;
      }

      .action-icon-btn .btn-icon {
        font-size: 1rem;
        flex-shrink: 0;
      }

      .action-icon-btn .btn-label {
        font-size: 0.8rem;
        display: none;
      }

      .action-icon-btn:hover .btn-label {
        display: inline;
      }

      .action-icon-btn:hover {
        transform: translateY(-1px);
        border-color: rgba(255, 255, 255, 0.2);
        background: rgba(255, 255, 255, 0.08);
      }

      /* Pause/Resume Button */
      .action-icon-btn.pause {
        border-color: rgba(245, 158, 11, 0.3);
        background: rgba(245, 158, 11, 0.08);
      }

      .action-icon-btn.pause:hover {
        border-color: rgba(245, 158, 11, 0.5);
        background: rgba(245, 158, 11, 0.15);
        box-shadow: 0 4px 12px rgba(245, 158, 11, 0.2);
      }

      .action-icon-btn.pause.paused {
        border-color: rgba(16, 185, 129, 0.3);
        background: rgba(16, 185, 129, 0.08);
      }

      .action-icon-btn.pause.paused:hover {
        border-color: rgba(16, 185, 129, 0.5);
        background: rgba(16, 185, 129, 0.15);
        box-shadow: 0 4px 12px rgba(16, 185, 129, 0.2);
      }

      /* Send Email Button */
      .action-icon-btn.send {
        border-color: rgba(103, 126, 234, 0.3);
        background: rgba(103, 126, 234, 0.08);
      }

      .action-icon-btn.send:hover {
        border-color: rgba(103, 126, 234, 0.5);
        background: rgba(103, 126, 234, 0.15);
        box-shadow: 0 4px 12px rgba(103, 126, 234, 0.2);
      }

      .action-icon-btn.send svg {
        width: 16px;
        height: 16px;
      }

      /* Mark Paid Button */
      .action-icon-btn.mark-paid {
        border-color: rgba(5, 150, 105, 0.3);
        background: rgba(5, 150, 105, 0.08);
      }

      .action-icon-btn.mark-paid:hover {
        border-color: rgba(5, 150, 105, 0.5);
        background: rgba(5, 150, 105, 0.15);
        box-shadow: 0 4px 12px rgba(5, 150, 105, 0.2);
      }

      /* Credit Button */
      .action-icon-btn.credit {
        border-color: rgba(59, 130, 246, 0.3);
        background: rgba(59, 130, 246, 0.08);
      }

      .action-icon-btn.credit:hover {
        border-color: rgba(59, 130, 246, 0.5);
        background: rgba(59, 130, 246, 0.15);
        box-shadow: 0 4px 12px rgba(59, 130, 246, 0.2);
      }

      /* Absent Button */
      .action-icon-btn.absent {
        border-color: rgba(239, 68, 68, 0.3);
        background: rgba(239, 68, 68, 0.08);
      }

      .action-icon-btn.absent:hover {
        border-color: rgba(239, 68, 68, 0.5);
        background: rgba(239, 68, 68, 0.15);
        box-shadow: 0 4px 12px rgba(239, 68, 68, 0.2);
      }

      /* Unmark Absent Button */
      .action-icon-btn.unmark {
        border-color: rgba(16, 185, 129, 0.3);
        background: rgba(16, 185, 129, 0.08);
      }

      .action-icon-btn.unmark:hover {
        border-color: rgba(16, 185, 129, 0.5);
        background: rgba(16, 185, 129, 0.15);
        box-shadow: 0 4px 12px rgba(16, 185, 129, 0.2);
      }

      .action-icon-btn:active {
        transform: scale(0.96);
      }

      /* Simplified Tooltip */
      .action-icon-btn[data-tooltip] {
        position: relative;
      }

      .action-icon-btn[data-tooltip]:hover::after {
        content: attr(data-tooltip);
        position: absolute;
        bottom: calc(100% + 6px);
        left: 50%;
        transform: translateX(-50%);
        padding: 6px 10px;
        background: rgba(0, 0, 0, 0.95);
        color: white;
        font-size: 0.75rem;
        white-space: nowrap;
        border-radius: 6px;
        z-index: 10000;
        pointer-events: none;
      }

      .action-icon-btn[data-tooltip]:hover::before {
        content: '';
        position: absolute;
        bottom: calc(100% + 1px);
        left: 50%;
        transform: translateX(-50%);
        border: 4px solid transparent;
        border-top-color: rgba(0, 0, 0, 0.95);
        z-index: 10000;
        pointer-events: none;
      }

      .badge {
        padding: 6px 12px;
        border-radius: 8px;
        font-size: 0.75rem;
        font-weight: 600;
        display: flex;
        align-items: center;
        gap: 4px;
      }

      .badge.paid {
        background: rgba(16, 185, 129, 0.2);
        color: #34d399;
        border: 1px solid rgba(16, 185, 129, 0.3);
      }

      .badge.manual-paid {
        background: rgba(5, 150, 105, 0.25);
        color: #10b981;
        border: 1px solid rgba(5, 150, 105, 0.4);
        box-shadow: 0 0 8px rgba(5, 150, 105, 0.2);
      }

      .badge.unpaid {
        background: rgba(239, 68, 68, 0.2);
        color: #f87171;
        border: 1px solid rgba(239, 68, 68, 0.3);
      }

      .badge.absent {
        background: rgba(245, 158, 11, 0.2);
        color: #fbbf24;
        border: 1px solid rgba(245, 158, 11, 0.3);
      }

      .empty-state {
        text-align: center;
        padding: 40px 20px;
      }

      .empty-state-icon {
        font-size: 3rem;
        margin-bottom: 15px;
        opacity: 0.5;
      }

      .empty-state-text {
        color: var(--text-secondary);
        font-size: 1rem;
      }

      /* Student Details Modal */
      .student-modal {
        max-width: 500px;
      }

      .student-detail-section {
        margin-bottom: 20px;
      }

      .student-detail-section:last-child {
        margin-bottom: 0;
      }

      .section-label {
        font-size: 0.75rem;
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 1px;
        color: var(--text-secondary);
        margin-bottom: 8px;
      }

      .section-content {
        background: rgba(255, 255, 255, 0.03);
        border: 1px solid var(--card-border);
        border-radius: 12px;
        padding: 15px;
        font-size: 1rem;
        color: var(--text-primary);
      }

      .section-content.highlight {
        background: rgba(245, 158, 11, 0.15);
        border-color: rgba(245, 158, 11, 0.3);
      }

      .section-content.balance {
        background: rgba(245, 158, 11, 0.15);
        border-color: rgba(245, 158, 11, 0.3);
        font-size: 1.5rem;
        font-weight: 700;
      }

      .balance-note {
        font-size: 0.85rem;
        color: var(--text-secondary);
        margin-top: 6px;
        font-weight: 400;
      }

      /* Credit Modal Styles */
      .credit-summary {
        background: linear-gradient(135deg, rgba(34,197,94,0.12) 0%, rgba(34,197,94,0.06) 100%);
        border: 1px solid rgba(34,197,94,0.3);
        border-radius: 16px;
        padding: 20px;
        margin-bottom: 24px;
        display: flex;
        align-items: center;
        justify-content: space-between;
      }

      .credit-summary-info h3 {
        font-size: 1rem;
        font-weight: 600;
        color: var(--text-primary);
        margin: 0 0 8px 0;
      }

      .credit-summary-info p {
        font-size: 0.9rem;
        color: var(--text-secondary);
        margin: 0;
      }

      .credit-summary-total {
        font-size: 2rem;
        font-weight: 700;
        background: linear-gradient(135deg, #22c55e 0%, #10b981 100%);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
      }

      .credit-student-list {
        display: flex;
        flex-direction: column;
        gap: 16px;
      }

      .credit-student-card {
        background: rgba(255, 255, 255, 0.03);
        border: 1px solid var(--card-border);
        border-radius: 14px;
        padding: 18px;
        transition: var(--transition);
      }

      .credit-student-card:hover {
        background: rgba(255, 255, 255, 0.05);
        border-color: rgba(138,180,255,0.3);
      }

      .credit-student-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 12px;
      }

      .credit-student-name {
        font-size: 1.1rem;
        font-weight: 600;
        color: var(--text-primary);
      }

      .credit-student-total {
        font-size: 1.2rem;
        font-weight: 700;
        color: #22c55e;
      }

      .credit-payment-list {
        display: flex;
        flex-direction: column;
        gap: 8px;
        margin-left: 12px;
      }

      .credit-payment-item {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 10px 14px;
        background: rgba(255, 255, 255, 0.02);
        border: 1px solid rgba(255, 255, 255, 0.05);
        border-radius: 10px;
        font-size: 0.9rem;
      }

      .credit-payment-date {
        color: var(--text-secondary);
      }

      .credit-payment-amount {
        font-weight: 600;
        color: var(--text-primary);
      }

      .modal-footer .btn-secondary:hover {
        background: rgba(255, 255, 255, 0.1);
        border-color: rgba(138,180,255,0.3);
      }

      .modal-footer .btn-primary:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 24px rgba(138,180,255,0.3);
      }

      .quick-actions-grid {
        display: flex;
        gap: 12px;
        margin-top: 20px;
        justify-content: center;
        align-items: center;
      }

      .quick-action-btn {
        width: 60px;
        height: 60px;
        border-radius: 16px;
        border: none;
        background: #3a3a3c;
        color: white;
        font-size: 24px;
        cursor: pointer;
        transition: transform 0.2s ease, opacity 0.2s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        position: relative;
      }

      .quick-action-btn.pause {
        background: #3a3a3c;
      }

      .quick-action-btn.forward {
        background: #3a3a3c;
      }

      .quick-action-btn.email-reminder {
        background: #fbbf24;
        color: #000;
        font-weight: bold;
      }

      .quick-action-btn.tertiary {
        background: #3a3a3c;
      }

      .quick-action-btn.payment {
        background: #3a3a3c;
      }

      .quick-action-btn.secondary {
        background: #3a3a3c;
        width: auto;
        padding: 0 20px;
        font-size: 14px;
      }

      .quick-action-btn:hover {
        transform: scale(1.05);
        opacity: 0.9;
      }

      .quick-action-btn:active {
        transform: scale(0.95);
      }

      .student-name-clickable {
        cursor: pointer;
        transition: color 0.2s ease;
      }

      .student-name-clickable:hover {
        color: var(--neon-cyan);
        text-shadow: 0 0 8px rgba(38, 255, 230, 0.6);
      }

      /* Payment Allocation Review UI */
      .payment-review-banner {
        margin: 24px 0 10px;
        padding: 18px 24px;
        border-radius: 20px;
        border: 1px solid rgba(250, 204, 21, 0.45);
        background: linear-gradient(120deg, rgba(250, 204, 21, 0.12), rgba(249, 115, 22, 0.1));
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 18px;
        box-shadow: 0 18px 30px rgba(0, 0, 0, 0.35);
      }

      .payment-review-banner.hidden {
        display: none;
      }

      .payment-review-banner .banner-left {
        display: flex;
        align-items: center;
        gap: 16px;
      }

      .payment-review-banner .banner-icon {
        font-size: 1.8rem;
      }

      .payment-review-chip {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 4px 12px;
        border-radius: 999px;
        background: rgba(250, 204, 21, 0.2);
        color: #d97706;
        font-size: 0.75rem;
        letter-spacing: 0.04em;
        text-transform: uppercase;
        font-weight: 700;
      }

      .payment-review-banner h4 {
        margin: 4px 0;
        font-size: 1.1rem;
        color: var(--text-primary);
      }

      .payment-review-subtitle {
        font-size: 0.9rem;
        color: rgba(255, 255, 255, 0.75);
      }

      .payment-review-banner .banner-actions {
        display: flex;
        align-items: center;
        gap: 12px;
      }

      .payment-review-btn {
        padding: 10px 20px;
        border-radius: 12px;
        border: none;
        font-weight: 600;
        cursor: pointer;
        transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
        white-space: nowrap;
      }

      .payment-review-btn.primary {
        background: linear-gradient(135deg, #f97316, #facc15);
        color: #0b0f17;
        box-shadow: 0 10px 25px rgba(249, 115, 22, 0.35);
      }

      .payment-review-btn.secondary {
        background: transparent;
        border: 1px solid rgba(255, 255, 255, 0.35);
        color: var(--text-primary);
      }

      .payment-review-btn:hover {
        transform: translateY(-1px);
      }

      .payment-review-scrim {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.6);
        backdrop-filter: blur(var(--panel-blur));
        z-index: 1500;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.25s ease;
      }

      .payment-review-scrim.visible {
        opacity: 1;
        pointer-events: all;
      }

      .payment-review-drawer {
        position: fixed;
        top: 0;
        right: -480px;
        width: min(420px, 92vw);
        height: 100vh;
        background: rgba(10, 14, 25, 0.96);
        border-left: 1px solid rgba(250, 204, 21, 0.2);
        box-shadow: -20px 0 40px rgba(0, 0, 0, 0.4);
        z-index: 1550;
        transition: right 0.35s cubic-bezier(0.4, 0, 0.2, 1);
        display: flex;
        flex-direction: column;
      }

      .payment-review-drawer.open {
        right: 0;
      }

      .payment-review-header {
        padding: 28px;
        border-bottom: 1px solid rgba(255, 255, 255, 0.08);
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        gap: 16px;
      }

      .payment-review-header h3 {
        margin: 0 0 6px 0;
        font-size: 1.3rem;
        color: var(--text-primary);
      }

      .payment-review-header p {
        margin: 0;
        color: rgba(255, 255, 255, 0.7);
        font-size: 0.9rem;
      }

      .payment-review-controls {
        padding: 0 28px 20px;
        border-bottom: 1px solid rgba(255, 255, 255, 0.08);
        display: flex;
        flex-direction: column;
        gap: 14px;
      }

      .payment-review-search {
        width: 100%;
        padding: 12px 16px;
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.15);
        background: rgba(255, 255, 255, 0.04);
        color: var(--text-primary);
        font-size: 0.95rem;
      }

      .payment-review-inline-stats {
        display: flex;
        justify-content: space-between;
        font-size: 0.9rem;
        color: rgba(255, 255, 255, 0.7);
      }

      .payment-review-list {
        padding: 24px 28px;
        overflow-y: auto;
        flex: 1;
      }

      .payment-review-card {
        border: 1px solid rgba(250, 204, 21, 0.25);
        border-radius: 16px;
        padding: 16px;
        margin-bottom: 18px;
        background: rgba(255, 255, 255, 0.03);
      }

      .payment-review-card h4 {
        margin: 0 0 4px 0;
        font-size: 1rem;
      }

      .payment-review-card small {
        color: rgba(255, 255, 255, 0.6);
      }

      .payment-review-payments {
        margin-top: 12px;
        display: flex;
        flex-direction: column;
        gap: 10px;
      }

      .payment-review-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 12px;
        padding: 10px 0;
        border-top: 1px solid rgba(255, 255, 255, 0.08);
      }

      .payment-review-row:first-child {
        border-top: none;
        padding-top: 0;
      }

      .payment-review-row span {
        font-size: 0.9rem;
      }

      .payment-review-actions {
        display: flex;
        gap: 8px;
      }

      .allocation-action {
        padding: 6px 10px;
        font-size: 0.8rem;
        border-radius: 8px;
        border: 1px solid transparent;
        background: rgba(255, 255, 255, 0.06);
        color: var(--text-primary);
        cursor: pointer;
      }

      .allocation-action.credit {
        border-color: rgba(6, 182, 212, 0.6);
        color: #5eead4;
      }

      .allocation-action.dismiss {
        border-color: rgba(239, 68, 68, 0.6);
        color: #fca5a5;
      }

      .allocation-action:hover {
        background: rgba(255, 255, 255, 0.1);
      }

      .payment-review-empty {
        margin-top: 40px;
        text-align: center;
        color: rgba(255, 255, 255, 0.5);
        font-size: 0.95rem;
      }

      .payment-review-header-actions {
        display: flex;
        gap: 10px;
      }

      .payment-review-close,
      .payment-review-reset {
        border: 1px solid rgba(255, 255, 255, 0.2);
        background: transparent;
        color: var(--text-primary);
        border-radius: 10px;
        padding: 8px 12px;
        cursor: pointer;
        font-weight: 600;
      }

      .payment-review-close {
        font-size: 1.1rem;
      }

      @media (max-width: 768px) {
        .payment-review-banner {
          flex-direction: column;
          align-items: flex-start;
        }

        .payment-review-banner .banner-actions {
          width: 100%;
          justify-content: flex-start;
          flex-wrap: wrap;
        }
      }

      /* Loading Animation */
      @keyframes pulse {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.5;
        }
      }

      .loading .day {
        animation: pulse 1.5s ease-in-out infinite;
      }

      /* Responsive Design */
      @media (max-width: 1024px) {
        .container {
          grid-template-columns: 1fr;
        }

        .sidebar {
          position: relative;
          top: 0;
        }
      }

      @media (max-width: 768px) {
        .calendar-header {
          flex-direction: column;
          gap: 20px;
          padding: 20px;
        }

        .month-year h1 {
          font-size: 1.8rem;
        }

        .calendar-grid {
          padding: 15px;
        }

        .day-number {
          font-size: 1rem;
        }

        .legend {
          gap: 15px;
        }

        .stats-grid {
          grid-template-columns: 1fr;
        }
      }

      /* Fade-in animation */
      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: translateY(20px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .day:nth-child(1) {
        animation-delay: 0.05s;
      }
      .day:nth-child(2) {
        animation-delay: 0.1s;
      }
      .day:nth-child(3) {
        animation-delay: 0.15s;
      }
      .day:nth-child(4) {
        animation-delay: 0.2s;
      }
      .day:nth-child(5) {
        animation-delay: 0.25s;
      }
      .day:nth-child(6) {
        animation-delay: 0.3s;
      }
      .day:nth-child(7) {
        animation-delay: 0.35s;
      }

      /* ============================================================
         MODULE POPUP OVERLAY SYSTEM
         ============================================================ */
      .module-popup-overlay {
        position: fixed;
        inset: 0;
        background: transparent !important;
        z-index: 100000;
        display: none;
        align-items: center;
        justify-content: center;
        animation: fadeIn 0.3s ease;
        pointer-events: none;
      }

      .module-popup-overlay.active {
        display: flex;
      }

      .module-popup-container {
        position: relative;
        width: 700px;
        max-width: 90vw;
        height: 80vh;
        max-height: 80vh;
        background: transparent;
        border-radius: 20px;
        overflow: hidden;
        box-shadow: 0 24px 80px rgba(0, 0, 0, 0.9);
        animation: slideUpModule 0.4s cubic-bezier(0.16, 1, 0.3, 1);
        pointer-events: auto;
      }

      @keyframes slideUpModule {
        from {
          opacity: 0;
          transform: scale(0.95);
        }
        to {
          opacity: 1;
          transform: scale(1);
        }
      }

      .module-popup-close {
        position: fixed;
        top: 24px;
        right: 24px;
        width: 48px;
        height: 48px;
        border-radius: 50%;
        background: linear-gradient(135deg, rgba(239, 68, 68, 0.3), rgba(220, 38, 38, 0.3));
        border: 2px solid rgba(239, 68, 68, 0.5);
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        z-index: 100001;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        box-shadow: 0 0 20px rgba(239, 68, 68, 0.4);
      }

      .module-popup-close:hover {
        background: linear-gradient(135deg, rgba(239, 68, 68, 0.5), rgba(220, 38, 38, 0.5));
        transform: scale(1.1) rotate(90deg);
        box-shadow: 0 0 30px rgba(239, 68, 68, 0.7);
      }

      .module-popup-close svg {
        width: 24px;
        height: 24px;
        stroke: #fca5a5;
        stroke-width: 3;
      }

      .module-popup-iframe {
        width: 100%;
        height: 100%;
        border: none;
        background: transparent;
      }
    </style>
  </head>
  <body>
    <!-- Floating Toggle Button -->
    <button class="floating-toggle" id="floatingToggle">
      <span class="toggle-icon">‚Ä∫</span>
    </button>

    <div class="container">
      <!-- Main Calendar Area -->
      <div class="calendar-wrapper">
        <!-- Header -->
        <div class="calendar-header">
          <div class="month-year">
            <div style="display: flex; align-items: center; gap: 20px">
              <h1 id="currentMonth">November</h1>
              <span class="year-badge" id="currentYear">2025</span>
            </div>
            <div class="calendar-stats" id="calendarStats">
              <span id="activeStudentsCount">44 active students</span>
              <span>‚Ä¢</span>
              <span id="scheduledClassesCount">391 scheduled classes</span>
              <span class="stat-divider">|</span>
              <span class="stat-paid" id="monthPaid">üí∞ 15,975 $ paid</span>
              <span class="stat-divider">|</span>
              <span class="stat-pending" id="monthPending">‚ö†Ô∏è 1,025 $ pending</span>
            </div>
          </div>
          <div style="display: flex; align-items: center; gap: 12px;">
            <!-- Multi-Select Status Filter -->
            <div style="position: relative;">
              <button 
                id="statusFilterBtn" 
                style="padding: 10px 16px; background: rgba(255,255,255,0.08); border: 1px solid rgba(138,180,255,0.3); border-radius: 10px; color: white; outline: none; font-size: 14px; cursor: pointer; transition: all 0.2s ease; display: flex; align-items: center; gap: 8px;"
                onclick="toggleStatusDropdown()"
              >
                <span id="statusFilterLabel">All Statuses</span>
                <span style="font-size: 10px;">‚ñº</span>
              </button>
              <div 
                id="statusFilterDropdown" 
                style="display: none; position: fixed; background: rgba(31, 20, 60, 0.98); border: 1px solid rgba(138,180,255,0.3); border-radius: 10px; padding: 8px; min-width: 200px; z-index: 9999999; box-shadow: 0 8px 24px rgba(0,0,0,0.4);"
              >
                <label style="display: flex; align-items: center; padding: 8px; cursor: pointer; border-radius: 6px; transition: background 0.2s;" onmouseover="this.style.background='rgba(138,180,255,0.1)'" onmouseout="this.style.background='transparent'">
                  <input type="checkbox" value="paid" style="margin-right: 10px;" onchange="updateStatusFilter()">
                  <span style="color: #22c55e;">‚úÖ Paid</span>
                </label>
                <label style="display: flex; align-items: center; padding: 8px; cursor: pointer; border-radius: 6px; transition: background 0.2s;" onmouseover="this.style.background='rgba(138,180,255,0.1)'" onmouseout="this.style.background='transparent'">
                  <input type="checkbox" value="unpaid" style="margin-right: 10px;" onchange="updateStatusFilter()">
                  <span style="color: #ef4444;">‚ùå Unpaid</span>
                </label>
                <label style="display: flex; align-items: center; padding: 8px; cursor: pointer; border-radius: 6px; transition: background 0.2s;" onmouseover="this.style.background='rgba(138,180,255,0.1)'" onmouseout="this.style.background='transparent'">
                  <input type="checkbox" value="credit" style="margin-right: 10px;" onchange="updateStatusFilter()">
                  <span style="color: #3b82f6;">üí≥ Credit</span>
                </label>
                <label style="display: flex; align-items: center; padding: 8px; cursor: pointer; border-radius: 6px; transition: background 0.2s;" onmouseover="this.style.background='rgba(138,180,255,0.1)'" onmouseout="this.style.background='transparent'">
                  <input type="checkbox" value="absent" style="margin-right: 10px;" onchange="updateStatusFilter()">
                  <span style="color: #f59e0b;">üö´ Absent</span>
                </label>
                <label style="display: flex; align-items: center; padding: 8px; cursor: pointer; border-radius: 6px; transition: background 0.2s;" onmouseover="this.style.background='rgba(138,180,255,0.1)'" onmouseout="this.style.background='transparent'">
                  <input type="checkbox" value="canceled" style="margin-right: 10px;" onchange="updateStatusFilter()">
                  <span style="color: #6b7280;">‚≠ï Canceled</span>
                </label>
                <label style="display: flex; align-items: center; padding: 8px; cursor: pointer; border-radius: 6px; transition: background 0.2s;" onmouseover="this.style.background='rgba(138,180,255,0.1)'" onmouseout="this.style.background='transparent'">
                  <input type="checkbox" value="partial" style="margin-right: 10px;" onchange="updateStatusFilter()">
                  <span style="color: #eab308;">‚ö†Ô∏è Partial</span>
                </label>
              </div>
            </div>
            <input 
              type="text" 
              id="studentSearchInput" 
              placeholder="üîç Search students..." 
              style="padding: 10px 16px; background: rgba(255,255,255,0.08); border: 1px solid rgba(138,180,255,0.3); border-radius: 10px; color: white; outline: none; font-size: 14px; width: 220px; transition: all 0.2s ease;"
              onfocus="this.style.background='rgba(255,255,255,0.12)'; this.style.borderColor='rgba(138,180,255,0.5)';"
              onblur="this.style.background='rgba(255,255,255,0.08)'; this.style.borderColor='rgba(138,180,255,0.3)';"
            />
            <div class="nav-controls">
            <button class="nav-btn" id="prevMonth" title="Previous Month">‚Äπ</button>
            <button class="today-btn" id="todayBtn">Today</button>
            <button class="nav-btn" id="nextMonth" title="Next Month">‚Ä∫</button>
            <button class="refresh-btn" id="refreshBtn" title="Refresh calendar data">
              <svg viewBox="0 0 24 24" class="refresh-icon">
                <path d="M21.5 2v6h-6M2.5 22v-6h6M2 11.5a10 10 0 0 1 18.8-4.3M22 12.5a10 10 0 0 1-18.8 4.2"/>
              </svg>
            </button>
            <button class="notification-bell" id="creditNotificationBell" title="Excess payment notifications">
              <svg viewBox="0 0 24 24">
                <path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"></path>
                <path d="M13.73 21a2 2 0 0 1-3.46 0"></path>
              </svg>
              <span class="notification-badge" id="creditNotificationBadge" style="display: none;">0</span>
            </button>
            </div>
          </div>
        </div>

        <!-- Search Recap Section -->
        <div class="search-recap" id="searchRecap">
          <span class="search-recap-title" id="searchRecapTitle">ALLA</span>
          <div class="search-recap-stats" id="searchRecapStats">
            <!-- Stats will be dynamically inserted here -->
          </div>
          <button class="search-recap-close" id="searchRecapClose" title="Clear search">‚úï</button>
        </div>

        <div class="payment-review-banner hidden" id="paymentReviewBanner">
          <div class="banner-left">
            <div class="banner-icon">‚ö†Ô∏è</div>
            <div>
              <div class="payment-review-chip">Needs review</div>
              <h4>
                <span id="paymentReviewCount">0</span>
                pending payment<span id="paymentReviewPlural">s</span>
                ¬∑
                <span id="paymentReviewTotal">0</span> $
              </h4>
              <div class="payment-review-subtitle" id="paymentReviewSummary">
                We couldn‚Äôt auto-match these payments between Nov 1 and today.
              </div>
            </div>
          </div>
          <div class="banner-actions">
            <button class="payment-review-btn primary" id="paymentReviewBannerBtn">Review now</button>
            <button class="payment-review-btn secondary" id="paymentReviewExportBtn">Export CSV</button>
          </div>
        </div>

        <!-- Calendar Grid -->
        <div class="calendar-grid">
          <!-- Weekday Headers -->
          <div class="weekdays">
            <div class="weekday">Sun</div>
            <div class="weekday">Mon</div>
            <div class="weekday">Tue</div>
            <div class="weekday">Wed</div>
            <div class="weekday">Thu</div>
            <div class="weekday">Fri</div>
            <div class="weekday">Sat</div>
          </div>

          <!-- Days -->
          <div class="days" id="calendarDays"></div>
        </div>

        <!-- Legend -->
        <div class="legend">
          <div class="legend-item">
            <div class="legend-dot dot-class"></div>
            <span>Class Scheduled</span>
          </div>
          <div class="legend-item">
            <div class="legend-dot dot-payment"></div>
            <span>Paid</span>
          </div>
          <div class="legend-item">
            <div class="legend-dot dot-credit"></div>
            <span>Credit Used</span>
          </div>
          <div class="legend-item">
            <div class="legend-dot dot-unpaid"></div>
            <span>Unpaid</span>
          </div>
          <div class="legend-item">
            <div class="legend-dot dot-partial"></div>
            <span>Partial Payment</span>
          </div>
          <div class="legend-item">
            <div class="legend-dot dot-absent"></div>
            <span>Absent</span>
          </div>
          <div class="legend-item">
            <div class="legend-dot dot-skipped"></div>
            <span>Class Skipped</span>
          </div>
          <div class="legend-item">
            <div class="legend-dot dot-canceled"></div>
            <span>Class Canceled</span>
          </div>
          <div class="legend-item">
            <div class="legend-dot" style="background: linear-gradient(135deg, #26ffe6, #8a4dff)"></div>
            <span>Today</span>
          </div>
        </div>
      </div>

      <!-- Sidebar -->
      <div class="sidebar" id="sidebar">
        <button class="sidebar-toggle" id="sidebarToggle">
          <span class="toggle-icon">‚Ä∫</span>
        </button>

        <div class="sidebar-content">
          <!-- Stats Section -->
          <div class="sidebar-section">
            <h3 class="sidebar-title">Overview</h3>
            <div class="stats-grid">
              <div class="stat-card">
                <span class="stat-number" id="totalClasses">12</span>
                <span class="stat-label">Classes</span>
              </div>
              <div class="stat-card">
                <span class="stat-number" id="totalPayments">8</span>
                <span class="stat-label">Payments</span>
              </div>
              <div class="stat-card">
                <span class="stat-number" id="totalAbsences">3</span>
                <span class="stat-label">Absences</span>
              </div>
              <div class="stat-card">
                <span class="stat-number" id="totalSkipped">2</span>
                <span class="stat-label">Skipped</span>
              </div>
            </div>
          </div>

          <!-- Filters Section -->
          <div class="sidebar-section">
            <h3 class="sidebar-title">Filters</h3>
            <div class="filter-group">
              <div class="filter-item active" data-filter="classes">
                <div class="filter-label">
                  <div class="filter-checkbox"></div>
                  <span>Show Classes</span>
                </div>
                <span class="filter-count">12</span>
              </div>
              <div class="filter-item active" data-filter="payments">
                <div class="filter-label">
                  <div class="filter-checkbox"></div>
                  <span>Show Payments</span>
                </div>
                <span class="filter-count">8</span>
              </div>
              <div class="filter-item active" data-filter="absences">
                <div class="filter-label">
                  <div class="filter-checkbox"></div>
                  <span>Show Absences</span>
                </div>
                <span class="filter-count">3</span>
              </div>
              <div class="filter-item active" data-filter="skipped">
                <div class="filter-label">
                  <div class="filter-checkbox"></div>
                  <span>Show Skipped</span>
                </div>
                <span class="filter-count">2</span>
              </div>
            </div>
          </div>

          <!-- Group Filter Section -->
          <div class="sidebar-section">
            <h3 class="sidebar-title">Filter by Group</h3>
            <div class="filter-group">
              <div class="filter-item active" data-group="all">
                <div class="filter-label">
                  <div class="filter-checkbox"></div>
                  <span>All Groups</span>
                </div>
              </div>
              <div class="filter-item active" data-group="A">
                <div class="filter-label">
                  <div class="filter-checkbox"></div>
                  <span>Group A</span>
                </div>
              </div>
              <div class="filter-item active" data-group="B">
                <div class="filter-label">
                  <div class="filter-checkbox"></div>
                  <span>Group B</span>
                </div>
              </div>
              <div class="filter-item active" data-group="C">
                <div class="filter-label">
                  <div class="filter-checkbox"></div>
                  <span>Group C</span>
                </div>
              </div>
              <div class="filter-item active" data-group="D">
                <div class="filter-label">
                  <div class="filter-checkbox"></div>
                  <span>Group D</span>
                </div>
              </div>
              <div class="filter-item active" data-group="E">
                <div class="filter-label">
                  <div class="filter-checkbox"></div>
                  <span>Group E</span>
                </div>
              </div>
              <div class="filter-item active" data-group="F">
                <div class="filter-label">
                  <div class="filter-checkbox"></div>
                  <span>Group F</span>
                </div>
              </div>
            </div>
          </div>

          <!-- Upcoming and Unpaid Alerts -->
          <div class="sidebar-section">
            <h3 class="sidebar-title">Upcoming Classes</h3>
            <div class="insight-list" id="upcomingClassesList">
              <div class="insight-empty">No future classes in view</div>
            </div>
          </div>

          <div class="sidebar-section">
            <h3 class="sidebar-title">Unpaid Alerts</h3>
            <div class="insight-list" id="unpaidClassesList">
              <div class="insight-empty">No unpaid classes in view</div>
            </div>
          </div>

          <!-- Quick Actions Section -->
          <div class="sidebar-section">
            <h3 class="sidebar-title">Quick Actions</h3>
            <div class="quick-actions">
              <button class="action-btn">üìÖ Add Event</button>
              <button class="action-btn">üí∞ Record Payment</button>
              <button class="action-btn">üìä View Reports</button>
              <button class="action-btn">‚öôÔ∏è Settings</button>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Modal -->
    <div class="modal-overlay" id="dayModal">
      <div class="modal">
        <div class="modal-header">
          <div class="modal-title">
            <h2 id="modalDate">November 20, 2025</h2>
            <span class="modal-subtitle" id="modalDayOfWeek">Wednesday</span>
          </div>
          <button class="modal-close" id="closeModal">√ó</button>
        </div>
        <div class="modal-body" id="modalBody">
          <!-- Content will be dynamically inserted here -->
        </div>
      </div>
    </div>

    <!-- Credit Confirmation Modal -->
    <div class="modal-overlay" id="creditModal">
      <div class="modal" style="max-width: 700px;">
        <div class="modal-header">
          <div class="modal-title">
            <h2>üí≥ Excess Payments Detected</h2>
            <span class="modal-subtitle">Students paid more than their scheduled classes</span>
          </div>
          <button class="modal-close" id="closeCreditModal">√ó</button>
        </div>
        <div class="modal-body" id="creditModalBody" style="max-height: calc(80vh - 240px);">
          <!-- Content will be dynamically inserted here -->
        </div>
        <div class="modal-footer" style="padding: 20px 30px; border-top: 1px solid var(--card-border); display: flex; gap: 12px; justify-content: space-between;">
          <button class="btn-danger" id="skipAllCreditBtn" style="padding: 12px 24px; border-radius: 12px; border: 1px solid #ff4757; background: rgba(255, 71, 87, 0.1); color: #ff4757; cursor: pointer; font-weight: 600; transition: var(--transition);">
            Skip All
          </button>
          <div style="display: flex; gap: 12px;">
            <button class="btn-secondary" id="cancelCreditBtn" style="padding: 12px 24px; border-radius: 12px; border: 1px solid var(--glass-border); background: var(--glass-bg); color: var(--text-primary); cursor: pointer; font-weight: 600; transition: var(--transition);">
              Skip Student
            </button>
            <button class="btn-primary" id="applyCreditBtn" style="padding: 12px 24px; border-radius: 12px; border: none; background: var(--primary-gradient); color: #000; cursor: pointer; font-weight: 600; transition: var(--transition);">
              Confirm
            </button>
          </div>
        </div>
      </div>
    </div>

    <!-- Confirm Modal -->
    <div class="modal-overlay" id="confirmModal" style="display: none;">
      <div class="modal" style="max-width: 500px;">
        <div class="modal-header">
          <div class="modal-title">
            <h2 id="confirmTitle">Confirm</h2>
          </div>
          <button class="modal-close" id="closeConfirmModal">√ó</button>
        </div>
        <div class="modal-body" id="confirmMessage" style="padding: 30px;">
          <!-- Content will be dynamically inserted here -->
        </div>
        <div class="modal-footer" style="padding: 20px 30px; border-top: 1px solid var(--card-border); display: flex; gap: 12px; justify-content: flex-end;">
          <button class="btn-secondary" id="cancelBtn" style="padding: 12px 24px; border-radius: 12px; border: 1px solid var(--glass-border); background: var(--glass-bg); color: var(--text-primary); cursor: pointer; font-weight: 600; transition: var(--transition);">
            Cancel
          </button>
          <button class="btn-primary" id="confirmBtn" style="padding: 12px 24px; border-radius: 12px; border: none; background: var(--primary-gradient); color: #000; cursor: pointer; font-weight: 600; transition: var(--transition);">
            Confirm
          </button>
        </div>
      </div>
    </div>

    <div class="payment-review-scrim" id="paymentReviewScrim"></div>
    <aside class="payment-review-drawer" id="paymentReviewDrawer" aria-hidden="true">
      <div class="payment-review-header">
        <div>
          <h3>Payment allocation review</h3>
          <p id="paymentReviewDrawerSubtitle">Tell us what to do with uncertain payments.</p>
        </div>
        <div class="payment-review-header-actions">
          <button class="payment-review-reset" id="paymentReviewResetBtn" title="Bring back dismissed items">Reset hidden</button>
          <button class="payment-review-close" id="paymentReviewCloseBtn" aria-label="Close review drawer">√ó</button>
        </div>
      </div>
      <div class="payment-review-controls">
        <input
          type="search"
          class="payment-review-search"
          id="paymentReviewSearch"
          placeholder="Search by student, date, amount, or memo"
        />
        <div class="payment-review-inline-stats">
          <span id="paymentReviewDrawerCount">0 pending</span>
          <span id="paymentReviewDrawerTotal">0 $ unresolved</span>
        </div>
      </div>
      <div class="payment-review-list" id="paymentReviewList">
        <div class="payment-review-empty">You're all caught up üôå</div>
      </div>
    </aside>

    <script>
      // Toggle status dropdown - must be global for onclick
      function toggleStatusDropdown() {
        const dropdown = document.getElementById('statusFilterDropdown');
        const button = document.getElementById('statusFilterBtn');
        
        if (dropdown.style.display === 'block') {
          dropdown.style.display = 'none';
        } else {
          const rect = button.getBoundingClientRect();
          dropdown.style.top = (rect.bottom + 4) + 'px';
          dropdown.style.left = rect.left + 'px';
          dropdown.style.display = 'block';
        }
      }

      // Status filter state - must be global
      let selectedStatuses = new Set();

      // Update status filter - must be global for onchange
      function updateStatusFilter() {
        selectedStatuses.clear();
        const checkboxes = document.querySelectorAll('#statusFilterDropdown input[type="checkbox"]:checked');
        checkboxes.forEach(cb => selectedStatuses.add(cb.value));
        
        const label = document.getElementById('statusFilterLabel');
        if (selectedStatuses.size === 0) {
          label.textContent = 'All Statuses';
        } else if (selectedStatuses.size === 1) {
          const status = Array.from(selectedStatuses)[0];
          const labels = {
            'paid': '‚úÖ Paid',
            'unpaid': '‚ùå Unpaid',
            'credit': 'üí≥ Credit',
            'absent': 'üö´ Absent',
            'canceled': '‚≠ï Canceled',
            'partial': '‚ö†Ô∏è Partial'
          };
          label.textContent = labels[status] || status;
        } else {
          label.textContent = `${selectedStatuses.size} Selected`;
        }
        
        applyStudentFilters();
      }

      // Calendar State
      let currentDate = new Date();
      const monthNames = [
        'January',
        'February',
        'March',
        'April',
        'May',
        'June',
        'July',
        'August',
        'September',
        'October',
        'November',
        'December',
      ];
      const CALENDAR_START_DATE_STR = '2025-11-01';
      const CALENDAR_START_DATE = createDateFromDateStr(CALENDAR_START_DATE_STR);

      // Globals initialized early to avoid temporal-dead-zone ReferenceErrors
      // Define once; later code will assign to these
      var absencesData = absencesData || {};
      var creditPaymentsLookup = creditPaymentsLookup || {};
      var studentAllocationCache = new Map(); // December 2025 payment allocation cache
      
      // Payment allocation tracker - tracks how much of each payment has been used
      const paymentAllocationTracker = new Map(); // paymentId -> { total, used, remaining }

      function resetPaymentAllocation() {
        paymentAllocationTracker.clear();
      }

      const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];

      const EVENT_STYLE_MAP = {
        class: {
          dotClass: 'dot-class',
          icon: 'üìò',
          accent: 'linear-gradient(135deg, #a855f7 0%, #9333ea 100%)',
        },
        payment: {
          dotClass: 'dot-payment',
          icon: 'üíµ',
          accent: 'linear-gradient(135deg, #22c55e 0%, #4ade80 100%)',
        },
        credit: {
          dotClass: 'dot-credit',
          icon: 'üí≥',
          accent: 'linear-gradient(135deg, #06b6d4 0%, #3b82f6 100%)',
        },
        studentJoin: {
          dotClass: 'dot-student',
          icon: 'üßë‚Äçüéì',
          accent: 'linear-gradient(135deg, #38bdf8 0%, #818cf8 100%)',
        },
        studentStatus: {
          dotClass: 'dot-status',
          icon: 'üîÅ',
          accent: 'linear-gradient(135deg, #f97316 0%, #fb923c 100%)',
        },
        studentBirthday: {
          dotClass: 'dot-birthday',
          icon: 'üéÇ',
          accent: 'linear-gradient(135deg, #f472b6 0%, #fb7185 100%)',
        },
      };

      let calendarBaseEvents = [];
      let currentMonthEventMap = {};
      let currentMonthEventsFlat = [];
      let lastMergedEventsCount = 0;

      const LA_TIMEZONE = 'America/Los_Angeles';
      const laDateTimeFormatter = new Intl.DateTimeFormat('en-US', {
        timeZone: LA_TIMEZONE,
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
        weekday: 'long',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        hour12: false,
      });
      const laHumanDateFormatter = new Intl.DateTimeFormat('en-US', {
        timeZone: LA_TIMEZONE,
        month: 'long',
        day: 'numeric',
        year: 'numeric',
      });
      const laWeekdayFormatter = new Intl.DateTimeFormat('en-US', {
        timeZone: LA_TIMEZONE,
        weekday: 'long',
      });
      const laTimeFormatter = new Intl.DateTimeFormat('en-US', {
        timeZone: LA_TIMEZONE,
        hour: 'numeric',
        minute: '2-digit',
        hour12: true,
      });

      function getLAParts(dateInput) {
        const date = dateInput instanceof Date ? dateInput : new Date(dateInput);
        if (isNaN(date.getTime())) return null;
        const parts = {};
        laDateTimeFormatter.formatToParts(date).forEach(part => {
          parts[part.type] = part.value;
        });
        return parts;
      }

      function getLAWeekdayName(dateInput) {
        const date = dateInput instanceof Date ? dateInput : new Date(dateInput);
        if (isNaN(date.getTime())) return '';
        return laWeekdayFormatter.format(date);
      }

      function getLAWeekdayIndex(dateInput) {
        const name = getLAWeekdayName(dateInput);
        if (!name) return null;
        const idx = dayNames.indexOf(name);
        return idx === -1 ? null : idx;
      }

      function formatHumanDateInLA(dateInput) {
        const date = dateInput instanceof Date ? dateInput : new Date(dateInput);
        if (isNaN(date.getTime())) return '';
        return laHumanDateFormatter.format(date);
      }

      function formatTimeInLA(dateInput) {
        const date = dateInput instanceof Date ? dateInput : new Date(dateInput);
        if (isNaN(date.getTime())) return '';
        return laTimeFormatter.format(date);
      }

      // Alias for compatibility
      function formatDateNice(dateStr) {
        if (!dateStr) return '';
        // Handle YYYY-MM-DD format
        const date = dateStr.includes('-') ? new Date(dateStr + 'T12:00:00') : new Date(dateStr);
        return formatHumanDateInLA(date);
      }

      function parseTimeToMinutes(timeStr) {
        if (!timeStr || typeof timeStr !== 'string') return 0;
        const match = timeStr.trim().match(/^(\d{1,2}):(\d{2})\s*(AM|PM)$/i);
        if (!match) return 0;
        let hours = Number(match[1]) % 12;
        const minutes = Number(match[2]) || 0;
        const period = match[3].toUpperCase();
        if (period === 'PM') {
          hours += 12;
        }
        return hours * 60 + minutes;
      }

      function normalizeDateInput(value) {
        if (!value) return '';
        if (typeof value === 'string') {
          const trimmed = value.trim();
          // If already in YYYY-MM-DD format, return as-is
          if (/^\d{4}-\d{2}-\d{2}$/.test(trimmed)) {
            return trimmed;
          }
        }
        // Convert to LA timezone before formatting
        // This ensures UTC timestamps are converted to LA dates
        return formatDateYYYYMMDD(value);
      }

      function createDateFromParts(year, monthIndex, day) {
        return new Date(Date.UTC(year, monthIndex, day, 12, 0, 0));
      }

      function createDateFromDateStr(dateStr) {
        const parts = parseDateParts(dateStr);
        if (!parts) return null;
        return createDateFromParts(parts.year, parts.month - 1, parts.day);
      }

      function getTodayLAParts() {
        return getLAParts(new Date());
      }

      function syncCurrentDateToLAToday() {
        const todayParts = getTodayLAParts();
        if (todayParts) {
          currentDate = createDateFromParts(
            Number(todayParts.year),
            Number(todayParts.month) - 1,
            Number(todayParts.day)
          );
        }
      }

      function getCurrentViewYearMonth() {
        const parts = getLAParts(currentDate);
        if (parts) {
          return { year: Number(parts.year), month: Number(parts.month) - 1 };
        }
        return { year: currentDate.getFullYear(), month: currentDate.getMonth() };
      }

      // ‚ö° LAZY LOADING: Track loaded date ranges to avoid reloading
      let loadedPaymentRange = { start: null, end: null };

      function shiftCurrentView(deltaMonths) {
        const { year, month } = getCurrentViewYearMonth();
        let newMonth = month + deltaMonths;
        let newYear = year;
        while (newMonth < 0) {
          newMonth += 12;
          newYear -= 1;
        }
        while (newMonth > 11) {
          newMonth -= 12;
          newYear += 1;
        }
        currentDate = createDateFromParts(newYear, newMonth, 1);
        
        // ‚ö° LAZY LOADING: Check if we need to load more payment data
        checkAndLoadPaymentsForMonth(newYear, newMonth);
      }
      
      // ‚ö° LAZY LOADING: Load payments for month if not already loaded
      async function checkAndLoadPaymentsForMonth(year, month) {
        const monthStartStr = new Date(year, month, 1).toISOString().split('T')[0];
        const monthEndStr = new Date(year, month + 1, 0).toISOString().split('T')[0];
        
        // Check if this month is already in our loaded range
        const isLoaded = loadedPaymentRange.start && loadedPaymentRange.end &&
          monthStartStr >= loadedPaymentRange.start &&
          monthEndStr <= loadedPaymentRange.end;
        
        if (isLoaded) {
          debugLog('‚úÖ Payments already loaded for', year, month);
          return;
        }
        
        // Calculate new range: requested month +/- 2 months
        const rangeStart = new Date(year, month - 2, 1);
        const rangeEnd = new Date(year, month + 3, 0);
        const startDateStr = rangeStart.toISOString().split('T')[0];
        const endDateStr = rangeEnd.toISOString().split('T')[0];
        
        debugLog('üì• Loading additional payments for', year, month, '(range:', startDateStr, 'to', endDateStr, ')');
        
        // Load payments for this range
        await loadPayments({ start: startDateStr, end: endDateStr });
        
        // Update loaded range (expand to include new range)
        if (!loadedPaymentRange.start || startDateStr < loadedPaymentRange.start) {
          loadedPaymentRange.start = startDateStr;
        }
        if (!loadedPaymentRange.end || endDateStr > loadedPaymentRange.end) {
          loadedPaymentRange.end = endDateStr;
        }
        
        // Clear month cache to force re-computation with new data
        clearMonthCache();
      }

      function ensureAMPMFormatLocal(timeStr) {
        if (!timeStr) return '';
        if (/AM|PM/i.test(timeStr)) return timeStr;

        const match = timeStr.match(/^(\d{1,2}):(\d{2})$/);
        if (!match) return timeStr;

        let hours = parseInt(match[1], 10);
        const minutes = match[2];
        const period = hours >= 12 ? 'PM' : 'AM';

        if (hours > 12) hours -= 12;
        if (hours === 0) hours = 12;

        return `${hours}:${minutes} ${period}`;
      }

      function parseScheduleString(scheduleStr) {
        if (scheduleStr == null) {
          return [];
        }

        if (typeof scheduleStr !== 'string') {
          // console.warn('Invalid schedule string:', scheduleStr);
          return [];
        }

        const rawInput = scheduleStr.trim();
        if (!rawInput) {
          return [];
        }

        // Some data sources use placeholder dashes or terms like "TBD" when no schedule exists.
  if (/^[-‚Äì‚Äî]+$/.test(rawInput) || /^(?:n[\/\.\s]?a|none|null|tbd|tba)$/i.test(rawInput)) {
          return [];
        }

        const sessions = [];
        
        // Normalize input: trim, handle various separators
        const normalizedSchedule = rawInput
          .replace(/\s*;\s*/g, ',')  // Handle semicolon separators
          .replace(/\s+/g, ' ');      // Normalize whitespace
          
        const parts = normalizedSchedule
          .split(',')
          .map(p => p.trim())
          .filter(Boolean);

        if (!parts.length) {
          return [];
        }

        const normalizeDay = day => {
          if (!day) return '';
          const cleaned = day.trim().toLowerCase().replace(/[^a-z]/g, '');
          const map = {
            sun: 'Sunday',
            sunday: 'Sunday',
            mon: 'Monday',
            monday: 'Monday',
            tue: 'Tuesday',
            tues: 'Tuesday',
            tuesday: 'Tuesday',
            wed: 'Wednesday',
            weds: 'Wednesday',
            wednesday: 'Wednesday',
            thu: 'Thursday',
            thur: 'Thursday',
            thurs: 'Thursday',
            thursday: 'Thursday',
            fri: 'Friday',
            friday: 'Friday',
            sat: 'Saturday',
            saturday: 'Saturday',
          };
          return map[cleaned] || '';
        };

        parts.forEach(part => {
          // More flexible regex to handle various formats
          const match = part.match(/^([A-Za-z/]+)\s+(.+)$/);
          if (!match) {
            // console.warn('Failed to parse schedule part:', part);
            return;
          }

          const daySegment = match[1];
          const timeSegment = ensureAMPMFormatLocal(match[2]);

          if (!timeSegment) {
            // console.warn('Failed to parse time:', match[2]);
            return;
          }

          daySegment.split('/').forEach(day => {
            const fullDay = normalizeDay(day);
            if (fullDay) {
              sessions.push({ day: fullDay, time: timeSegment });
            } else {
              // console.warn('Unrecognized day name:', day);
            }
          });
        });

        return sessions;
      }

      function parseDateParts(dateStr) {
        if (!dateStr || typeof dateStr !== 'string') return null;
        const match = dateStr.match(/^(\d{4})-(\d{2})-(\d{2})$/);
        if (!match) return null;
        return {
          year: Number(match[1]),
          month: Number(match[2]),
          day: Number(match[3]),
        };
      }

      function formatDateYYYYMMDD(dateInput) {
        const parts = getLAParts(dateInput);
        if (!parts) return '';
        return `${parts.year}-${parts.month}-${parts.day}`;
      }

      const monthCache = new Map();

      // ARNOMA rule: only consider classes/payments occurring on/after Nov 1, 2025 unless overridden.
      const COVERAGE_WINDOW_START =
        window.arnomaCoverageWindowStart || window.COVERAGE_WINDOW_START || '2025-11-01';

      function isWithinCoverageWindow(dateStr) {
        if (!dateStr || !COVERAGE_WINDOW_START) return false;
        return dateStr >= COVERAGE_WINDOW_START;
      }

      const PAYMENT_ALLOCATION_RESOLUTIONS_KEY = 'arnoma.paymentAllocationResolutions.v1';
      let paymentAllocationResolutionsCache = null;

      function loadPaymentAllocationResolutions() {
        if (paymentAllocationResolutionsCache) return paymentAllocationResolutionsCache;
        if (typeof localStorage === 'undefined') {
          paymentAllocationResolutionsCache = {};
          return paymentAllocationResolutionsCache;
        }
        try {
          const raw = localStorage.getItem(PAYMENT_ALLOCATION_RESOLUTIONS_KEY);
          paymentAllocationResolutionsCache = raw ? JSON.parse(raw) : {};
        } catch (error) {
          // console.warn('Unable to read payment allocation resolutions from localStorage', error);
          paymentAllocationResolutionsCache = {};
        }
        return paymentAllocationResolutionsCache;
      }

      function savePaymentAllocationResolutions(resolutions) {
        paymentAllocationResolutionsCache = resolutions;
        if (typeof localStorage === 'undefined') return;
        try {
          localStorage.setItem(PAYMENT_ALLOCATION_RESOLUTIONS_KEY, JSON.stringify(resolutions));
        } catch (error) {
          // console.warn('Unable to persist payment allocation resolutions', error);
        }
      }

      function resetPaymentAllocationResolutions() {
        savePaymentAllocationResolutions({});
      }

      function canonicalizeGroupCode(value) {
        if (!value) return '';
        const raw = value.toString().trim();
        if (!raw) return '';
        const withoutPrefix = raw.replace(/^group\s+/i, '');
        const normalized = withoutPrefix.replace(/[^a-z0-9]/gi, '').toUpperCase();
        return normalized;
      }

      function formatGroupDisplay(code) {
        if (!code) return 'No Group';
        return `Group ${code}`;
      }

      function buildPaymentAllocationKey(entry) {
        if (!entry) return 'unknown-allocation';
        const pieces = [
          entry.paymentId || entry.id || 'payment',
          entry.studentId || entry.studentName || 'student',
          entry.payDate || 'date',
          Number(entry.amount || 0).toFixed(2),
        ];
        return pieces.join('|');
      }

      function markPaymentAllocationResolution(entry, action = 'acknowledged', note = '') {
        if (!entry) return;
        const key = buildPaymentAllocationKey(entry);
        const existing = loadPaymentAllocationResolutions();
        existing[key] = {
          action,
          note,
          resolvedAt: new Date().toISOString(),
        };
        savePaymentAllocationResolutions(existing);
      }

      function filterResolvedPaymentAllocations(entries) {
        if (!Array.isArray(entries) || !entries.length) return [];
        const resolutions = loadPaymentAllocationResolutions();
        return entries.filter(entry => {
          const key = buildPaymentAllocationKey(entry);
          return !resolutions[key];
        });
      }

      const MANUAL_PAYMENT_MOVES_TABLE = 'manual_payment_moves';
      const MANUAL_PAYMENT_MOVES_CACHE_TTL_MS = 2 * 60 * 1000; // 2 minutes
      let manualPaymentMovesState = {
        byStudentId: new Map(),
        lastFetched: 0,
        loadingPromise: null,
      };

      function primeManualPaymentMovesCache(rows = []) {
        const map = new Map();
        (rows || []).forEach(row => {
          if (!row || row.student_id == null) return;
          const key = String(row.student_id);
          if (!map.has(key)) {
            map.set(key, []);
          }
          map.get(key).push({
            id: row.id,
            fromDate: row.from_date,
            toDate: row.to_date,
            amount: Number(row.amount) || 0,
            createdAt: row.created_at,
            createdBy: row.created_by,
          });
        });

        map.forEach(list => {
          list.sort((a, b) => {
            const aCreated = a.createdAt || '';
            const bCreated = b.createdAt || '';
            return aCreated.localeCompare(bCreated);
          });
        });

        manualPaymentMovesState.byStudentId = map;
        manualPaymentMovesState.lastFetched = Date.now();
      }

      function getManualMovesForStudent(studentId) {
        if (!studentId && studentId !== 0) return [];
        const key = String(studentId);
        const entries = manualPaymentMovesState.byStudentId.get(key);
        return Array.isArray(entries) ? [...entries] : [];
      }

      async function loadManualPaymentMovesFromSupabase(force = false) {
        try {
          const now = Date.now();
          const cacheIsFresh =
            manualPaymentMovesState.byStudentId.size > 0 &&
            now - manualPaymentMovesState.lastFetched < MANUAL_PAYMENT_MOVES_CACHE_TTL_MS;

          if (!force && cacheIsFresh) {
            return manualPaymentMovesState.byStudentId;
          }

          if (!force && manualPaymentMovesState.loadingPromise) {
            return manualPaymentMovesState.loadingPromise;
          }

          if (!window.supabase) {
            console.warn('Supabase client unavailable; manual payment moves cannot be loaded.');
            manualPaymentMovesState.byStudentId = new Map();
            manualPaymentMovesState.lastFetched = now;
            return manualPaymentMovesState.byStudentId;
          }

          const loaderPromise = (async () => {
            const { data, error } = await supabaseClient
              .from(MANUAL_PAYMENT_MOVES_TABLE)
              .select('id, student_id, from_date, to_date, amount, created_at, created_by')
              .order('created_at', { ascending: true });

            if (error) {
              throw error;
            }

            primeManualPaymentMovesCache(data || []);
            return manualPaymentMovesState.byStudentId;
          })();

          manualPaymentMovesState.loadingPromise = loaderPromise
            .catch(err => {
              console.error('‚ùå Failed to load manual payment moves:', err);
              showErrorToast?.('‚ùå Failed to load manual payment moves from Supabase');
              return manualPaymentMovesState.byStudentId;
            })
            .finally(() => {
              manualPaymentMovesState.loadingPromise = null;
            });

          return manualPaymentMovesState.loadingPromise;
        } catch (error) {
          console.error('‚ùå Unexpected error loading manual payment moves:', error);
          return manualPaymentMovesState.byStudentId;
        }
      }

      async function recordManualPaymentMove(studentId, fromDate, toDate, amount) {
        if ((!studentId && studentId !== 0) || !fromDate || !toDate) {
          throw new Error('Missing information for manual payment move');
        }
        if (!window.supabase) {
          throw new Error('Supabase client not initialized');
        }

        const numericStudentId = Number(studentId);
        if (!Number.isFinite(numericStudentId)) {
          throw new Error('Invalid student selected for payment move');
        }

        const normalizedAmount = Number(amount) || 0;
        const payload = {
          student_id: numericStudentId,
          from_date: fromDate,
          to_date: toDate,
          amount: normalizedAmount,
        };

        const { data, error } = await supabaseClient
          .from(MANUAL_PAYMENT_MOVES_TABLE)
          .upsert(payload, { onConflict: 'student_id,from_date,to_date' })
          .select()
          .single();

        if (error) {
          throw new Error(error.message || 'Failed to store manual payment move');
        }

        const entryId = data?.id || `${numericStudentId}-${fromDate}-${toDate}`;
        const cacheKey = String(numericStudentId);
        const existingMoves = manualPaymentMovesState.byStudentId.get(cacheKey) || [];
        const remaining = existingMoves.filter(move => !(move.fromDate === fromDate && move.toDate === toDate));
        remaining.push({
          id: entryId,
          fromDate,
          toDate,
          amount: normalizedAmount,
          createdAt: data?.created_at || new Date().toISOString(),
          createdBy: data?.created_by || null,
        });
        manualPaymentMovesState.byStudentId.set(cacheKey, remaining);
        manualPaymentMovesState.lastFetched = Date.now();
        return data;
      }

      function applyManualMovesToAllocation(student, allocation, pricePerClass) {
        if (!student || !allocation) return allocation;
        const studentId = student.id != null ? String(student.id) : null;
        if (!studentId) return allocation;

        const moves = getManualMovesForStudent(studentId);
        if (!moves.length) return allocation;

        moves.forEach(move => {
          if (!move || !move.fromDate || !move.toDate) return;
          // Only support manual moves inside December 2025 (allocation revamp window)
          const isDecemberWindow = move.fromDate.startsWith('2025-12') && move.toDate.startsWith('2025-12');
          if (!isDecemberWindow) return;

          const moveAmount = Number(move.amount) || Number(pricePerClass) || 0;
          // Force source class to unpaid
          const fromEntry = allocation[move.fromDate] || (allocation[move.fromDate] = {});
          fromEntry.isPaid = false;
          fromEntry.allocatedAmount = 0;
          fromEntry.owedAmount = moveAmount;
          fromEntry.manualOverride = 'moved-out';

          // Force destination class to paid
          const toEntry = allocation[move.toDate] || (allocation[move.toDate] = {});
          toEntry.isPaid = true;
          toEntry.allocatedAmount = moveAmount;
          toEntry.owedAmount = 0;
          toEntry.manualOverride = 'moved-in';
        });

        return allocation;
      }

      function getMonthCacheKey(year, month) {
        return `${year}-${String(month + 1).padStart(2, '0')}`;
      }

      function clearMonthCache() {
        monthCache.clear();
        invalidateIndexCaches(); // ‚ö° PERFORMANCE: Also clear index caches when data changes
        if (DataCache && DataCache.monthData && typeof DataCache.monthData.clear === 'function') {
          DataCache.monthData.clear();
        }
      }

      async function getMonthData(year, month) {
        const cacheKey = getMonthCacheKey(year, month);
        if (monthCache.has(cacheKey)) {
          return monthCache.get(cacheKey);
        }

        const computed = await computeMonthData(year, month);
        monthCache.set(cacheKey, computed);
        return computed;
      }

      // Helper function to get student visibility threshold (when they should start appearing)
      function getStudentVisibilityThreshold(record) {
        const created = normalizeDateInput(
          record?.created_at || record?.start_date || record?.startDate || record?.joined_at || record?.joinedAt
        );
        return created || CALENDAR_START_DATE_STR;
      }

      async function computeMonthData(year, month) {
        // Reset payment allocation tracker for fresh calculation
        resetPaymentAllocation();
        
        /* ================================================================
           üõ°Ô∏è DATA INTEGRITY SAFEGUARDS
           ================================================================
           
           ISSUE 1: Orphan Data (Unused Cache)
           ‚úÖ PROTECTED: clearMonthCache() is called after EVERY data mutation
           ‚úÖ PROTECTED: computeMonthData() creates FRESH structures every time
           ‚úÖ PROTECTED: Uses latest window.studentsCache, groupsCache, paymentsCache
           ‚Üí No stale data: when cache is cleared, this function rebuilds from source
           
           ISSUE 2: Payment Duplication (Logic Bug)
           ‚úÖ PROTECTED: This function is IDEMPOTENT - always rebuilds from scratch
           ‚úÖ PROTECTED: dayMap is created fresh (line 3808), NOT mutated
           ‚úÖ PROTECTED: Payment matching uses Set() to prevent duplicates
           ‚úÖ PROTECTED: Each render clears cache and re-computes, no accumulation
           ‚Üí No duplicates: same payment ID can't be linked twice in one month
           
           ISSUE 3: Inaccurate Payment Summaries
           ‚úÖ PROTECTED: Payments matched by BOTH date AND student ID
           ‚úÖ PROTECTED: buildPaymentIndexes() creates studentId ‚Üí payments map
           ‚úÖ PROTECTED: Only payments for scheduled students are counted
           ‚úÖ PROTECTED: Summary calculated from matched payments, not raw count
           ‚Üí Accurate totals: payment must belong to student in that class
           
           ISSUE 4: Timezone/Date Mismatch
           ‚úÖ PROTECTED: ALL dates use Date.UTC() via createDateFromParts()
           ‚úÖ PROTECTED: ALL formatting uses getLAParts() for LA timezone
           ‚úÖ PROTECTED: Comparison uses YYYY-MM-DD strings (consistent format)
           ‚úÖ PROTECTED: UTC midnight dates with 12:00 noon prevent edge cases
           ‚Üí No timezone bugs: UTC storage + LA display, consistent everywhere
           
           ================================================================ */
        const cacheKey = getMonthCacheKey(year, month);
        const label = `${monthNames[month]} ${year}`;
        const daysInMonth = new Date(year, month + 1, 0).getDate();
        const firstDayDate = createDateFromParts(year, month, 1);
        const firstDay = getLAWeekdayIndex(firstDayDate) ?? 0;
        const todayParts = getTodayLAParts();
        const todayStr = todayParts ? formatDateYYYYMMDD(createDateFromParts(
          Number(todayParts.year),
          Number(todayParts.month) - 1,
          Number(todayParts.day)
        )) : formatDateYYYYMMDD(new Date());

        const dayMap = {};
        for (let day = 1; day <= daysInMonth; day++) {
          const dateObj = createDateFromParts(year, month, day);
          const dateStr = formatDateYYYYMMDD(dateObj);
          const weekdayIndex = getLAWeekdayIndex(dateObj);
          dayMap[day] = {
            date: dateObj,
            dateStr,
            weekdayIndex: weekdayIndex ?? dateObj.getUTCDay(),
            groups: [],
            payments: [],
            credits: [],
            studentEvents: [],
            fuchsiaDots: [], // Initialize fuchsia dots array
            stats: {
              classes: 0,
              payments: 0,
              credits: 0,
              absences: 0,
              skipped: 0,
            },
            totals: {
              paid: 0,
              unpaid: 0,
            },
            indicators: new Set(),
          };
        }

        const aggregates = {
          classes: 0,
          payments: 0,
          credits: 0,
          absenceCount: 0,
          skippedCount: 0,
          activeStudents: 0,
        };

        const eventsFlat = [];
        const students = window.studentsCache || [];
        const groups = window.groupsCache || [];
        const payments = window.paymentsCache || [];
        const creditLookup = creditPaymentsLookup || {};

    // ‚ö° PERFORMANCE: Use cached indexes to avoid recalculating on every month render
    // Only rebuild if student/payment data actually changed
    const studentsChanged = students.length !== lastStudentsCacheSize;
    const paymentsChanged = payments.length !== lastPaymentsCacheSize;
    
    if (!cachedStudentIndexes || studentsChanged) {
      cachedStudentIndexes = buildStudentIndexes(students);
      cachedStudentsByGroup = buildStudentsByGroup(students);
      lastStudentsCacheSize = students.length;
      debugLog('‚ö° Rebuilt student indexes:', students.length, 'students');
    }
    
    if (!cachedPaymentIndexes || paymentsChanged || studentsChanged) {
      cachedPaymentIndexes = buildPaymentIndexes(payments, cachedStudentIndexes);
      lastPaymentsCacheSize = payments.length;
      debugLog('‚ö° Rebuilt payment indexes:', payments.length, 'payments');
    }
    
    const studentIndexes = cachedStudentIndexes;
    const studentsByGroup = cachedStudentsByGroup;
    const paymentIndexes = cachedPaymentIndexes;
    
    // üîß FIX: Make studentsByGroup globally accessible for modal/debugging
    window.studentsByGroup = studentsByGroup;
    
    aggregates.activeStudents = studentIndexes.activeIds.size;
    const creditEventsByDate = buildCreditEventsByDate(creditLookup, studentIndexes.byId);
    const ambiguousPaymentAllocations = [];
    window.excessPaymentsForCredit = [];

        // Track payment IDs that have been allocated to classes
        // This prevents payments from showing twice (once on class, once on payment date)
        const allocatedPaymentIds = new Set();

        // ============================================================
        // üé® GRAY DOT LOGIC - PURE SCHEDULE ONLY (December 1+)
        // ============================================================
        addScheduledClassDots(groups, aggregates);

        // ============================================================
        // üî¥ FUCHSIA DOT LOGIC - Misallocated Payments
        // ============================================================
        // Show fuchsia dots for payments where for_class doesn't match any scheduled class
        await addMisallocatedPaymentDots();

        const totals = Object.values(dayMap).reduce(
          (acc, entry) => {
            acc.paid += entry.totals.paid;
            acc.unpaid += entry.totals.unpaid;
            debugLog(`üìä Day totals aggregation - Day has paid: ${entry.totals.paid}$, unpaid: ${entry.totals.unpaid}$ | Running total: paid ${acc.paid}$, unpaid ${acc.unpaid}$`);
            return acc;
          },
          { paid: 0, unpaid: 0 }
        );
        
        debugLog(`üìà FINAL MONTH TOTALS: Paid ${totals.paid}$, Unpaid ${totals.unpaid}$`);

        const monthData = {
          key: cacheKey,
          year,
          month,
          firstDay,
          daysInMonth,
          dayMap,
          aggregates: {
            classes: aggregates.classes,
            payments: aggregates.payments,
            credits: aggregates.credits,
            absences: aggregates.absenceCount,
            skipped: aggregates.skippedCount,
            activeStudents: aggregates.activeStudents,
          },
          totals,
          eventsFlat,
          ambiguousPaymentAllocations: [],
          paymentAllocationSource: [],
          paymentAllocationMeta: { total: 0, unresolved: 0, resolved: 0 },
        };
        
        // Log payment matching statistics
        let matchedPayments = 0;
        let unmatchedPayments = 0;
        Object.values(dayMap).forEach(day => {
          (day.groups || []).forEach(group => {
            (group.students || []).forEach(student => {
              if (student.status === 'paid' || student.status === 'credit') {
                matchedPayments++;
              } else if (student.status === 'unpaid' && day.dateStr <= todayStr) {
                unmatchedPayments++;
              }
            });
          });
        });

        const unresolvedAllocations = filterResolvedPaymentAllocations(ambiguousPaymentAllocations);
        const resolvedCount = ambiguousPaymentAllocations.length - unresolvedAllocations.length;
        monthData.ambiguousPaymentAllocations = unresolvedAllocations;
        monthData.paymentAllocationSource = ambiguousPaymentAllocations;
        monthData.paymentAllocationMeta = {
          total: ambiguousPaymentAllocations.length,
          unresolved: unresolvedAllocations.length,
          resolved: resolvedCount,
        };

        if (resolvedCount > 0) {
          debugLog(
            `‚ÑπÔ∏è Skipped ${resolvedCount} previously reviewed payment allocation${resolvedCount === 1 ? '' : 's'}.`
          );
        }

        if (unresolvedAllocations.length) {
          window.paymentAllocationAlerts = unresolvedAllocations;
          // Payment allocation alerts handled by UI drawer
          // console.group('‚ö†Ô∏è Payment allocation requires review');
          // const sample = unresolvedAllocations.slice(0, 25);
          // sample.forEach(entry => {
          //   console.warn(
          //     `Student ${entry.studentName || entry.studentId} has $${entry.amount.toFixed(2)} from payment on ${entry.payDate || 'unknown date'} that could not be assigned between Nov 1 and today.`
          //   );
          // });
          // if (unresolvedAllocations.length > sample.length) {
          //   console.warn(
          //     `+${unresolvedAllocations.length - sample.length} additional payment${unresolvedAllocations.length - sample.length === 1 ? '' : 's'} require review. Use the on-screen review drawer to inspect all of them.`
          //   );
          // }
          // console.groupEnd();
        } else {
          window.paymentAllocationAlerts = [];
        }

        notifyPaymentAllocationReview(unresolvedAllocations, cacheKey, ambiguousPaymentAllocations);

        return monthData;

        // ===== Helper Functions (scoped to computeMonthData) =====

        function normalizeNameKey(value) {
          if (!value) return '';
          
          return value
            .toString()
            .trim()
            .toLowerCase()
            // Normalize Unicode characters (handles accents, Armenian, Cyrillic, etc.)
            .normalize('NFD')
            .replace(/[\u0300-\u036f]/g, '') // Remove diacritics/accents
            // Keep letters (including Unicode), numbers, and spaces - remove only punctuation
            .replace(/[^\p{L}\p{N}\s]/gu, '')
            .replace(/\s+/g, ''); // Remove ALL spaces for consistent matching
        }

        function parseAliasList(value) {
          if (!value) return [];
          if (Array.isArray(value)) return value;
          if (typeof value === 'string') {
            const trimmed = value.trim();
            if (trimmed.startsWith('[') || trimmed.startsWith('{')) {
              try {
                const parsed = JSON.parse(trimmed);
                if (Array.isArray(parsed)) {
                  return parsed.map(entry => (typeof entry === 'string' ? entry.trim() : entry)).filter(Boolean);
                }
              } catch (err) {
                // Not valid JSON, fall back to delimiter parsing
              }
            }
            if (trimmed.includes('|||')) return trimmed.split('|||').map(v => v.trim()).filter(Boolean);
            if (trimmed.includes(',')) return trimmed.split(',').map(v => v.trim()).filter(Boolean);
            return [trimmed];
          }
          return [];
        }

        function shouldIncludeStudent(student) {
          if (!student) return false;
          
          // Check calendar visibility flag (show_in_grid from database)
          // Only exclude if explicitly set to false (undefined means include)
          if (student.show_in_grid === false) {
            debugLog(`üö´ Student ${student.name} excluded: show_in_grid=${student.show_in_grid}`);
            return false;
          }
          
          // Exclude graduated/archived/inactive students
          const status = (student.status || '').toLowerCase().trim();
          const excludedStatuses = ['graduated', 'archived', 'inactive', 'deleted'];
          
          if (excludedStatuses.includes(status)) {
            debugLog(`üö´ Student ${student.name} excluded: status=${status}`);
            return false;
          }
          
          // Note: Paused students are INCLUDED but marked differently
          // They will show in calendar but won't generate unpaid warnings
          
          return true;
        }

        function getNameKeysForStudent(record) {
          const keys = new Set();
          if (!record) return keys;

          const directName = normalizeNameKey(record.name || record.student_name);
          if (directName) keys.add(directName);

          const aliasFields = [record.aliases, record.alias_list, record.alias];
          aliasFields.forEach(value => {
            parseAliasList(value).forEach(alias => {
              const key = normalizeNameKey(alias);
              if (key) keys.add(key);
            });
          });

          [record.parent_name, record.guardian_name, record.payer_name, record.payer]
            .filter(Boolean)
            .forEach(value => {
              const key = normalizeNameKey(value);
              if (key) keys.add(key);
            });

          return keys;
        }

        function buildStudentIndexes(rawStudents) {
          const byId = new Map();
          const nameToId = new Map();
          const activeIds = new Set();

          rawStudents.forEach(student => {
            const idKey = student && student.id != null ? String(student.id) : null;
            if (idKey) {
              byId.set(idKey, student);
            }

            if (!shouldIncludeStudent(student)) return;

            if (idKey) {
              activeIds.add(idKey);
            }

            const normalizedName = normalizeNameKey(student.name);
            if (normalizedName && idKey && !nameToId.has(normalizedName)) {
              nameToId.set(normalizedName, idKey);
            }

            parseAliasList(student.aliases).forEach(alias => {
              const aliasKey = normalizeNameKey(alias);
              if (aliasKey && idKey && !nameToId.has(aliasKey)) {
                nameToId.set(aliasKey, idKey);
              }
            });
          });

          return { byId, nameToId, activeIds };
        }

        function deriveStudentGroups(student) {
          const primarySources = [student.group_code, student.group_display, student.group_name, student.group, student.groupName];
          const extra = Array.isArray(student.groups) ? student.groups : [];
          const combined = [...primarySources, ...extra]
            .map(value => (value === 'ungrouped' ? 'ungrouped' : canonicalizeGroupCode(value)))
            .filter(Boolean);

          if (combined.length === 0) return ['ungrouped'];
          return Array.from(new Set(combined));
        }

        function normalizeGroupKey(value) {
          if (!value || value === 'ungrouped') return 'ungrouped';
          const normalized = canonicalizeGroupCode(value);
          return normalized || 'ungrouped';
        }

        function buildStudentsByGroup(rawStudents) {
          const map = {};
          rawStudents.forEach(student => {
            if (!shouldIncludeStudent(student)) return;
            deriveStudentGroups(student).forEach(groupName => {
              const key = normalizeGroupKey(groupName);
              if (!map[key]) map[key] = [];
              map[key].push(student);
            });
          });
          return map;
        }

        function getStudentPricePerClass(student, group) {
          const fromStudent = student.price_per_class || student.pricePerClass || student.pay_per_class;
          if (fromStudent) return Number(fromStudent) || 0;
          if (group && group.price_per_class) return Number(group.price_per_class) || 0;
          return 0;
        }

        function getStudentBalance(student) {
          const balanceFields = [
            student.balance,
            student.credit_balance,
            student.balance_amount,
            student.creditBalance,
          ];
          const value = balanceFields.find(v => v !== undefined && v !== null);
          return Number(value) || 0;
        }

        function buildPaymentIndexes(rawPayments, indexes) {
          const byDate = {};
          const byStudentDate = {};
          const byNameDate = {};

          (rawPayments || []).forEach(payment => {
            const dateStr = extractDateStr(payment);
            if (!dateStr) return;

            const studentId = resolveStudentIdForPayment(payment, indexes);
            const studentEntry = studentId ? indexes.byId.get(studentId) : null;
            const studentName =
              studentEntry?.name ||
              payment.student_name ||
              payment.studentName ||
              payment.resolved_student_name ||
              payment.payer_name ||
              payment.payer ||
              payment.payer_name_raw ||
              '';
            const amount = Number(payment.amount) || 0;

            const entry = {
              id: payment.id || payment.gmail_id || `${dateStr}-${Math.random().toString(36).slice(2, 8)}`,
              studentId,
              studentName,
              amount,
              payerName: payment.payer_name || payment.payer || payment.payer_name_raw || '',
              memo: payment.memo || payment.message || '',
              raw: payment,
            };

            if (!byDate[dateStr]) byDate[dateStr] = [];
            byDate[dateStr].push(entry);

            if (studentId) {
              if (!byStudentDate[studentId]) byStudentDate[studentId] = {};
              if (!byStudentDate[studentId][dateStr]) byStudentDate[studentId][dateStr] = [];
              byStudentDate[studentId][dateStr].push(entry);
            }

            const nameKeys = new Set();
            [
              studentEntry?.name,
              payment.student_name,
              payment.studentName,
              payment.resolved_student_name,
              payment.payer_name,
              payment.payer,
              payment.payer_name_raw,
              payment.sender_name,
            ]
              .filter(Boolean)
              .forEach(value => {
                const key = normalizeNameKey(value);
                if (key) nameKeys.add(key);
              });

            // Include aliases stored on the payment record if present
            if (payment.aliases && Array.isArray(payment.aliases)) {
              payment.aliases.forEach(alias => {
                const key = normalizeNameKey(alias);
                if (key) nameKeys.add(key);
              });
            }

            nameKeys.forEach(key => {
              if (!byNameDate[key]) byNameDate[key] = {};
              if (!byNameDate[key][dateStr]) byNameDate[key][dateStr] = [];
              byNameDate[key][dateStr].push(entry);
            });
          });

          return { byDate, byStudentDate, byNameDate };

          function extractDateStr(payment) {
            const source = payment.email_date || payment.emailDate || payment.date || payment.created_at;
            if (!source) return '';
            
            // CRITICAL: ALL payment dates MUST be converted to LA timezone
            // We cannot just extract the date portion from ISO strings because
            // "2025-11-23T05:05:51+00:00" in UTC could be "2025-11-22" in LA time
            
            const sourceStr = String(source);
            
            // If it's already in simple YYYY-MM-DD format (no time component), use as-is
            if (/^\d{4}-\d{2}-\d{2}$/.test(sourceStr) && !sourceStr.includes('T')) {
              return sourceStr;
            }
            
            // For any date with time information, convert to LA timezone
            // This handles ISO strings, timestamps, and Date objects
            return normalizeDateInput(source);
          }
        }

        function resolveStudentIdForPayment(payment, indexes) {
          // Step 1: Try direct ID matches
          const candidateIds = [
            payment.student_id,
            payment.studentid,
            payment.linked_student_id,
            payment.derived_student_id,
          ].filter(Boolean);

          for (const candidate of candidateIds) {
            const key = String(candidate);
            if (indexes.byId.has(key)) {
              return key;
            }
          }

          // Step 2: Try name matching (student_name, resolved_student_name)
          const studentKey = normalizeNameKey(payment.student_name || payment.studentName || payment.resolved_student_name);
          if (studentKey && indexes.nameToId.has(studentKey)) {
            return indexes.nameToId.get(studentKey);
          }

          // Step 3: Try payer name matching
          const payerKey = normalizeNameKey(payment.payer_name || payment.payer || payment.payer_name_raw);
          if (payerKey && indexes.nameToId.has(payerKey)) {
            return indexes.nameToId.get(payerKey);
          }

          // Step 4: Try email matching
          const paymentEmail = payment.student_email || payment.email || payment.payer_email;
          if (paymentEmail) {
            const normalizedEmail = paymentEmail.toLowerCase().trim();
            // Search through all students for email match
            for (const [studentId, student] of indexes.byId) {
              const studentEmail = student.email || student.student_email;
              if (studentEmail && studentEmail.toLowerCase().trim() === normalizedEmail) {
                return studentId;
              }
            }
          }

          return null;
        }

        function buildCreditEventsByDate(lookup, studentMap) {
          const byDate = {};
          Object.keys(lookup || {}).forEach(studentId => {
            const studentRecords = lookup[studentId];
            Object.keys(studentRecords || {}).forEach(dateStr => {
              const record = studentRecords[dateStr];
              if (!byDate[dateStr]) byDate[dateStr] = [];
              byDate[dateStr].push({
                studentId,
                studentName: studentMap.get(studentId)?.name || 'Unknown Student',
                amount: Number(record.amount) || 0,
                balance: record.balance_after ?? null,
              });
            });
          });
          return byDate;
        }

        function normalizePaymentDate(payment) {
          if (!payment) return '';
          
          // CRITICAL: Use email_date for automated payments (contains actual payment timestamp)
          // This is the Gmail email delivery time which reflects when payment was sent
          // NOTE: for_class is ONLY for manual payment reassignment, NOT for display
          const source =
            payment.email_date ||
            payment.emailDate ||
            payment.payDate ||
            payment.payment_date ||
            payment.date ||
            payment.timestamp ||
            payment.created_at ||
            payment.raw?.email_date ||
            payment.raw?.date;
          if (!source) return '';
          
          try {
            // Parse the timestamp and convert to LA timezone
            const date = new Date(source);
            if (isNaN(date.getTime())) return '';
            
            // Use LA timezone formatter to get the correct date
            const parts = getLAParts(date);
            if (!parts) return '';
            
            const result = `${parts.year}-${parts.month}-${parts.day}`;
            
            // DEBUG: Log payment date conversion for Dec 17-18
            if (result === '2024-12-17' || result === '2024-12-18') {
              console.log('üîç PAYMENT DATE DEBUG:', {
                payer: payment.payer_name || payment.resolved_student_name,
                source_timestamp: source,
                utc_date: date.toISOString(),
                la_result: result,
                la_parts: parts,
                for_class: payment.for_class
              });
            }
            
            return result;
          } catch (e) {
            debugLog('‚ö†Ô∏è Error parsing payment date:', e);
            return '';
          }
        }

        function extractPaymentTime(payment) {
          if (!payment) return '';
          
          // Priority order: email_date (actual payment time from email) > created_at > date (usually midnight)
          const source =
            payment.email_date ||
            payment.emailDate ||
            payment.created_at ||
            payment.timestamp ||
            payment.date;
          
          if (!source) return '';
          
          // Convert to Date object and format in LA timezone
          try {
            const date = new Date(source);
            if (isNaN(date.getTime())) return '';
            
            // Use LA timezone formatter for time display
            return formatTimeInLA(date);
          } catch (err) {
            debugLog('‚ö†Ô∏è Error extracting payment time:', err);
            return '';
          }
        }

        function normalizeSimpleName(value) {
          if (!value) return '';
          return normalizeNameKey(value);
        }

        function getStudentAliasNames(student) {
          const aliasFields = [
            student?.aliases,
            student?.alias_list,
            student?.alias,
            student?.parent_name,
            student?.guardian_name,
            student?.payer_name,
            student?.payer,
          ];
          const names = new Set();
          aliasFields.forEach(value => {
            // Accept both arrays and delimited strings
            const list = Array.isArray(value) ? value : parseAliasList(value);
            list.forEach(alias => {
              const normalized = normalizeSimpleName(alias);
              if (normalized) names.add(normalized);
            });
          });
          return Array.from(names);
        }

        function getStudentPaymentCacheKeys(student) {
          const keys = [];
          if (student?.id != null) {
            keys.push(`id:${student.id}`);
          }
          const normalizedName = normalizeSimpleName(student?.name || student?.student_name);
          if (normalizedName) {
            keys.push(`name:${normalizedName}`);
          }
          return keys;
        }

        function collectPaymentsForStudentSimple(student) {
          if (!student) return [];

          const cacheKeys = getStudentPaymentCacheKeys(student);
          const existingKey = cacheKeys.find(key => studentPaymentMatchCache.has(key));
          if (existingKey) {
            return studentPaymentMatchCache.get(existingKey);
          }

          const matchNames = new Set();
          const studentName = normalizeSimpleName(student?.name || student?.student_name);
          if (studentName) {
            matchNames.add(studentName);
          }
          getStudentAliasNames(student).forEach(alias => matchNames.add(alias));

          const idKey = student?.id != null ? String(student.id) : null;
          
          // Targeted debug for Taguhi Barseghyan (ID: 41)
          const isTaguhiBarseghyan = (student.name === 'Taguhi Barseghyan' || idKey === '41');
          
          // 1. Collect regular payments from payments table
          const matchedPayments = (window.paymentsCache || [])
            .filter(payment => doesPaymentBelongToStudent(payment, idKey, matchNames))
            .map(payment => {
              const dateStr = normalizePaymentDate(payment);
              if (!dateStr) return null;
              const amount =
                Number(payment.amount) ||
                Number(payment.amountUSD) ||
                Number(payment.amount_paid_usd) ||
                Number(payment.total) ||
                0;
              const paymentId =
                payment.id ||
                payment.gmail_id ||
                payment.payment_id ||
                payment.resend_id ||
                payment.record_id ||
                `payment-${dateStr}-${Math.random().toString(36).slice(2, 8)}`;
              
              // Extract payment time from created_at timestamp
              const timeStr = extractPaymentTime(payment);
              
              // CRITICAL: Extract for_class date (allocated class date)
              const forClass = payment.for_class ? normalizeDateInput(payment.for_class) : null;
              
              return {
                id: paymentId,
                amount,
                dateStr,  // Receipt date (when payment was received)
                forClass, // Allocated class date (from for_class column)
                timeStr,  // Add time string (e.g., "9:13 AM")
                raw: payment,
                source: 'payment', // Mark as regular payment
              };
            })
            .filter(Boolean);
          
          // 2. Add credit payments from credit_payments table
          if (idKey && creditPaymentsLookup && creditPaymentsLookup[idKey]) {
            const creditPaymentsForStudent = creditPaymentsLookup[idKey] || {};
            Object.keys(creditPaymentsForStudent).forEach(dateStr => {
              const creditPayment = creditPaymentsForStudent[dateStr];
              const timeStr = extractPaymentTime(creditPayment);
              
              matchedPayments.push({
                id: `credit-${idKey}-${dateStr}`,
                amount: Number(creditPayment.amount) || 0,
                dateStr: dateStr,
                timeStr,  // Add time for credit payments too
                raw: creditPayment,
                source: 'credit', // Mark as credit payment
              });
            });
          }

          if (cacheKeys.length) {
            cacheKeys.forEach(key => {
              studentPaymentMatchCache.set(key, matchedPayments);
            });
          }
          
          // Targeted summary for Taguhi
          if (isTaguhiBarseghyan) {
            matchedPayments.forEach((p, i) => {
              // Debug placeholder - can add logging here if needed
            });
          }
          
          return matchedPayments;
        }

        function doesPaymentBelongToStudent(payment, idKey, matchNames) {
          if (!payment || payment.ignored) return false;

          if (idKey) {
            // CRITICAL: Check linked_student_id FIRST (many payments have student_id=NULL but linked_student_id populated)
            const candidateIds = [
              payment.linked_student_id,      // Check this FIRST
              payment.student_id,              // Then check student_id
              payment.studentid,
              payment.studentId,
              payment.derived_student_id,
            ]
              .map(value => (value != null ? String(value) : null))
              .filter(Boolean);
            
            const matched = candidateIds.includes(idKey);
            
            // COMPREHENSIVE DEBUG: Log ALL payment matching attempts
            debugLog(`  üîé Payment Match Check:
       Payment ID: ${payment.id}
       Looking for student ID: ${idKey}
       payment.student_id: ${payment.student_id}
       payment.linked_student_id: ${payment.linked_student_id}
       payment.for_class: ${payment.for_class}
       payment.payer_name: ${payment.payer_name}
       Candidate IDs: [${candidateIds.join(', ')}]
       ‚úÖ MATCHED: ${matched}`);
            
            if (matched) {
              return true;
            }
          }

          if (!matchNames || !matchNames.size) return false;

          const paymentNames = [
            payment.student_name,
            payment.studentName,
            payment.resolved_student_name,
            payment.payer_name,
            payment.payerName,
            payment.payer,
            payment.payer_name_raw,
            payment.sender_name,
          ]
            .map(normalizeSimpleName)
            .filter(Boolean);

          // Direct exact-name match
          if (paymentNames.some(name => matchNames.has(name))) return true;

          // Alias array on payment record
          if (Array.isArray(payment.aliases)) {
            const paymentAliasNames = payment.aliases.map(normalizeSimpleName).filter(Boolean);
            if (paymentAliasNames.some(name => matchNames.has(name))) return true;
          }

          // Fuzzy match: contains/startsWith to catch common variations
          for (const payName of paymentNames) {
            for (const alias of matchNames) {
              if (!payName || !alias) continue;
              if (payName.includes(alias) || alias.includes(payName)) {
                return true;
              }
            }
          }

          // Token-based fuzzy match: require at least 2 overlapping tokens (first/last names)
          function tokenize(name) {
            return String(name)
              .split(/\s+/)
              .map(s => s.trim())
              .filter(Boolean);
          }
          for (const payName of paymentNames) {
            const payTokens = new Set(tokenize(payName));
            if (!payTokens.size) continue;
            for (const alias of matchNames) {
              const aliasTokens = tokenize(alias);
              let overlap = 0;
              for (const t of aliasTokens) {
                if (payTokens.has(t)) overlap++;
              }
              if (overlap >= 2) {
                return true;
              }
            }
          }

          return false;
        }

        // ============================================================
        // üí∞ REVERSE CHRONOLOGICAL PAYMENT ALLOCATION (December 2025)
        // Most recent payments cover most recent classes first
        // ============================================================
        
        function getAllDecemberClassDates(student, groupList) {
          const dates = [];
          const studentId = student.id != null ? String(student.id) : null;
          
          // Get today's date in LA timezone
          const todayParts = getTodayLAParts();
          const todayStr = todayParts ? formatDateYYYYMMDD(createDateFromParts(
            Number(todayParts.year),
            Number(todayParts.month) - 1,
            Number(todayParts.day)
          )) : formatDateYYYYMMDD(new Date());
          
          groupList.forEach(groupRecord => {
            const occurrences = generateGroupOccurrences(groupRecord);
            occurrences.forEach(occurrence => {
              // Only include December 2025 classes UP TO TODAY (not future classes)
              if (!occurrence.dateStr.startsWith('2025-12')) return;
              if (occurrence.dateStr > todayStr) return; // SKIP FUTURE CLASSES
              
              // Check if student is in this group
              const groupNameRaw = groupRecord.group_name || groupRecord.name;
              const groupCode = groupRecord.group_code || canonicalizeGroupCode(groupNameRaw);
              const canonicalKey = groupCode || 'ungrouped';
              const fallbackKey = normalizeGroupKey(groupNameRaw);
              
              const isInGroup = (studentsByGroup[canonicalKey] || studentsByGroup[fallbackKey] || [])
                .some(s => String(s.id) === studentId || s.name === student.name);
              
              if (!isInGroup) return;
              
              // Check visibility (student must have existed on this date)
              const studentCreationDateStr = getStudentVisibilityThreshold(student);
              if (occurrence.dateStr < studentCreationDateStr) return;
              if (occurrence.dateStr < CALENDAR_START_DATE_STR) return;
              
              // ‚úÖ CHANGED: Include canceled classes (don't filter them out)
              // Check if class was canceled (but still include it in the list)
              const skipInfo = getSkipInfoForGroup(groupNameRaw, occurrence.dateStr);
              // Removed: if (skipInfo && skipInfo.type === 'class-canceled') return;
              
              dates.push(occurrence.dateStr);
            });
          });
          
          // Remove duplicates and sort oldest ‚Üí newest
          return [...new Set(dates)].sort();
        }
        
        function allocateDecemberPayments(student, groupList) {
          const studentId = student.id != null ? String(student.id) : null;
          const cacheKey = `${studentId}-2025-12`;
          
          // Check cache
          if (studentAllocationCache.has(cacheKey)) {
            return studentAllocationCache.get(cacheKey);
          }
          
          // Get all December 2025 class dates for this student
          const classDates = getAllDecemberClassDates(student, groupList);
          if (!classDates.length) return {};
          
          // Get all December 2025 payments for this student
          const allPayments = collectPaymentsForStudentSimple(student);
          const decemberPayments = allPayments.filter(p => 
            p.dateStr && p.dateStr >= '2025-12-01' && p.dateStr < '2026-01-01'
          );
          
          // Sum total money paid in December
          let totalMoney = decemberPayments.reduce((sum, p) => sum + (p.amount || 0), 0);
          
          // Get class price (each unpaid class costs this much)
          const pricePerClass = Number(student.price_per_class) || Number(student.pricePerClass) || 0;
          if (pricePerClass <= 0) return {};
          
          // Sort dates newest ‚Üí oldest for reverse chronological allocation
          const sortedDates = [...classDates].sort().reverse();
          
          // Allocation map: { "2025-12-07": { isPaid: true, allocatedAmount: 50 } }
          const allocation = {};
          
          // Walk backward from newest to oldest
          // Each class needs exactly pricePerClass to be marked as PAID
          for (const dateStr of sortedDates) {
            if (totalMoney >= pricePerClass) {
              // Enough money to cover this class - mark as PAID (green)
              allocation[dateStr] = {
                isPaid: true,
                allocatedAmount: pricePerClass,  // Exactly one class worth
                remainingBalance: totalMoney - pricePerClass
              };
              totalMoney -= pricePerClass;  // Subtract one class price
            } else {
              // Not enough money left - mark as UNPAID (red)
              // This class costs pricePerClass but we don't have enough
              allocation[dateStr] = {
                isPaid: false,
                allocatedAmount: 0,
                remainingBalance: totalMoney,
                owedAmount: pricePerClass  // Student owes this much for this class
              };
            }
          }
          
          applyManualMovesToAllocation(student, allocation, pricePerClass);

          // Cache the result
          studentAllocationCache.set(cacheKey, allocation);
          
          if (DEBUG_MODE) {
            const totalPaid = decemberPayments.reduce((sum, p) => sum + p.amount, 0);
            const totalOwed = classDates.length * pricePerClass;
            console.log(`üí∞ Allocated payments for ${student.name}:`, {
              totalPaid,
              totalOwed,
              pricePerClass,
              classCount: classDates.length,
              paidClasses: Object.values(allocation).filter(a => a.isPaid).length,
              unpaidClasses: Object.values(allocation).filter(a => !a.isPaid).length,
              allocation
            });
          }
          
          return allocation;
        }
        
        function findPaymentMatchForClass(student, dateStr, pricePerClass) {
          // SIMPLE RULE: Match payments by for_class column ONLY
          // If payment.for_class === class_date ‚Üí payment matches (GREEN dot)
          // If no match ‚Üí null (RED dot)
          
          const studentPayments = collectPaymentsForStudentSimple(student);
          
          const isTaguhiBarseghyan = (student.name === 'Taguhi Barseghyan' || student.id === 41 || student.id === '41');

          if (!studentPayments.length) {
            return null;
          }

          const validPrice = Number(pricePerClass) || 0;
          if (validPrice <= 0) {
            return null;
          }

          // Find payment where for_class matches this class date
          const exactMatch = studentPayments.find(payment => payment.forClass === dateStr);
          
          if (exactMatch) {
            return exactMatch;
          }

          // No match found
          return null;
        }

        // Helper: Find the next class date for this student after the given date
        function findNextClassDate(student, currentDateStr) {
          const studentId = student.id != null ? String(student.id) : null;
          const allClassDates = [];
          
          // Collect all class dates for this student across all groups
          const groupList = window.groupsCache || [];
          const studentsByGroupLookup = window.studentsByGroup || studentsByGroup || {};
          
          groupList.forEach(groupRecord => {
            const occurrences = generateGroupOccurrences(groupRecord);
            occurrences.forEach(occurrence => {
              // Check if student is in this group
              const groupNameRaw = groupRecord.group_name || groupRecord.name;
              const groupCode = groupRecord.group_code || canonicalizeGroupCode(groupNameRaw);
              const canonicalKey = groupCode || 'ungrouped';
              const fallbackKey = normalizeGroupKey(groupNameRaw);
              
              const isInGroup = (studentsByGroupLookup[canonicalKey] || studentsByGroupLookup[fallbackKey] || [])
                .some(s => String(s.id) === studentId || s.name === student.name);
              
              if (!isInGroup) return;
              
              // Check visibility
              const studentCreationDateStr = getStudentVisibilityThreshold(student);
              if (occurrence.dateStr < studentCreationDateStr) return;
              if (occurrence.dateStr < CALENDAR_START_DATE_STR) return;
              
              allClassDates.push(occurrence.dateStr);
            });
          });
          
          // Remove duplicates and sort
          const uniqueDates = [...new Set(allClassDates)].sort();
          
          // Find the next date after currentDateStr
          const nextDate = uniqueDates.find(date => date > currentDateStr);
          return nextDate || null;
        }

        /**
         * Determines the payment/class status for a given student on a specific date
         * @returns {Object} Status object with: status, label, balance, paidAmount
         */
        function determineClassStatus(student, studentId, dateStr, pricePerClass, skipInfo, groupName, classTime) {
          // Add comprehensive null safety
          if (!student || !dateStr) return null;
          
          const idKey = studentId ? String(studentId) : null;
          const studentName = student?.name || student?.student_name || 'Unknown';
          const balance = getStudentBalance(student);
          const classDate = createDateFromDateStr(dateStr);
          const todayParts = getTodayLAParts();
          const todayStr = todayParts ? formatDateYYYYMMDD(createDateFromParts(
            Number(todayParts.year),
            Number(todayParts.month) - 1,
            Number(todayParts.day)
          )) : formatDateYYYYMMDD(new Date());

          if (!classDate) return null;

          // Validate pricePerClass
          const validPrice = Number(pricePerClass) || 0;
          if (validPrice <= 0) {
            // console.warn(`Invalid pricePerClass for student ${student.name}: ${pricePerClass}`);
          }

          // Hide historical classes before system start or before the student existed
          if (CALENDAR_START_DATE && classDate < CALENDAR_START_DATE) {
            return null;
          }

          const visibilityThreshold = getStudentVisibilityThreshold(student);
          if (visibilityThreshold && dateStr < visibilityThreshold) {
            return null;
          }

          // Priority 1: Check if class was canceled or skipped
          if (skipInfo) {
            const isCanceled = skipInfo.type === 'class-canceled';
            return {
              status: isCanceled ? 'canceled' : 'skipped',
              label: skipInfo.note || (isCanceled ? 'Class canceled' : 'Class skipped'),
              balance,
              paidAmount: 0,
            };
          }

          // Priority 2: Check if student was absent
          // Check both absencesData and AbsentManager for real-time updates
          const isAbsentInData = idKey && absencesData[idKey] && absencesData[idKey][dateStr];
          const isAbsentInManager = idKey && window.AbsentManager && window.AbsentManager.isAbsent(idKey, dateStr);
          
          
          if (isAbsentInData || isAbsentInManager) {
            return {
              status: 'absent',
              label: 'Marked absent',
              balance,
              paidAmount: 0,
            };
          }

          // Priority 3: Check for payment match (STRICT: only matched payments make dots green)
          const paymentMatch = findPaymentMatchForClass(student, dateStr, validPrice);
          if (paymentMatch && paymentMatch.amount > 0) {
            const paidAmount = paymentMatch.amount;
            const overpayAmount = validPrice > 0 ? paidAmount - validPrice : 0;
            const labelBase = `Paid ${formatCurrency(paidAmount)} $`;
            const label = overpayAmount > 0
              ? `${labelBase} (${formatCurrency(overpayAmount)} $ overpaid)`
              : labelBase;
            
            return {
              status: 'paid',
              label,
              balance,
              paidAmount,
              paymentDate: paymentMatch.dateStr,
              paymentTime: paymentMatch.timeStr || '',  // Include payment time
            };
          }

          // Priority 5: MANUAL CREDIT ONLY - Never automatic
          // STRICT RULE: Credits ONLY if manually applied, never by automation
          // Check both creditLookup and CreditPaymentManager for MANUALLY applied credits
          const creditInLookup = idKey && creditLookup[idKey] && creditLookup[idKey][dateStr];
          const creditInManager = idKey && window.CreditPaymentManager && window.CreditPaymentManager.getCreditPayment(idKey, dateStr);
          const creditRecord = creditInLookup || creditInManager;
          
          // ONLY if credit was MANUALLY applied (has a record in the credit system)
          if (creditRecord && creditRecord.manually_applied !== false) {
            const creditAmount = Number(creditRecord.amount) || pricePerClass;
            return {
              status: 'credit',
              label: `Paid from credit (${formatCurrency(creditAmount)} $)`,
              balance: creditRecord.balance_after ?? creditRecord.balance ?? balance,
              paidAmount: creditAmount,
            };
          }

          // Priority 4: Future class (no payment yet)
          if (dateStr > todayStr) {
            return {
              status: 'upcoming',
              label: balance > 0 ? `Upcoming (balance ${formatCurrency(balance)} $)` : 'Upcoming class',
              balance,
              paidAmount: 0,
            };
          }

          // Priority 6: Unpaid (past or today, no payment, no absence)
          return {
            status: 'unpaid',
            label: balance > 0 ? `Unpaid (${formatCurrency(balance)} $ balance)` : 'Unpaid',
            balance,
            paidAmount: 0,
            owedAmount: validPrice, // Include owed amount for totals calculation
          };
        }

        // ============================================================
        // üî¥ FUCHSIA DOT LOGIC - Misallocated Payments
        // ============================================================
        async function addMisallocatedPaymentDots() {
          const studentsData = window.studentsCache || [];
          const targetMonthPrefix = `${year}-${String(month + 1).padStart(2, '0')}`;

          // Fetch ignored payments
          let ignoredPaymentIds = new Set();
          try {
            const { data: ignoredData, error: ignoredError } = await supabaseClient
              .from('ignored_fuchsia_payments')
              .select('payment_id');
            
            if (!ignoredError && ignoredData) {
              ignoredPaymentIds = new Set(ignoredData.map(row => row.payment_id));
            }
          } catch (err) {
            console.warn('Failed to fetch ignored payments:', err);
          }

          // Build a lookup of scheduled class dates per student from the day map
          const scheduledDatesByStudent = new Map(); // studentId/name -> Set(dateStr)
          const canceledDatesByStudent = new Map(); // studentId/name -> Set(dateStr) for canceled classes
          
          Object.values(dayMap).forEach(dayEntry => {
            if (!dayEntry || !dayEntry.groups) return;
            const { dateStr, groups } = dayEntry;
            if (!dateStr || !dateStr.startsWith(targetMonthPrefix)) return;

            groups.forEach(groupEntry => {
              (groupEntry.students || []).forEach(studentEntry => {
                if (!studentEntry) return;
                const studentKey = studentEntry.id ? String(studentEntry.id) : studentEntry.name;
                if (!studentKey) return;
                if (!scheduledDatesByStudent.has(studentKey)) {
                  scheduledDatesByStudent.set(studentKey, new Set());
                }
                scheduledDatesByStudent.get(studentKey).add(dateStr);
                
                // Check if this specific class was canceled for this student
                const groupName = studentEntry.group_name || groupEntry.groupName;
                if (groupName) {
                  const skipInfo = getSkipInfoForGroup(groupName, dateStr);
                  if (skipInfo && skipInfo.type === 'class-canceled') {
                    if (!canceledDatesByStudent.has(studentKey)) {
                      canceledDatesByStudent.set(studentKey, new Set());
                    }
                    canceledDatesByStudent.get(studentKey).add(dateStr);
                  }
                }
              });
            });
          });

          let totalFuchsiaDots = 0;
          let totalIgnored = 0;
          let totalPaymentsChecked = 0;

          // FIRST PASS: Check ALL students for Dec 13 payments (including show_in_grid=false)
          studentsData.forEach(student => {
            const studentPayments = collectPaymentsForStudentSimple(student);
            studentPayments.forEach(payment => {
              if (payment.forClass === '2025-12-13') {
                // Dec 13 payment found - silently tracked
              }
            });
          });

          // SECOND PASS: Process only show_in_grid students
          studentsData.forEach(student => {
            if (!student.show_in_grid) return;

            const studentPayments = collectPaymentsForStudentSimple(student);
            if (!studentPayments.length) return;

            const studentKey = student.id != null ? String(student.id) : student.name;
            const scheduledDates = scheduledDatesByStudent.get(studentKey) || new Set();
            const canceledDates = canceledDatesByStudent.get(studentKey) || new Set();

            studentPayments.forEach(payment => {
              if (!payment.forClass) {
                return;
              }

              const forClassDate = payment.forClass;

              if (!forClassDate.startsWith(targetMonthPrefix)) {
                // Payment for different month
                return;
              }

              totalPaymentsChecked++;

              // Skip ignored payments
              if (ignoredPaymentIds.has(payment.id)) {
                totalIgnored++;
                return;
              }

              const isScheduledClass = scheduledDates.has(forClassDate);
              const isClassCanceled = canceledDates.has(forClassDate);

              // Show fuchsia dot if:
              // 1. Payment for a date with no scheduled class (misallocated), OR
              // 2. Payment for a canceled class (needs reassignment)
              if (!isScheduledClass || isClassCanceled) {
                addFuchsiaDot(forClassDate, student, payment);
                totalFuchsiaDots++;
              }
            });
          });
        }
        
        function isScheduledClassDay(groupRecord, classDate) {
          // Check if the given date is a scheduled class day for this group
          if (!groupRecord || !classDate) return false;
          
          // Parse the group's schedule
          const sessions = parseScheduleString(groupRecord.schedule || '');
          if (!sessions.length) return false;
          
          // Get the day of week for the class date
          const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
          const dayOfWeek = classDate.getDay();
          const dayName = dayNames[dayOfWeek];
          
          // Check if this day is in the group's schedule
          const hasRegularClass = sessions.some(session => session.day === dayName);
          if (hasRegularClass) return true;
          
          // Check one-time schedules
          if (Array.isArray(groupRecord.one_time_schedules)) {
            const dateStr = formatDateYYYYMMDD(classDate);
            const hasOneTimeClass = groupRecord.one_time_schedules.some(override => {
              if (!override || !override.date) return false;
              const normalizedDate = normalizeDateInput(override.date);
              return normalizedDate === dateStr;
            });
            if (hasOneTimeClass) return true;
          }
          
          return false;
        }
        
        function hasScheduledClass(student, dateStr) {
          // Check if student has a scheduled class on this date
          const groupName = student.group_name;
          if (!groupName) return false;
          
          // Find the group record
          const groupRecord = (window.groupsCache || []).find(g => 
            (g.group_name || g.name) === groupName || 
            canonicalizeGroupCode(g.group_name || g.name) === canonicalizeGroupCode(groupName)
          );
          
          if (!groupRecord) return false;
          
          // Check if date is in the group's schedule
          const classDate = createDateFromDateStr(dateStr);
          if (!classDate) return false;
          
          return isScheduledClassDay(groupRecord, classDate);
        }
        
        function addFuchsiaDot(dateStr, student, payment) {
          // Extract day number from YYYY-MM-DD format
          const dateParts = dateStr.split('-');
          const day = parseInt(dateParts[2], 10); // Get day as number (1-31)
          
          // Get or create day entry using NUMERIC key
          if (!dayMap[day]) {
            dayMap[day] = {
              dateStr,
              classes: 0,
              payments: 0,
              totals: { paid: 0, unpaid: 0 },
              groups: [],
              fuchsiaDots: [] // New: track fuchsia dots separately
            };
          }
          
          // Add fuchsia dot to the day
          if (!dayMap[day].fuchsiaDots) {
            dayMap[day].fuchsiaDots = [];
          }
          
          const fuchsiaDotData = {
            studentId: student.id,
            studentName: student.name,
            paymentId: payment.id,
            paymentAmount: payment.amount,
            receiptDate: payment.dateStr,
            forClass: payment.forClass,
            label: `${student.name} - Payment for non-class day`
          };
          
          dayMap[day].fuchsiaDots.push(fuchsiaDotData);
        }

        // ============================================================
        // üé® GRAY DOT LOGIC - Pure Schedule Only (Starting Dec 1, 2025)
        // ============================================================
        function addScheduledClassDots(groupList, aggregates) {
          groupList.forEach(groupRecord => {
            const groupNameRaw = groupRecord.group_name || groupRecord.name || 'Untitled Group';
            const groupCode = groupRecord.group_code || canonicalizeGroupCode(groupNameRaw);
            const canonicalKey = groupCode || 'ungrouped';
            const fallbackKey = normalizeGroupKey(groupNameRaw);
            const groupDisplay = groupCode ? formatGroupDisplay(groupCode) : groupNameRaw;
            
            // Get students for this group from Student Manager
            const groupStudents = (studentsByGroup[canonicalKey] && studentsByGroup[canonicalKey].length)
              ? studentsByGroup[canonicalKey]
              : (studentsByGroup[fallbackKey] && studentsByGroup[fallbackKey].length)
                ? studentsByGroup[fallbackKey]
                : buildFallbackGroupStudents(groupRecord);
            
            // Filter only active students (respects paused/toggled off)
            const activeStudents = groupStudents.filter(student => {
              if (!student || !shouldIncludeStudent(student)) return false;
              return true;
            });
            
            if (activeStudents.length === 0) return; // No active students = no dots
            
            // Generate all occurrences for this group's schedule
            const occurrences = generateGroupOccurrences(groupRecord);
            
            occurrences.forEach((occurrence) => {
              const parts = parseDateParts(occurrence.dateStr);
              if (!parts) return;
              
              const dayEntry = dayMap[parts.day];
              if (!dayEntry) return;
              
              // ‚úÖ CHANGED: Include cancelled classes (don't filter them out)
              // Check if class is cancelled for this specific date
              const skipInfo = getSkipInfoForGroup(groupNameRaw, occurrence.dateStr);
              const isCancelled = skipInfo && skipInfo.type === 'class-canceled';
              // Removed: if (isCancelled) return; // Now we show cancelled classes!
              
              // Create class entry with students array
              const classEntry = {
                id: `${groupCode || 'group'}-${occurrence.dateStr}`,
                groupName: groupDisplay,
                groupCode,
                laTime: occurrence.laTime,
                students: [], // Will hold individual student entries
                isCancelled: isCancelled, // ‚úÖ NEW: Mark if cancelled
                skipInfo: skipInfo, // ‚úÖ NEW: Include skip info
              };
              
              // Add one dot per active student with proper payment status
              activeStudents.forEach(student => {
                const studentId = student.id != null ? String(student.id) : null;
                const studentName = student.name || 'Unknown Student';
                
                // Check if student was already created before this class date
                const studentCreationDateStr = getStudentVisibilityThreshold(student);
                if (occurrence.dateStr < studentCreationDateStr) {
                  return; // Student didn't exist yet on this date
                }
                
                if (occurrence.dateStr < CALENDAR_START_DATE_STR) {
                  // Class is before calendar start ‚Üí HIDE (don't render)
                  return;
                }
                
                // ============================================================
                // üí∞ December 2025: Pre-compute allocation for this student
                // ============================================================
                
                // ============================================================
                // üí∞ Compute payment status
                // ============================================================
                const skipInfo = getSkipInfoForGroup(groupNameRaw, occurrence.dateStr);
                const paymentStatus = determineClassStatus(
                  student,
                  studentId,
                  occurrence.dateStr,
                  student.price_per_class || student.pricePerClass,
                  skipInfo,
                  groupNameRaw,
                  occurrence.dateStr
                );
                
                if (!paymentStatus) return; // Hidden due to visibility rules
                
                // Add student entry with payment info
                classEntry.students.push({
                  id: studentId,
                  name: studentName,
                  status: paymentStatus.status,
                  label: paymentStatus.label,
                  paid: paymentStatus.status === 'paid',
                  absent: paymentStatus.status === 'absent',
                  paidAmount: paymentStatus.paidAmount || 0,
                  balance: paymentStatus.balance,
                  pricePerClass: student.price_per_class || student.pricePerClass || 0,
                  paymentDate: paymentStatus.paymentDate,
                  paymentTime: paymentStatus.paymentTime,
                  groupCode: groupCode, // Add groupCode for search functionality
                  group_letter: groupCode, // Alternative field name for compatibility
                });
                
                // Update stats
                if (paymentStatus.status === 'paid' || paymentStatus.status === 'credit') {
                  dayEntry.stats.payments += 1;
                  aggregates.payments += 1;
                } else if (paymentStatus.status === 'absent') {
                  dayEntry.stats.absences += 1;
                  aggregates.absences += 1;
                }
                
                // Update totals for header stats
                if (paymentStatus.status === 'paid' || paymentStatus.status === 'credit') {
                  const paidAmount = paymentStatus.paidAmount || 0;
                  dayEntry.totals.paid += paidAmount;
                  debugLog(`üíö PAID: ${studentName} on ${occurrence.dateStr} - Added ${paidAmount}$ to totals.paid (now: ${dayEntry.totals.paid}$)`);
                } else if (paymentStatus.status === 'unpaid') {
                  const owedAmount = paymentStatus.owedAmount || student.price_per_class || student.pricePerClass || 0;
                  dayEntry.totals.unpaid += owedAmount;
                  debugLog(`üî¥ UNPAID: ${studentName} on ${occurrence.dateStr} - Added ${owedAmount}$ to totals.unpaid (now: ${dayEntry.totals.unpaid}$)`, {
                    owedAmountFromStatus: paymentStatus.owedAmount,
                    pricePerClass: student.price_per_class || student.pricePerClass,
                    finalOwedAmount: owedAmount,
                    paymentStatus
                  });
                }
              });
              
              // Only add class entry if it has students
              if (classEntry.students.length > 0) {
                dayEntry.groups.push(classEntry);
                dayEntry.indicators.add('class');
              }
            });
          });
        }

        function addPaymentEvents(paymentsByDate, allocatedPaymentIds = new Set()) {
          Object.entries(paymentsByDate || {}).forEach(([dateStr, list]) => {
            const parts = parseDateParts(dateStr);
            if (!parts || parts.year !== year || parts.month !== month + 1) return;
            const dayEntry = dayMap[parts.day];
            if (!dayEntry) return;

            // Filter out payments that have already been allocated to classes
            const unallocatedPayments = list.filter(p => !allocatedPaymentIds.has(p.id));
            
            if (unallocatedPayments.length === 0) return;

            dayEntry.payments.push(...unallocatedPayments);
            dayEntry.stats.payments += unallocatedPayments.length;
            dayEntry.indicators.add('payment');
            aggregates.payments += unallocatedPayments.length;

            unallocatedPayments.forEach(entry => {
              eventsFlat.push({ type: 'payment', date: dateStr, studentName: entry.studentName, amount: entry.amount });
            });
          });
        }

        function addCreditEvents(creditByDate) {
          Object.entries(creditByDate || {}).forEach(([dateStr, list]) => {
            const parts = parseDateParts(dateStr);
            if (!parts || parts.year !== year || parts.month !== month + 1) return;
            const dayEntry = dayMap[parts.day];
            if (!dayEntry) return;

            dayEntry.credits.push(...list);
            dayEntry.stats.credits += list.length;
            dayEntry.indicators.add('credit');
            aggregates.credits += list.length;

            list.forEach(entry => {
              eventsFlat.push({ type: 'credit', date: dateStr, studentName: entry.studentName, amount: entry.amount });
            });
          });
        }

        function getSkipInfoForGroup(groupName, dateStr) {
          if (!groupName || !dateStr) return null;
          if (skippedClassesData[groupName] && skippedClassesData[groupName][dateStr]) {
            return skippedClassesData[groupName][dateStr];
          }

          const normalized = normalizeGroupKey(groupName);
          for (const key of Object.keys(skippedClassesData || {})) {
            if (normalizeGroupKey(key) === normalized && skippedClassesData[key][dateStr]) {
              return skippedClassesData[key][dateStr];
            }
          }
          return null;
        }

        function generateGroupOccurrences(groupRecord) {
          const occurrences = [];
          const sessions = parseScheduleString(groupRecord.schedule);
          for (const session of sessions) {
            const weekdayIndex = dayNames.indexOf(session.day);
            if (weekdayIndex === -1) continue;

            for (let day = 1; day <= daysInMonth; day++) {
              const dateObj = createDateFromParts(year, month, day);
              const laWeekdayIndex = getLAWeekdayIndex(dateObj);
              if (laWeekdayIndex !== weekdayIndex) continue;
              const dateStr = formatDateYYYYMMDD(dateObj);
              occurrences.push({
                dateObj,
                dateStr,
                weekdayIndex: laWeekdayIndex,
                laTime: session.time,
                isOneTime: false,
              });
            }
          }

          (Array.isArray(groupRecord.one_time_schedules) ? groupRecord.one_time_schedules : []).forEach(override => {
            if (!override || !override.date) return;
            const normalizedDate = normalizeDateInput(override.date);
            const parts = parseDateParts(normalizedDate);
            if (!parts || parts.year !== year || parts.month !== month + 1) return;
            const overrideDate = createDateFromParts(parts.year, parts.month - 1, parts.day);
            const laTime = ensureAMPMFormatLocal(override.time || '');
            occurrences.push({
              dateObj: overrideDate,
              dateStr: normalizedDate,
              weekdayIndex: getLAWeekdayIndex(overrideDate) ?? overrideDate.getUTCDay(),
              laTime,
              isOneTime: true,
            });
          });

          return occurrences;
        }

        function buildFallbackGroupStudents(groupRecord) {
          if (!groupRecord || !Array.isArray(groupRecord.students)) return [];
          const groupCode = groupRecord.group_code || canonicalizeGroupCode(groupRecord.group_name || groupRecord.name || '');
          const groupDisplay = groupCode ? formatGroupDisplay(groupCode) : (groupRecord.group_name || groupRecord.name || 'Untitled Group');
          return groupRecord.students.map((student, index) => ({
            id: student.id != null ? String(student.id) : `${groupRecord.id || 'group'}-student-${index}`,
            name: student.name || student.student_name || `Student ${index + 1}`,
            group_code: groupCode,
            group_display: groupDisplay,
            group_name: groupRecord.group_name || groupRecord.name || groupDisplay,
            price_per_class: student.price_per_class || groupRecord.price_per_class || 0,
            status: student.status || 'active',
            show_in_calendar: student.show_in_calendar ?? true,
          }));
        }

        /**
         * Determines the payment status for a student on a specific class date.
         * 
         * PAYMENT MATCHING RULES (Core Billing Logic):
         * ================================================
         * 
         * 1. Every scheduled class creates an "expected payment"
         *    - Red dot = student owes money for that specific class
         *    - Red dot only disappears when valid payment/credit is found
         * 
         * 2. Payment Identification (who paid?)
         *    A payment belongs to a student if ANY of these match:
         *    - student_id, linked_student_id, derived_student_id
         *    - resolved_student_name, student_email
         *    - Any name alias configured for the student
         * 
         * 3. Payment Application (which class does it cover?)
         *    - Payment applies to nearest PAST class ON or BEFORE payment date
         *    - Payment CANNOT apply to future classes
         *    - Exact date match has highest priority
         * 
         *    Example:
         *    Classes: Nov 10, Nov 12, Nov 14
         *    Payment: Nov 13 (LA time)
         *    
         *    Result:
         *    - Nov 10: May get earlier payment if exists
         *    - Nov 12: Gets Nov 13 payment ‚úÖ (nearest past class)
         *    - Nov 14: Not covered (payment is before this class)
         * 
         * 4. When payment matches:
         *    ‚úÖ Remove red dot
         *    ‚úÖ Add green dot (payment) or cyan dot (credit)
         *    ‚úÖ Mark student as PAID/CREDIT
         *    ‚úÖ Show payment in day modal
         *    ‚úÖ Reduce outstanding balance
         * 
         * 5. Credit payments (using student's profile credit):
         *    - Work exactly like cash payments
         *    - Show cyan dot instead of green
         *    - Reduce credit balance
         *    - Logged in credit_payments table
         * 
         * 6. No payment/credit found:
         *    ‚ùå Keep red dot (UNPAID)
         *    ‚ùå Show in "Unpaid Students" list
         *    ‚ùå Day modal shows "Unpaid (no payment found)"
         * 
         * CRITICAL: All dates MUST use LA timezone only
         * 
         * @param {Object} student - Student record with name, id, schedule info
         * @param {String} studentId - Student ID for lookups
         * @param {String} dateStr - Class date in YYYY-MM-DD format (LA time)
         * @param {Number} pricePerClass - Expected payment amount for this class
         * @param {Object} skipInfo - Optional cancellation/skip information
         * @returns {Object} Status object with: status, label, balance, paidAmount
         */
        }

        function addClassEvents(groupList, groupedStudents, allocatedPaymentIds = new Set()) {
          groupList.forEach(groupRecord => {
            const groupNameRaw = groupRecord.group_name || groupRecord.name || 'Untitled Group';
            const groupCode = groupRecord.group_code || canonicalizeGroupCode(groupNameRaw);
            const canonicalKey = groupCode || 'ungrouped';
            const fallbackKey = normalizeGroupKey(groupNameRaw);
            const groupDisplay = groupCode ? formatGroupDisplay(groupCode) : groupNameRaw;
            const groupStudents = (groupedStudents[canonicalKey] && groupedStudents[canonicalKey].length)
              ? groupedStudents[canonicalKey]
              : (groupedStudents[fallbackKey] && groupedStudents[fallbackKey].length)
                ? groupedStudents[fallbackKey]
                : buildFallbackGroupStudents(groupRecord);

            if (!groupStudents.length) return;

            const occurrences = generateGroupOccurrences(groupRecord);
            occurrences.forEach((occurrence, idx) => {
              const parts = parseDateParts(occurrence.dateStr);
              if (!parts) return;
              const dayEntry = dayMap[parts.day];
              if (!dayEntry) return;

              // ============================================================
              // üé® ALL SKIP/CANCEL LOGIC REMOVED - CLEAN SLATE
              // ============================================================
              const classEntry = {
                id: `${canonicalKey || 'group'}-${occurrence.dateStr}-${idx}`,
                groupName: groupDisplay,
                groupCode,
                laTime: occurrence.laTime,
                day: dayNames[occurrence.weekdayIndex],
                isOneTime: occurrence.isOneTime,
                students: [],
              };

              groupStudents.forEach(student => {
                if (!student || !shouldIncludeStudent(student)) return;
                
                const studentId = student.id != null ? String(student.id) : null;
                const studentName = student.name || 'Unknown Student';
                
                // Validate student has required data
                if (!studentName && !studentId) {
                  return;
                }
                
                // ============================================================
                // üéØ VISIBILITY RULES: Hide classes before student creation or calendar start
                // ============================================================
                const studentCreationDateStr = getStudentVisibilityThreshold(student);
                if (occurrence.dateStr < studentCreationDateStr) {
                  // Class is before student joined ‚Üí HIDE (don't render)
                  return;
                }
                
                if (occurrence.dateStr < CALENDAR_START_DATE_STR) {
                  // Class is before calendar start ‚Üí HIDE (don't render)
                  return;
                }
                
                // ============================================================
                // üí∞ Compute payment status
                // ============================================================
                const skipInfo = getSkipInfoForGroup(groupNameRaw, occurrence.dateStr);
                const paymentStatus = determineClassStatus(
                  student,
                  studentId,
                  occurrence.dateStr,
                  student.price_per_class || student.pricePerClass,
                  skipInfo,
                  groupNameRaw,
                  occurrence.dateStr
                );
                
                if (!paymentStatus) return; // Hidden due to visibility rules
                
                classEntry.students.push({
                  id: studentId,
                  name: studentName,
                  status: paymentStatus.status,
                  label: paymentStatus.label,
                  paid: paymentStatus.status === 'paid',
                  absent: paymentStatus.status === 'absent',
                  paidAmount: paymentStatus.paidAmount || 0,
                  balance: paymentStatus.balance,
                  pricePerClass: student.price_per_class || student.pricePerClass || 0,
                  paymentDate: paymentStatus.paymentDate,
                  paymentTime: paymentStatus.paymentTime,
                  groupCode: groupCode, // Add groupCode for search functionality
                  group_letter: groupCode, // Alternative field name for compatibility
                });
                
                // Update stats
                if (paymentStatus.status === 'paid' || paymentStatus.status === 'credit') {
                  dayEntry.stats.payments += 1;
                  aggregates.payments += 1;
                } else if (paymentStatus.status === 'absent') {
                  dayEntry.stats.absences += 1;
                  aggregates.absences += 1;
                }
                
                // Update totals for header stats
                if (paymentStatus.status === 'paid' || paymentStatus.status === 'credit') {
                  const paidAmount = paymentStatus.paidAmount || 0;
                  dayEntry.totals.paid += paidAmount;
                  debugLog(`üíö PAID: ${studentName} on ${occurrence.dateStr} - Added ${paidAmount}$ to totals.paid (now: ${dayEntry.totals.paid}$)`);
                } else if (paymentStatus.status === 'unpaid') {
                  const owedAmount = paymentStatus.owedAmount || student.price_per_class || student.pricePerClass || 0;
                  dayEntry.totals.unpaid += owedAmount;
                  debugLog(`üî¥ UNPAID: ${studentName} on ${occurrence.dateStr} - Added ${owedAmount}$ to totals.unpaid (now: ${dayEntry.totals.unpaid}$)`, {
                    owedAmountFromStatus: paymentStatus.owedAmount,
                    pricePerClass: student.price_per_class || student.pricePerClass,
                    finalOwedAmount: owedAmount,
                    paymentStatus
                  });
                }
              });

              if (classEntry.students.length === 0) {
                return; // No students = don't render class entry
              }

              classEntry.students.sort((a, b) => a.name.localeCompare(b.name));
              dayEntry.groups.push(classEntry);
              dayEntry.stats.classes += 1;
              aggregates.classes += 1;
              dayEntry.indicators.add('class');

              eventsFlat.push({
                type: 'class',
                date: occurrence.dateStr,
                groupName: groupDisplay,
                groupCode: groupCode,
                students: classEntry.students.length,
                skipped: Boolean(skipInfo),
              });
            });
          });
        }

        function addStudentMilestones(rawStudents) {
          (rawStudents || []).forEach(student => {
            if (!shouldIncludeStudent(student)) return;

            const candidateDates = [];
            if (student.start_date) {
              candidateDates.push({ type: 'studentJoin', value: student.start_date, label: 'Joined Program' });
            }
            if (student.created_at) {
              candidateDates.push({ type: 'studentJoin', value: student.created_at, label: 'Student Added' });
            }
            if (student.birthdate || student.birthday) {
              const source = student.birthdate || student.birthday;
              const birthParts = parseDateParts(source);
              if (birthParts) {
                const normalizedBirthday = `${year}-${String(birthParts.month).padStart(2, '0')}-${String(birthParts.day).padStart(2, '0')}`;
                candidateDates.push({ type: 'studentBirthday', value: normalizedBirthday, label: 'Birthday' });
              }
            }

            candidateDates.forEach(eventInfo => {
              const targetDateStr = normalizeDateInput(eventInfo.value);
              const parts = parseDateParts(targetDateStr);
              if (!parts || parts.year !== year || parts.month !== month + 1) return;
              const dayEntry = dayMap[parts.day];
              if (!dayEntry) return;

              const event = {
                type: eventInfo.type,
                studentName: student.name,
                label: eventInfo.label,
              };

              dayEntry.studentEvents.push(event);
              dayEntry.indicators.add(eventInfo.type);
              eventsFlat.push({ type: eventInfo.type, date: targetDateStr, studentName: student.name });
            });
          });
        }
      

      // ============================================================================
      // SCHEDULING CONFLICT DETECTION
      // ============================================================================
      
      /**
       * Check if a student has overlapping classes on the same date
       * Returns conflict info if found, null otherwise
       */
      async function checkSchedulingConflict(studentId, classDate, startTime, endTime, excludeGroupId = null) {
        try {
          const students = window.studentsCache || [];
          const groups = window.groupsCache || [];
          const student = students.find(s => s.id === studentId);
          
          if (!student) {
            // console.warn('Student not found:', studentId);
            return null;
          }
          
          // Get all groups this student is in
          const studentGroups = deriveStudentGroups(student);
          
          // Check each group for classes on this date
          const conflicts = [];
          
          for (const groupCode of studentGroups) {
            const normalized = normalizeGroupKey(groupCode);
            const group = groups.find(g => {
              const gCode = g.group_code || canonicalizeGroupCode(g.group_name || g.name || '');
              return normalized === normalizeGroupKey(gCode || '');
            });
            
            if (!group || (excludeGroupId && group.id === excludeGroupId)) continue;
            
            // Check if this group has a class on the target date
            const sessions = parseScheduleString(group.schedule || '');
            const targetDate = createDateFromDateStr(classDate);
            if (!targetDate) continue;
            
            const targetWeekday = getLAWeekdayName(targetDate);
            
            for (const session of sessions) {
              if (session.day === targetWeekday) {
                // Parse times and check for overlap
                const sessionStart = parseTimeToMinutes(session.time);
                const sessionEnd = sessionStart + 60; // Assume 60 min classes
                const newStart = parseTimeToMinutes(startTime);
                const newEnd = parseTimeToMinutes(endTime);
                
                // Check for time overlap
                if (newStart < sessionEnd && newEnd > sessionStart) {
                  conflicts.push({
                    groupName: group.group_name || group.name,
                    groupCode: group.group_code,
                    time: session.time,
                    date: classDate,
                    day: session.day
                  });
                }
              }
            }
            
            // Check one-time schedules
            if (Array.isArray(group.one_time_schedules)) {
              for (const override of group.one_time_schedules) {
                const overrideDate = normalizeDateInput(override.date);
                if (overrideDate === classDate) {
                  const sessionStart = parseTimeToMinutes(override.time);
                  const sessionEnd = sessionStart + 60;
                  const newStart = parseTimeToMinutes(startTime);
                  const newEnd = parseTimeToMinutes(endTime);
                  
                  if (newStart < sessionEnd && newEnd > sessionStart) {
                    conflicts.push({
                      groupName: group.group_name || group.name,
                      groupCode: group.group_code,
                      time: override.time,
                      date: classDate,
                      day: getLAWeekdayName(targetDate),
                      isOneTime: true
                    });
                  }
                }
              }
            }
          }
          
          if (conflicts.length > 0) {
            return {
              hasConflict: true,
              conflicts,
              message: `Student ${student.name} is already scheduled for ${conflicts.length} class${conflicts.length > 1 ? 'es' : ''} on ${classDate}`
            };
          }
          
          return null;
        } catch (err) {
          console.error('Error checking scheduling conflict:', err);
          return null;
        }
      }
      
      /**
       * Helper function to derive student groups (copied from computeMonthData scope)
       */
      // ============================================================================
      // CREDIT BALANCE & PREPAYMENT TRACKING
      // ============================================================================
      
      /**
       * Calculate student's accurate balance based only on allocated payments
       * This prevents showing negative balances when students prepay
       */
      function calculateStudentBalance(student, studentId) {
        try {
          // Get all payments for this student
          const payments = window.paymentsCache || [];
          const studentPayments = payments.filter(p => {
            if (!p) return false;
            
            // Check direct ID match
            const paymentStudentId = p.student_id || p.studentid || p.linked_student_id;
            if (paymentStudentId && String(paymentStudentId) === String(studentId)) {
              return true;
            }
            
            // Check name match
            const studentName = (student?.name || '').toLowerCase().trim();
            const paymentName = (p.student_name || p.studentName || '').toLowerCase().trim();
            const payerName = (p.payer_name || p.payer || '').toLowerCase().trim();
            
            return studentName && (paymentName === studentName || payerName === studentName);
          });
          
          // Sum all payments
          const totalPaid = studentPayments.reduce((sum, p) => {
            return sum + (Number(p.amount) || 0);
          }, 0);
          
          const storedBalance = Number(student?.balance) || 0;
          const debugInfo = {
            totalPaid,
            storedBalance,
            finalBalance: storedBalance
          };
          debugLog(`üí∞ Balance for ${student?.name || studentId}:`, debugInfo);
          
          return {
            totalPaid,
            totalAllocated: 0,
            creditBalance: storedBalance,
            storedBalance,
            finalBalance: storedBalance
          };
        } catch (err) {
          console.error('Error calculating student balance:', err);
          return {
            totalPaid: 0,
            totalAllocated: 0,
            creditBalance: Number(student?.balance) || 0,
            storedBalance: Number(student?.balance) || 0,
            finalBalance: Number(student?.balance) || 0
          };
        }
      }
      
      /**
       * Handle prepayments by adding to student's credit balance
       * instead of trying to allocate to future classes
       */
      async function recordPrepayment(studentId, amount, paymentDate, memo = '') {
        try {
          const students = window.studentsCache || [];
          const student = students.find(s => s.id === studentId);
          
          if (!student) {
            throw new Error('Student not found');
          }
          
          // Calculate current accurate balance
          const balanceInfo = calculateStudentBalance(student, studentId);
          const newBalance = balanceInfo.finalBalance + amount;
          
          // Update student balance in database
          const { error: updateError } = await supabaseClient
            .from('students')
            .update({ balance: newBalance })
            .eq('id', studentId);
          
          if (updateError) {
            throw new Error(`Failed to update student balance: ${updateError.message}`);
          }
          
          // Record the payment
          const paymentRecord = {
            id: generatePaymentId(),
            student_id: studentId,
            student_name: student.name,
            amount: amount,
            date: paymentDate,
            email_date: paymentDate + 'T12:00:00',
            payer_name: student.name
          };
          
          const { error: paymentError } = await supabaseClient
            .from('payments')
            .insert([paymentRecord]);
          
          if (paymentError) {
            throw new Error(`Failed to record payment: ${paymentError.message}`);
          }
          
          debugLog('‚úÖ Prepayment recorded:', {
            student: student.name,
            amount,
            oldBalance: balanceInfo.finalBalance,
            newBalance
          });
          
          // Refresh data
          await loadPayments();
          student.balance = newBalance; // Update cache
          clearMonthCache();
          renderCalendar();
          
          return {
            success: true,
            oldBalance: balanceInfo.finalBalance,
            newBalance,
            message: `Added ${formatCurrency(amount)} $ credit. New balance: ${formatCurrency(newBalance)} $`
          };
        } catch (err) {
          console.error('Error recording prepayment:', err);
          throw err;
        }
      }

      // ============================================================================
      // DATA LOADING FROM SUPABASE
      // ============================================================================
      
      // Load all students from Supabase
      async function loadStudents() {
        try {
          const { data, error } = await supabaseClient
            .from('students')
            .select('*')
            .order('name');
            
          if (error) {
            console.error('‚ùå Error loading students:', error);
            return [];
          }
          
          const normalizedStudents = (data || []).map(record => {
            const groupCode = record.group_code || canonicalizeGroupCode(record.group_name || record.group || record.groupName || '');
            const groupDisplay = groupCode ? formatGroupDisplay(groupCode) : (record.group_name || record.group || record.groupName || 'No Group');
            
            const normalized = {
              ...record,
              group_code: groupCode,
              group_display: groupDisplay,
            };
            
            return normalized;
          });
          window.studentsCache = normalizedStudents;
          return window.studentsCache;
        } catch (err) {
          console.error('‚ùå Exception loading students:', err);
          return [];
        }
      }
      
      // Load all groups from Supabase
      async function loadGroups() {
        try {
          const { data, error } = await supabaseClient
            .from('groups')
            .select('*')
            .order('group_name');
            
          if (error) {
            console.error('‚ùå Error loading groups:', error);
            return [];
          }
          
          const normalizedGroups = (data || []).map(record => {
            const groupCode = record.group_code || canonicalizeGroupCode(record.group_name || record.name || '');
            const displayName = groupCode ? formatGroupDisplay(groupCode) : (record.group_name || record.name || 'Untitled Group');
            
            const normalized = {
              ...record,
              group_code: groupCode,
              group_display: displayName,
            };
            
            return normalized;
          });
          window.groupsCache = normalizedGroups;
          return window.groupsCache;
        } catch (err) {
          console.error('‚ùå Exception loading groups:', err);
          return [];
        }
      }
      
      // Load all payments from Supabase - BOTH payment_records (manual) AND payments (Zelle)
      async function loadPayments(dateRange = null) {
        debugLog('üîÑ Loading payments from Supabase...');
        try {
          // ‚ö° LAZY LOADING: Calculate date range for current month +/- 2 months
          let startDate = null;
          let endDate = null;
          
          if (dateRange) {
            startDate = dateRange.start;
            endDate = dateRange.end;
            debugLog('üìÖ Loading payments for date range:', startDate, 'to', endDate);
          }
          
          // ‚ö° PERFORMANCE: Run both queries in parallel
          const [automatedResult, manualResult] = await Promise.all([
            // Load automated payments from 'payments' table
            (async () => {
              let automatedQuery = supabaseClient.from('payments').select('*');
              
              if (startDate && endDate) {
                automatedQuery = automatedQuery
                  .gte('for_class', startDate)
                  .lte('for_class', endDate);
              }
              
              return await automatedQuery.order('for_class', { ascending: false });
            })(),
            
            // Load manual payment records from 'payment_records' table
            (async () => {
              try {
                let manualQuery = supabaseClient.from('payment_records').select('*');
                
                if (startDate && endDate) {
                  manualQuery = manualQuery
                    .gte('date', startDate)
                    .lte('date', endDate);
                }
                
                return await manualQuery.order('date', { ascending: false });
              } catch (manualException) {
                debugLog('‚ÑπÔ∏è payment_records table not available:', manualException.message);
                return { data: [], error: null };
              }
            })()
          ]);
          
          const { data: automatedPayments, error: automatedError } = automatedResult;
          const { data: manualPayments, error: manualError } = manualResult;
          
          if (automatedError) {
            console.error('‚ùå Error loading automated payments:', automatedError);
          }
          
          if (manualError) {
            debugLog('‚ÑπÔ∏è Skipping payment_records table:', manualError.message);
          }
          
          debugLog('‚úÖ Automated payments loaded:', (automatedPayments || []).length);
          debugLog('üìã Manual payment_records loaded:', (manualPayments || []).length);
          
          // Combine both sources
          const allPayments = [
            ...(automatedPayments || []),
            ...(manualPayments || [])
          ];
          
          debugLog('üí∞ Loaded payments:', {
            automated: (automatedPayments || []).length,
            manual: (manualPayments || []).length,
            total: allPayments.length,
            range: dateRange ? `${startDate} to ${endDate}` : 'all'
          });
          
          // ‚ö° LAZY LOADING: If date range specified, append to cache instead of replacing
          if (dateRange && window.paymentsCache) {
            // Merge new payments with existing cache, avoiding duplicates
            const existingIds = new Set(window.paymentsCache.map(p => p.id));
            const newPayments = allPayments.filter(p => !existingIds.has(p.id));
            window.paymentsCache = [...window.paymentsCache, ...newPayments];
            debugLog('üì¶ Appended', newPayments.length, 'new payments to cache. Total:', window.paymentsCache.length);
          } else {
            window.paymentsCache = allPayments;
            debugLog('‚úÖ Stored in window.paymentsCache:', window.paymentsCache.length, 'payments');
          }
          
          debugLog('üìã Sample payment:', window.paymentsCache[0]);
          return window.paymentsCache;
        } catch (err) {
          console.error('‚ùå Exception loading payments:', err);
          return window.paymentsCache || [];
        }
      }
      
      // ‚ö° PERFORMANCE: Removed duplicate loadAbsences() - now using AbsentManager.init() only
      // Old function at this location caused double Supabase calls (Lines 6109-6143 removed)
      // Wrapper function to initialize AbsentManager and return data for backwards compatibility
      async function loadAbsences() {
        await AbsentManager.init();
        // AbsentManager doesn't expose all data, so we return empty object
        // The actual absence checking is done via AbsentManager.isAbsent()
        return {};
      }
      
      // Load skipped/canceled classes from Supabase
      async function loadSkippedClasses() {
        try {
          const { data, error } = await supabaseClient
            .from('skipped_classes')
            .select('*');
            
          if (error) {
            console.error('‚ùå Error loading skipped classes:', error);
            return {};
          }
          
          // Convert to object format: { groupName: { 'YYYY-MM-DD': { type, note } } }
          const skipped = {};
          (data || []).forEach(record => {
            const groupName = record.group_name;
            const dateStr = normalizeDateInput(record.class_date || record.date);
            if (!groupName || !dateStr) return;
            if (!skipped[groupName]) {
              skipped[groupName] = {};
            }
            skipped[groupName][dateStr] = {
              type: record.skip_type || 'class-canceled',
              note: record.note || null
            };
          });
          
          return skipped;
        } catch (err) {
          console.error('‚ùå Exception loading skipped classes:', err);
          return {};
        }
      }

      // ‚ö° PERFORMANCE: Removed duplicate loadCreditPayments() - now using CreditPaymentManager.init() only
      // Old function at this location caused double Supabase calls (Lines 6146-6178 removed)
      // Wrapper function to initialize CreditPaymentManager and build lookup for backwards compatibility
      async function loadCreditPayments() {
        await CreditPaymentManager.init();
        // Build the lookup from window.creditPaymentsCache which is populated by the manager
        if (window.creditPaymentsCache && window.creditPaymentsCache.length > 0) {
          return buildCreditPaymentLookup(window.creditPaymentsCache);
        }
        return {};
      }

      function buildCreditPaymentLookup(records) {
        const lookup = {};
        (records || []).forEach(record => {
          if (!record || !record.student_id) return;
          const studentKey = String(record.student_id);
          const dateStr = normalizeDateInput(record.created_at || record.class_date);
          if (!dateStr) return;
          if (!lookup[studentKey]) {
            lookup[studentKey] = {};
          }
          lookup[studentKey][dateStr] = { ...record, la_date: dateStr };
        });
        return lookup;
      }

      // ============================================================================
      // ABSENT MANAGER - Cloud Sync for Student Absences ‚òÅÔ∏è
      // ============================================================================
      /**
       * Absent Manager - Supabase Cloud Sync Version
       * - Tracks which students were absent on which dates
       * - Syncs across all devices via Supabase student_absences table
       * - Fallback to localStorage for offline support
       */
      // ============================================================
      // AUTOMATED ABSENCE EMAIL SYSTEM
      // ============================================================
      async function sendAbsenceEmail(studentId, dateStr) {
        try {
          debugLog('üìß Sending absence email...', { studentId, dateStr });
          
          // Get student information
          const students = window.studentsCache || [];
          const student = students.find(s => s.id === parseInt(studentId));
          
          if (!student) {
            throw new Error('Student not found');
          }
          
          debugLog('üìß Student email check:', { 
            name: student.name, 
            email: student.email, 
            emailType: typeof student.email 
          });
          
          if (!student.email) {
            throw new Error('Student has no email address');
          }
          
          // Parse email if it's JSON array string
          let cleanEmail = String(student.email).trim();
          
          // Check if email is a JSON array string like '["email@example.com"]'
          if (cleanEmail.startsWith('[') && cleanEmail.endsWith(']')) {
            try {
              const parsed = JSON.parse(cleanEmail);
              if (Array.isArray(parsed) && parsed.length > 0) {
                cleanEmail = String(parsed[0]).trim();
                debugLog('üìß Parsed email from JSON array:', cleanEmail);
              }
            } catch (e) {
              // console.warn('‚ö†Ô∏è Failed to parse email JSON:', e);
            }
          }
          
          // Validate email format
          const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
          
          if (!emailRegex.test(cleanEmail)) {
            throw new Error(`Invalid email format: "${cleanEmail}" - Please update student's email in Student Manager`);
          }
          
          // Format the date nicely
          const dateObj = new Date(dateStr + 'T00:00:00');
          const formattedDate = dateObj.toLocaleDateString('en-US', { 
            weekday: 'long', 
            year: 'numeric', 
            month: 'long', 
            day: 'numeric' 
          });
          
          // Generate email HTML
          const emailHTML = generateAbsenceEmailHTML(student.name, formattedDate, dateStr);
          
          debugLog('üìß Sending to email:', cleanEmail);
          
          // Send email via Supabase Edge Function
          const response = await fetch(`${SUPABASE_URL}/functions/v1/send-email`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
            },
            body: JSON.stringify({
              to: cleanEmail,
              subject: `‚ö†Ô∏è Absence Notice - ${formattedDate}`,
              html: emailHTML,
            }),
          });
          
          if (!response.ok) {
            const errorData = await response.json().catch(() => ({}));
            console.error('‚ùå Email API error response:', errorData);
            const errorMsg = errorData.error?.message || errorData.error || 'Unknown error';
            throw new Error(`Email API error: ${errorMsg}`);
          }
          
          const result = await response.json();
          
          // Check if the result contains an error (Resend returns success:true but includes error details)
          if (result.data && result.data.error) {
            console.error('‚ùå Email service error:', result.data.error);
            throw new Error(`Email service error: ${result.data.error.message || JSON.stringify(result.data.error)}`);
          }
          
          debugLog('‚úÖ Absence email sent successfully:', result);
          
          // Log to sent_emails and notifications tables
          try {
            const resendEmailId = result?.id || result?.data?.id || null;
            
            // 1. Log to sent_emails table (for Email System)
            const sentEmailRecord = {
              recipient_email: cleanEmail,
              recipient_name: student.name,
              subject: `‚ö†Ô∏è Absence Notice - ${formattedDate}`,
              html_content: emailHTML,
              template_name: 'Absence Notice',
              email_type: 'absence_notice',
              resend_id: resendEmailId,
              delivery_status: 'delivered',
              status: 'sent',
              sent_at: new Date().toISOString()
            };
            
            const { data: logData, error: logError } = await supabaseClient.from('sent_emails').insert([sentEmailRecord]).select();
            
            if (logError) {
              console.error('‚ö†Ô∏è Failed to log to sent_emails:', logError);
            } else {
              debugLog('‚úÖ Absence email logged to sent_emails:', logData[0]);
            }
            
            // 2. Log to notifications table (for Notification Center bell)
            const notificationRecord = {
              type: 'email_sent',
              category: 'email',
              title: 'Absence Notice Sent',
              description: `Sent absence notice to ${student.name} (${cleanEmail}) for ${formattedDate}`,
              student_name: student.name,
              metadata: {
                student_id: studentId,
                student_name: student.name,
                email: cleanEmail,
                absence_date: dateStr,
                email_type: 'absence_notice',
                subject: `‚ö†Ô∏è Absence Notice - ${formattedDate}`,
                html: emailHTML
              },
              timestamp: new Date().toISOString(),
              read: false,
              created_at: new Date().toISOString()
            };
            
            const { data: notifData, error: notifError } = await supabaseClient.from('notifications').insert([notificationRecord]).select();
            
            if (notifError) {
              console.error('‚ö†Ô∏è Failed to log to notifications:', notifError);
            } else {
              debugLog('‚úÖ Notification logged:', notifData[0]);
            }
            
          } catch (logErr) {
            console.error('‚ö†Ô∏è Error logging notifications (email still sent):', logErr);
          }
          
          return result;
        } catch (err) {
          console.error('‚ùå Error sending absence email:', err);
          throw err;
        }
      }
      
      function generateAbsenceEmailHTML(studentName, formattedDate, dateStr) {
        return `<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ARNOMA NCLEX-RN Email</title>
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      padding: 0;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      padding: 40px 20px;
    }
    .email-wrapper {
      max-width: 600px;
      margin: 0 auto;
    }
    .email-container {
      background-color: #ffffff;
      border-radius: 16px;
      overflow: hidden;
      box-shadow: 0 20px 60px rgba(0,0,0,0.3);
    }
    .email-header {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      padding: 45px 35px 35px;
      text-align: center;
    }
    .email-header img {
      width: 140px;
      height: 140px;
      margin-bottom: 15px;
      filter: drop-shadow(0 0 6px rgba(255,255,255,0.7))
              drop-shadow(0 0 12px rgba(255,255,255,0.4))
              drop-shadow(0 0 3px rgba(255,255,255,0.8));
      animation: fadeIn 1.5s ease-in-out;
    }
    .email-header h1 {
      color: #fff;
      margin: 0;
      font-size: 28px;
      letter-spacing: -0.5px;
    }
    @keyframes fadeIn {
      from { opacity: 0; transform: scale(0.9); }
      to { opacity: 1; transform: scale(1); }
    }
    .email-body {
      padding: 35px;
      color: #333;
      font-size: 16px;
      line-height: 1.6;
    }
    .email-body p {
      margin: 0 0 16px 0;
    }
    .info-box {
      background-color: #f6f8fe;
      border-left: 3px solid #3b82f6;
      border-radius: 10px;
      padding: 14px 18px;
      font-size: 15px;
      line-height: 1.5;
      color: #1e293b;
      margin: 20px 0;
      box-shadow: 0 2px 6px rgba(0,0,0,0.05);
    }
    .info-box p {
      margin: 6px 0;
      text-align: left;
    }
    .info-box strong {
      color: #1e40af;
    }
    .warning-box {
      background-color: #fef3c7;
      border-left: 3px solid #f59e0b;
      border-radius: 10px;
      padding: 14px 18px;
      font-size: 15px;
      line-height: 1.5;
      color: #78350f;
      margin: 20px 0;
      box-shadow: 0 2px 6px rgba(0,0,0,0.05);
    }
    .warning-box p {
      margin: 6px 0;
      text-align: left;
    }
    .highlight-box {
      background: linear-gradient(135deg, #ecfdf5 0%, #d1fae5 100%);
      border-left: 3px solid #10b981;
      border-radius: 10px;
      padding: 18px;
      font-size: 15px;
      line-height: 1.6;
      color: #065f46;
      margin: 24px 0;
      box-shadow: 0 2px 8px rgba(16, 185, 129, 0.1);
    }
    .highlight-box p {
      margin: 6px 0;
      text-align: left;
    }
    .highlight-box strong {
      color: #047857;
      font-size: 16px;
    }
    .divider {
      height: 1px;
      background: linear-gradient(to right, transparent, rgba(0,0,0,0.1) 20%, rgba(0,0,0,0.1) 80%, transparent);
      margin: 24px 0;
      border: none;
    }
    .email-footer {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: #fff;
      text-align: center;
      padding: 30px 20px;
    }
    .email-footer img {
      width: 100px;
      height: 100px;
      margin: 10px 0;
      filter: drop-shadow(0 0 5px rgba(255,255,255,0.6))
              drop-shadow(0 0 10px rgba(255,255,255,0.3))
              drop-shadow(0 0 2px rgba(255,255,255,0.8));
    }
    .email-footer p {
      margin: 6px 0;
      font-size: 13px;
    }
    @media (max-width: 600px) {
      body { padding: 20px 10px; }
      .email-body { padding: 25px 20px; font-size: 15px; }
      .email-header img { width: 110px; height: 110px; }
    }
  </style>
</head>
<body>
  <div class="email-wrapper">
    <div class="email-container">
      <!-- Header -->
      <div class="email-header">
        <img src="https://raw.githubusercontent.com/easylearnrn-hash/ARNOMA/main/richyfesta-logo.png" alt="ARNOMA Logo">
        <h1>Absence Notice</h1>
      </div>

      <!-- Body -->
      <div class="email-body">
        <p><strong>Hi ${studentName},</strong></p>
        
        <p>
          This email is to inform you that you have been marked as <strong>absent</strong> for the following class:
        </p>

        <div class="info-box">
          <p><strong>Class Date:</strong> ${formattedDate}</p>
        </div>

        <div class="warning-box">
          <p><strong>What this means:</strong></p>
          <p>‚Ä¢ Your attendance for this class has been recorded as absent</p>
          <p>‚Ä¢ If you no longer wish to attend the class, please notify the instructor</p>
        </div>

        <hr class="divider">

        <div class="highlight-box">
          <p><strong>üìö Want to Get the Class Notes?</strong></p>
          <p>If you would like to receive the notes we went over during this class, you can make the payment for the class and the notes will be sent to you <strong>within 30 minutes</strong>.</p>
          <p style="margin-top: 12px;">Simply make the payment and we'll email you the complete class materials right away!</p>
        </div>

        <hr class="divider">

        <p style="margin-top: 24px;">
          <strong>Need Help?</strong><br>
          Contact your instructor or reply to this email for assistance.
        </p>
      </div>

      <!-- Footer -->
      <div class="email-footer">
        <img src="https://raw.githubusercontent.com/easylearnrn-hash/ARNOMA/main/richyfesta-logo.png" alt="ARNOMA Logo">
        <p><strong style="font-size: 18px;">ARNOMA ‚Äì NCLEX RN</strong></p>
        <p style="font-size: 14px;">Professional NCLEX Preparation & Medical Education</p>
        <p style="font-size: 13px;">
          nclex.rn@arnoma.us<br>
          richy@arnoma.us<br>
          909-808-1818
        </p>
        <p style="font-size: 12px; color: #95a5a6;">
          ¬© ${new Date().getFullYear()} ARNOMA. All rights reserved.
        </p>
        <p style="font-size: 12px; color: #7f8c8d;">
          This is an automated notification from your ARNOMA NCLEX prep program.
        </p>
      </div>
    </div>
  </div>
</body>
</html>`;
      }

      // ============================================================
      // PAYMENT REMINDER EMAIL
      // ============================================================
      async function sendPaymentReminderEmail(studentId) {
        try {
          debugLog('üìß Sending payment reminder email...', { studentId });
          
          // Get student information
          const students = window.studentsCache || [];
          const student = students.find(s => s.id === parseInt(studentId));
          
          if (!student) {
            throw new Error('Student not found');
          }
          
          debugLog('üìß Student email check:', { 
            name: student.name, 
            email: student.email, 
            emailType: typeof student.email 
          });
          
          if (!student.email) {
            throw new Error('Student has no email address');
          }
          
          // Parse email if it's JSON array string
          let cleanEmail = String(student.email).trim();
          
          // Check if email is a JSON array string like '["email@example.com"]'
          if (cleanEmail.startsWith('[') && cleanEmail.endsWith(']')) {
            try {
              const parsed = JSON.parse(cleanEmail);
              if (Array.isArray(parsed) && parsed.length > 0) {
                cleanEmail = String(parsed[0]).trim();
                debugLog('üìß Parsed email from JSON array:', cleanEmail);
              }
            } catch (e) {
              // console.warn('‚ö†Ô∏è Failed to parse email JSON:', e);
            }
          }
          
          // Validate email format
          const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
          
          if (!emailRegex.test(cleanEmail)) {
            throw new Error(`Invalid email format: "${cleanEmail}" - Please update student's email in Student Manager`);
          }
          
          // Get student balance and price
          const balance = Number(student.balance) || 0;
          const pricePerClass = Number(student.price_per_class) || 0;
          
          // CRITICAL: Calculate ACTUAL unpaid classes from month data, not DOM
          // The balance field may be stale - count unpaid classes from the calendar's computed data
          let unpaidClassesFromCalendar = 0;
          let unpaidAmountFromCalendar = 0;
          const unpaidClassDetails = [];
          
          // Get the current month data from the calendar
          const { year: currentYear, month: currentMonth } = getCurrentViewYearMonth();
          const currentMonthData = monthCache.get(getMonthCacheKey(currentYear, currentMonth));
          
          if (currentMonthData && currentMonthData.dayMap) {
            // Iterate through all days in the current month
            Object.values(currentMonthData.dayMap).forEach(dayData => {
              // Check each group's students for this student
              (dayData.groups || []).forEach(group => {
                (group.students || []).forEach(studentEntry => {
                  // Match by student ID
                  if (String(studentEntry.id) === String(studentId) && studentEntry.status === 'unpaid') {
                    unpaidClassesFromCalendar++;
                    const amount = studentEntry.pricePerClass || pricePerClass;
                    unpaidAmountFromCalendar += amount;

                    const formattedDate = new Date(`${dayData.dateStr}T12:00:00`).toLocaleDateString('en-US', {
                      weekday: 'long',
                      year: 'numeric',
                      month: 'long',
                      day: 'numeric'
                    });
                    
                    unpaidClassDetails.push({
                      date: dayData.dateStr,
                      formattedDate,
                      amount
                    });
                  }
                });
              });
            });
          }
          
          // Use calendar data if we found unpaid classes, otherwise fall back to balance
          const finalBalance = unpaidAmountFromCalendar > 0 ? unpaidAmountFromCalendar : balance;
          const finalPrice = pricePerClass || 15;
          
          // Generate email HTML (async now - loads from Email System)
          const emailHTML = await generatePaymentReminderEmailHTML(
            student.name,
            finalBalance,
            finalPrice,
            studentId,
            unpaidClassDetails
          );
          
          debugLog('üìß Sending payment reminder to:', cleanEmail);
          
          // Send email via Supabase Edge Function
          const response = await fetch(`${SUPABASE_URL}/functions/v1/send-email`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
            },
            body: JSON.stringify({
              to: cleanEmail,
              subject: `Payment Reminder - ARNOMA NCLEX-RN`,
              html: emailHTML,
            }),
          });
          
          if (!response.ok) {
            const errorData = await response.json().catch(() => ({}));
            console.error('‚ùå Email API error response:', errorData);
            const errorMsg = errorData.error?.message || errorData.error || 'Unknown error';
            throw new Error(`Email API error: ${errorMsg}`);
          }
          
          const result = await response.json();
          
          // Check if the result contains an error
          if (result.data && result.data.error) {
            console.error('‚ùå Email service error:', result.data.error);
            throw new Error(`Email service error: ${result.data.error.message || JSON.stringify(result.data.error)}`);
          }
          
          debugLog('‚úÖ Payment reminder email sent successfully:', result);
          
          debugLog('üî• ABOUT TO LOG EMAIL TO sent_emails TABLE');
          
          // CRITICAL: Log to BOTH notification systems
          try {
            const resendEmailId = result?.id || result?.data?.id || null;
            
            // 1. Log to sent_emails table (for Email System)
            const sentEmailRecord = {
              recipient_email: cleanEmail,
              recipient_name: student.name,
              subject: `Payment Reminder - ARNOMA NCLEX-RN`,
              html_content: emailHTML,
              template_name: 'Payment Reminder',
              email_type: 'payment_reminder',
              resend_id: resendEmailId,
              delivery_status: 'delivered',
              status: 'sent',
              sent_at: new Date().toISOString()
            };
            
            debugLog('üìù sentEmailRecord:', sentEmailRecord);
            
            const { data: logData, error: logError } = await supabaseClient
              .from('sent_emails')
              .insert([sentEmailRecord])
              .select();
            
            debugLog('üíæ Supabase sent_emails response:', { logData, logError });
            
            if (logError) {
              console.error('‚ö†Ô∏è Failed to log to sent_emails:', logError);
            } else {
              debugLog('‚úÖ Payment reminder logged to sent_emails:', logData[0]);
            }
            
            // 2. Log to notifications table (for Notification Center bell)
            const notificationRecord = {
              type: 'email_sent',
              category: 'email',  // For UI rendering (getCategoryIcon)
              title: 'Payment Reminder Sent',
              description: `Sent payment reminder to ${student.name} (${cleanEmail}) for $${finalBalance}`,
              student_name: student.name,
              metadata: {
                student_id: studentId,
                student_name: student.name,
                email: cleanEmail,
                amount: finalBalance,
                email_type: 'payment_reminder',
                subject: `Payment Reminder - ARNOMA NCLEX-RN`,
                html: emailHTML  // Full email HTML for preview
              },
              timestamp: new Date().toISOString(),
              read: false,
              created_at: new Date().toISOString()
            };
            
            const { data: notifData, error: notifError } = await supabaseClient
              .from('notifications')
              .insert([notificationRecord])
              .select();
            
            debugLog('üîî Supabase notifications response:', { notifData, notifError });
            
            if (notifError) {
              console.error('‚ö†Ô∏è Failed to log to notifications:', notifError);
            } else {
              debugLog('‚úÖ Notification logged:', notifData[0]);
            }
            
          } catch (logErr) {
            console.error('‚ö†Ô∏è Error logging notifications (email still sent):', logErr);
          }
          
          return result;
        } catch (err) {
          console.error('‚ùå Error sending payment reminder email:', err);
          throw err;
        }
      }
      
      // Generate email HTML using Email System template structure
      function generateEmailHTML(title, bodyContent) {
        return `<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ARNOMA NCLEX-RN Email</title>
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      padding: 0;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      padding: 40px 20px;
    }
    .email-wrapper {
      max-width: 600px;
      margin: 0 auto;
    }
    .email-container {
      background-color: #ffffff;
      border-radius: 16px;
      overflow: hidden;
      box-shadow: 0 20px 60px rgba(0,0,0,0.3);
    }
    .email-header {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      padding: 45px 35px 35px;
      text-align: center;
    }
    .email-header img {
      width: 140px;
      height: 140px;
      margin-bottom: 15px;
      filter: drop-shadow(0 0 6px rgba(255,255,255,0.7))
              drop-shadow(0 0 12px rgba(255,255,255,0.4))
              drop-shadow(0 0 3px rgba(255,255,255,0.8));
      animation: fadeIn 1.5s ease-in-out;
    }
    .email-header h1 {
      color: #fff;
      margin: 0;
      font-size: 28px;
      letter-spacing: -0.5px;
    }
    @keyframes fadeIn {
      from { opacity: 0; transform: scale(0.9); }
      to { opacity: 1; transform: scale(1); }
    }
    .email-body {
      padding: 35px;
      color: #333;
      font-size: 16px;
      line-height: 1.6;
    }
    .email-body p {
      margin: 0 0 16px 0;
    }
    .email-body img {
      display: block;
      max-width: 100%;
      height: auto;
      margin: 20px auto;
      border-radius: 12px;
      box-shadow: 0 6px 20px rgba(0,0,0,0.15);
    }
    .payment-frame {
      background-color: #f8f9fc;
      border: 2px solid #e5e7eb;
      border-radius: 12px;
      padding: 20px;
      margin: 24px 0;
      text-align: center;
      box-shadow: 0 2px 8px rgba(0,0,0,0.08);
    }
    .payment-frame img {
      margin: 12px auto;
      border-radius: 8px;
      box-shadow: none;
    }
    .info-box {
      background-color: #f6f8fe;
      border-left: 3px solid #3b82f6;
      border-radius: 10px;
      padding: 14px 18px;
      font-size: 15px;
      line-height: 1.5;
      color: #1e293b;
      margin: 20px 0;
      box-shadow: 0 2px 6px rgba(0,0,0,0.05);
    }
    .info-box p {
      margin: 6px 0;
      text-align: left;
    }
    .divider {
      height: 1px;
      background: linear-gradient(to right, transparent, rgba(255,255,255,0.3) 20%, rgba(255,255,255,0.3) 80%, transparent);
      margin: 24px 0;
      border: none;
    }
    .email-footer {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: #fff;
      text-align: center;
      padding: 30px 20px;
    }
    .email-footer img {
      width: 100px;
      height: 100px;
      margin: 10px 0;
      filter: drop-shadow(0 0 5px rgba(255,255,255,0.6))
              drop-shadow(0 0 10px rgba(255,255,255,0.3))
              drop-shadow(0 0 2px rgba(255,255,255,0.8));
    }
    .email-footer p {
      margin: 6px 0;
      font-size: 13px;
    }
    @media (max-width: 600px) {
      body { padding: 20px 10px; }
      .email-body { padding: 25px 20px; font-size: 15px; }
      .email-header img { width: 110px; height: 110px; }
    }
  </style>
</head>
<body>
  <div class="email-wrapper">
    <div class="email-container">
      <div class="email-header">
        <img src="https://raw.githubusercontent.com/easylearnrn-hash/ARNOMA/main/richyfesta-logo.png" alt="ARNOMA Logo">
        <h1>${title}</h1>
      </div>

      <div class="email-body">
        ${bodyContent}
      </div>

      <div class="email-footer">
        <img src="https://raw.githubusercontent.com/easylearnrn-hash/ARNOMA/main/richyfesta-logo.png" alt="ARNOMA Logo">
        <p><strong style="font-size: 18px;">ARNOMA ‚Äì NCLEX RN</strong></p>
        <p style="font-size: 14px;">Professional NCLEX Preparation & Medical Education</p>
        <p style="font-size: 13px;">
          nclex.rn@arnoma.us<br>
          richy@arnoma.us<br>
          909-808-1818
        </p>
        <p style="font-size: 12px; color: #95a5a6;">
          ¬© 2025 ARNOMA. All rights reserved.
        </p>
        <p style="font-size: 12px; color: #7f8c8d;">
          This is an automated notification from your ARNOMA NCLEX prep program.
        </p>
      </div>
    </div>
  </div>
</body>
</html>`;
      }

      async function generatePaymentReminderEmailHTML(studentName, balance, pricePerClass, studentId = null, unpaidClassDetails = []) {
        // Helper function to format date beautifully
        function formatClassDate(dateStr) {
          const date = new Date(dateStr + 'T12:00:00');
          const options = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
          return date.toLocaleDateString('en-US', options);
        }
        const normalizedPricePerClass = Number(pricePerClass) > 0 ? Number(pricePerClass) : 15;
        const unpaidClasses = (Array.isArray(unpaidClassDetails) ? unpaidClassDetails : []).map(cls => {
          const rawDate = cls.date || cls.class_date || null;
          const formattedDate = cls.formattedDate || (rawDate ? formatClassDate(rawDate) : 'Class date pending');
          const amount = Number(cls.amount);
          return {
            date: rawDate,
            formattedDate,
            amount: Number.isFinite(amount) && amount > 0 ? amount : normalizedPricePerClass
          };
        });
        
        // Calculate unpaid amount from student balance
        // The calendar red dots show unpaid classes, and balance reflects this
        let actualAmountDue = 0;
        let actualUnpaidCount = 0;
        
  if (studentId && balance && balance > 0) {
          // Student has positive balance = money owed
          actualAmountDue = balance;
          
          // Calculate number of unpaid classes based on price per class
          actualUnpaidCount = Math.ceil(actualAmountDue / normalizedPricePerClass);
          
          if (DEBUG_MODE) {
            console.log('üí∞ Payment reminder - using student balance:', {
              studentId,
              studentName,
              balance,
              pricePerClass: normalizedPricePerClass,
              unpaidCount: actualUnpaidCount,
              amountDue: actualAmountDue
            });
          }
        } else {
          if (DEBUG_MODE) {
            console.log('üí∞ Payment reminder - no balance owed:', {
              studentId,
              studentName,
              balance
            });
          }
        }
        
        // Build unpaid classes summary HTML
        let unpaidClassesSummary = '';
        
        // Calculate actual amounts from unpaid classes
        if (unpaidClasses.length > 0) {
          actualUnpaidCount = unpaidClasses.length;
          actualAmountDue = unpaidClasses.reduce((sum, cls) => sum + cls.amount, 0);
          
          if (unpaidClasses.length === 1) {
            // Single unpaid class - simple format
            unpaidClassesSummary = `
              <div style="background: #f0f4ff; border-left: 4px solid #667eea; padding: 16px; margin: 16px 0; border-radius: 6px;">
                <p style="margin: 4px 0; font-size: 15px;"><strong>üìÖ ${unpaidClasses[0].formattedDate}</strong></p>
                <p style="margin: 4px 0; font-size: 15px;"><strong>Amount Due:</strong> $${unpaidClasses[0].amount.toFixed(2)}</p>
              </div>
            `;
          } else {
            // Multiple unpaid classes - beautiful list
            const classList = unpaidClasses.map((cls, index) => `
              <div style="background: ${index === unpaidClasses.length - 1 ? '#fff9e6' : '#ffffff'}; padding: 12px; margin: 8px 0; border-radius: 6px; border: 1px solid #e5e7eb;">
                <p style="margin: 4px 0; font-size: 14px; color: #6b7280;">Class ${index + 1}</p>
                <p style="margin: 4px 0; font-size: 15px;"><strong>${index === unpaidClasses.length - 1 ? 'üëâ ' : ''}${cls.formattedDate}</strong></p>
                <p style="margin: 4px 0; font-size: 15px; text-align: right;"><strong>$${cls.amount.toFixed(2)}</strong></p>
              </div>
            `).join('');
            
            unpaidClassesSummary = `
              <div style="background: #f9fafb; border: 2px solid #e5e7eb; border-radius: 12px; padding: 20px; margin: 20px 0;">
                <h3 style="margin: 0 0 16px 0; color: #764ba2; font-size: 18px;">üí≥ Outstanding Classes</h3>
                ${classList}
                <div style="background: #667eea; color: white; padding: 12px; margin: 12px 0 0 0; border-radius: 6px; text-align: right;">
                  <strong style="font-size: 16px;">Total Amount Due: $${actualAmountDue.toFixed(2)}</strong>
                </div>
              </div>
            `;
          }
        } else {
          // Fallback: calculate from balance if we couldn't fetch classes
          const normalizedBalance = Number(balance) || 0;
          actualAmountDue = normalizedBalance > 0 ? normalizedBalance : 0;
          
          // Validate pricePerClass to prevent NaN
          actualUnpaidCount = Math.ceil(actualAmountDue / normalizedPricePerClass);
          
          // Ensure actualUnpaidCount is a valid number
          if (!Number.isFinite(actualUnpaidCount) || actualUnpaidCount < 0) {
            actualUnpaidCount = 0;
          }
          
          debugLog('üí∞ Using fallback calculation:', {
            balance: normalizedBalance,
            actualAmountDue,
            pricePerClass: normalizedPricePerClass,
            unpaidCount: actualUnpaidCount
          });
          
          unpaidClassesSummary = `${actualUnpaidCount} unpaid ${actualUnpaidCount === 1 ? 'class' : 'classes'} - Total: $${actualAmountDue.toFixed(2)}`;
        }
        
        try {
          // Try to load Payment Reminder template from Email System (Supabase)
          const { data: templates, error } = await supabaseClient
            .from('email_templates')
            .select('*')
            .eq('name', 'Payment Reminder')
            .single();
          
          if (!error && templates && templates.body) {
            debugLog('‚úÖ Using Payment Reminder template from Email System');
            debugLog(`üìä Payment details: ${actualUnpaidCount} classes, $${actualAmountDue.toFixed(2)} total`);
            
            // Replace template variables with actual data (case-insensitive)
            let emailHTML = templates.body
              .replace(/\{\{StudentName\}\}/gi, studentName)
              .replace(/\{\{UnpaidClasses\}\}/gi, unpaidClassesSummary)
              .replace(/\{\{ClassDate\}\}/gi, new Date().toLocaleDateString())
              .replace(/\{\{PricePerClass\}\}/gi, normalizedPricePerClass.toFixed(2))
              .replace(/\{\{Balance\}\}/gi, actualAmountDue.toFixed(2))
              .replace(/\{\{AmountDue\}\}/gi, actualAmountDue.toFixed(2))
              .replace(/\{\{UnpaidClassCount\}\}/gi, actualUnpaidCount.toString())
              .replace(/\{\{TeacherEmail\}\}/gi, 'arnomaschool@gmail.com')
              .replace(/\{\{TeacherName\}\}/gi, 'ARNOMA Team');
            
            return emailHTML;
          }
        } catch (e) {
          // console.warn('‚ö†Ô∏è Could not load template from Email System, using fallback:', e);
        }
        
        // FALLBACK: Use hardcoded template if Email System template not found
        debugLog('‚ÑπÔ∏è Using fallback payment reminder template');
        const fallbackHTML = `<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ARNOMA NCLEX-RN Email</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica Neue', Arial, sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        padding: 20px;
        margin: 0;
      }

      .email-wrapper {
        width: 100%;
        max-width: 600px;
        margin: 0 auto;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        padding: 24px;
        border-radius: 16px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      }

      .email-container {
        background: white;
        border-radius: 12px;
        overflow: hidden;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
      }

      .email-header {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        padding: 40px 30px;
        text-align: center;
        position: relative;
        overflow: hidden;
      }

      .email-header::before {
        content: '';
        position: absolute;
        top: -50%;
        left: -50%;
        width: 200%;
        height: 200%;
        background: radial-gradient(circle, rgba(255, 255, 255, 0.1) 0%, transparent 70%);
        /* REMOVED: animation: pulse 15s ease-in-out infinite; - causing unnecessary GPU load */
        animation: none;
      }

      @keyframes pulse {
        0%,
        100% {
          transform: scale(1);
          opacity: 0.5;
        }
        50% {
          transform: scale(1.1);
          opacity: 0.8;
        }
      }

      .email-header img {
        width: 120px;
        height: auto;
        margin-bottom: 20px;
        position: relative;
        z-index: 1;
        filter: drop-shadow(0 4px 6px rgba(0, 0, 0, 0.1)) drop-shadow(0 0 10px rgba(255, 255, 255, 0.6)) drop-shadow(0 0 20px rgba(255, 255, 255, 0.4));
      }

      .email-header h1 {
        color: white;
        font-size: 32px;
        font-weight: 700;
        margin: 0;
        position: relative;
        z-index: 1;
        text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }

      .email-body {
        padding: 40px 30px;
        color: #1f2937;
        line-height: 1.8;
        background: white;
      }

      .email-body p {
        margin: 16px 0;
        font-size: 16px;
        color: #374151;
      }

      .email-body strong {
        color: #764ba2;
        font-weight: 600;
      }

      .info-box {
        background-color: #f6f8fe;
        border-left: 3px solid #3b82f6;
        border-radius: 10px;
        padding: 14px 18px;
        font-size: 15px;
        line-height: 1.5;
        color: #1e293b;
        margin: 20px 0;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.05);
      }

      .info-box p {
        margin: 6px 0;
        text-align: left;
      }

      .payment-instructions {
        background: #f9fafb;
        border-radius: 12px;
        padding: 24px;
        margin: 24px 0;
      }

      .payment-instructions h3 {
        color: #764ba2;
        font-size: 20px;
        margin-bottom: 16px;
        font-weight: 600;
      }

      .payment-instructions p {
        margin: 12px 0;
        color: #4b5563;
      }

      .payment-frame {
        background: linear-gradient(135deg, rgba(102, 126, 234, 0.05), rgba(118, 75, 162, 0.05));
        border: 2px solid rgba(118, 75, 162, 0.2);
        border-radius: 16px;
        padding: 32px;
        margin: 32px 0;
        text-align: center;
        box-shadow: 0 4px 12px rgba(102, 126, 234, 0.1);
      }

      .payment-frame p {
        margin: 12px 0;
        font-size: 18px;
        color: #1f2937;
      }

      .payment-frame img {
        max-width: 240px;
        height: auto;
        margin: 20px auto;
        display: block;
        border-radius: 12px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      }

      .zelle-number {
        font-size: 24px;
        font-weight: 700;
        color: #764ba2;
        margin: 16px 0;
        letter-spacing: 1px;
      }

      .email-footer {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        padding: 32px 30px;
        text-align: center;
        color: white;
      }

      .email-footer img {
        width: 80px;
        height: auto;
        margin-bottom: 16px;
        filter: brightness(0) invert(1);
        opacity: 0.9;
      }

      .email-footer p {
        margin: 8px 0;
        font-size: 14px;
        color: rgba(255, 255, 255, 0.9);
      }

      .email-footer strong {
        color: white;
        font-weight: 600;
      }

      .divider {
        height: 1px;
        background: linear-gradient(to right, transparent, rgba(118, 75, 162, 0.3), transparent);
        margin: 24px 0;
      }

      @media only screen and (max-width: 600px) {
        .email-wrapper {
          padding: 16px;
        }

        .email-header {
          padding: 30px 20px;
        }

        .email-header h1 {
          font-size: 24px;
        }

        .email-body {
          padding: 24px 20px;
        }

        .payment-frame {
          padding: 20px;
        }

        .payment-frame img {
          max-width: 200px;
        }
      }
    </style>
  </head>
  <body>
    <div class="email-wrapper">
      <div class="email-container">
        <!-- Header -->
        <div class="email-header">
          <img
            src="https://raw.githubusercontent.com/easylearnrn-hash/ARNOMA/main/richyfesta-logo.png"
            alt="ARNOMA Logo"
          />
          <h1>Payment Reminder</h1>
        </div>

        <!-- Body -->
        <div class="email-body">
          <p>
            Hello
            <strong>${studentName}</strong>
            ,
          </p>

          <p>This is a quick, automated check regarding your recent classes:</p>

          <div class="info-box">
            <p><strong>${unpaidClassesSummary}</strong></p>
          </div>

          <p>Our records show that your payment hasn't been posted yet.</p>

          <div class="divider"></div>

          <div class="payment-instructions">
            <h3>What to do:</h3>

            <p>
              <strong>If you have already paid:</strong>
              <br />
              Great! Please simply reply with the screenshot of your transfer. That's all we need to update our log and
              ensure you don't receive any more reminders.
            </p>

            <p>
              <strong>If you still plan to pay:</strong>
              <br />
              Please submit the payment at your earliest convenience. The system can only process and send your notes
              once payment is confirmed.
            </p>
          </div>

          <div class="divider"></div>

          <!-- Payment Frame -->
          <div class="payment-frame">
            <p style="font-size: 20px; margin-bottom: 8px">
              <strong>
                Send Money with
                <span style="color: #764ba2">Zelle¬Æ</span>
              </strong>
            </p>
            <p style="font-size: 14px; color: #6b7280; margin-bottom: 20px">Scan in your banking app to pay.</p>

            <p class="zelle-number">909-300-5155</p>

            <img
              src="https://raw.githubusercontent.com/easylearnrn-hash/ARNOMA/main/Arnoma%20Zelle.JPG"
              alt="Zelle QR Code"
            />

            <p style="font-size: 16px; color: #9ca3af; margin-top: 16px">
              <strong style="color: #764ba2">Zelle</strong>
            </p>
          </div>

          <p style="margin-top: 32px">Thank you for your prompt attention to this!</p>

          <p style="margin-top: 24px">
            Best regards,
            <br />
            <strong style="color: #764ba2">ARNOMA Team</strong>
          </p>
        </div>

        <!-- Footer -->
        <div class="email-footer">
          <img
            src="https://raw.githubusercontent.com/easylearnrn-hash/ARNOMA/main/richyfesta-logo.png"
            alt="ARNOMA Logo"
          />
          <p><strong>ARNOMA ‚Äì NCLEX RN</strong></p>
          <p style="margin-top: 12px">nclex.rn@arnoma.us | richy@arnoma.us | 909-808-1818</p>
          <p style="margin-top: 16px; font-size: 12px; opacity: 0.8">¬© 2025 ARNOMA. All rights reserved.</p>
        </div>
      </div>
    </div>
  </body>
</html>`;
        
        return fallbackHTML;
      }

      // Credit Added Email Function
      function generateCreditAddedEmailHTML(studentName, amount, originalDate) {
        const formattedAmount = new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD' }).format(amount);
        const formattedDate = new Date(originalDate + 'T12:00:00').toLocaleDateString('en-US', { 
          weekday: 'long', 
          year: 'numeric', 
          month: 'long', 
          day: 'numeric' 
        });

        return `<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ARNOMA NCLEX-RN Email</title>
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      padding: 0;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      padding: 40px 20px;
    }
    .email-wrapper {
      max-width: 600px;
      margin: 0 auto;
    }
    .email-container {
      background-color: #ffffff;
      border-radius: 16px;
      overflow: hidden;
      box-shadow: 0 20px 60px rgba(0,0,0,0.3);
    }
    .email-header {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      padding: 45px 35px 35px;
      text-align: center;
    }
    .email-header img {
      width: 140px;
      height: 140px;
      margin-bottom: 15px;
      filter: drop-shadow(0 0 6px rgba(255,255,255,0.7))
              drop-shadow(0 0 12px rgba(255,255,255,0.4))
              drop-shadow(0 0 3px rgba(255,255,255,0.8));
      animation: fadeIn 1.5s ease-in-out;
    }
    .email-header h1 {
      color: #fff;
      margin: 0;
      font-size: 28px;
      letter-spacing: -0.5px;
    }
    @keyframes fadeIn {
      from { opacity: 0; transform: scale(0.9); }
      to { opacity: 1; transform: scale(1); }
    }
    .email-body {
      padding: 35px;
      color: #333;
      font-size: 16px;
      line-height: 1.6;
    }
    .email-body p {
      margin: 0 0 16px 0;
    }
    .info-box {
      background-color: #fef9e7;
      border-left: 3px solid #ffeb3b;
      border-radius: 10px;
      padding: 14px 18px;
      font-size: 15px;
      line-height: 1.5;
      color: #1e293b;
      margin: 20px 0;
      box-shadow: 0 2px 6px rgba(0,0,0,0.05);
    }
    .info-box p {
      margin: 6px 0;
      text-align: left;
    }
    .info-box strong {
      color: #f59e0b;
    }
    .warning-box {
      background-color: #fef3c7;
      border-left: 3px solid #f59e0b;
      border-radius: 10px;
      padding: 14px 18px;
      font-size: 15px;
      line-height: 1.5;
      color: #78350f;
      margin: 20px 0;
      box-shadow: 0 2px 6px rgba(0,0,0,0.05);
    }
    .warning-box p {
      margin: 6px 0;
      text-align: left;
    }
    .highlight-box {
      background: linear-gradient(135deg, #fffbeb 0%, #fef3c7 100%);
      border-left: 3px solid #ffeb3b;
      border-radius: 10px;
      padding: 18px;
      font-size: 15px;
      line-height: 1.6;
      color: #78350f;
      margin: 24px 0;
      box-shadow: 0 2px 8px rgba(255, 235, 59, 0.2);
    }
    .highlight-box p {
      margin: 6px 0;
      text-align: left;
    }
    .highlight-box strong {
      color: #f59e0b;
      font-size: 16px;
    }
    .divider {
      height: 1px;
      background: linear-gradient(to right, transparent, rgba(0,0,0,0.1) 20%, rgba(0,0,0,0.1) 80%, transparent);
      margin: 24px 0;
      border: none;
    }
    .email-footer {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: #fff;
      text-align: center;
      padding: 30px 20px;
    }
    .email-footer img {
      width: 100px;
      height: 100px;
      margin: 10px 0;
      filter: drop-shadow(0 0 5px rgba(255,255,255,0.6))
              drop-shadow(0 0 10px rgba(255,255,255,0.3))
              drop-shadow(0 0 2px rgba(255,255,255,0.8));
    }
    .email-footer p {
      margin: 6px 0;
      font-size: 13px;
    }
    @media (max-width: 600px) {
      body { padding: 20px 10px; }
      .email-body { padding: 25px 20px; font-size: 15px; }
      .email-header img { width: 110px; height: 110px; }
    }
  </style>
</head>
<body>
  <div class="email-wrapper">
    <div class="email-container">
      <!-- Header -->
      <div class="email-header">
        <img src="https://raw.githubusercontent.com/easylearnrn-hash/ARNOMA/main/richyfesta-logo.png" alt="ARNOMA Logo">
        <h1>üí≥ Payment Applied as Credit</h1>
      </div>

      <!-- Body -->
      <div class="email-body">
        <p><strong>Hi ${studentName},</strong></p>
        
        <p>
          We're writing to inform you that a payment of <strong style="color: #f59e0b;">${formattedAmount}</strong> 
          has been applied as <strong style="color: #f59e0b;">credit</strong> to your account.
        </p>

        <div class="info-box">
          <p><strong>Credit Details:</strong></p>
          <p><strong>Amount:</strong> ${formattedAmount}</p>
          <p><strong>Original Payment Date:</strong> ${formattedDate}</p>
          <p><strong>Reason:</strong> No outstanding balance at time of payment</p>
        </div>

        <div class="highlight-box">
          <p><strong>üí° What This Means:</strong></p>
          <p>Your payment was received, but there were no unpaid classes to allocate it to. Instead of holding it as unallocated, we've added it as credit to your account for maximum flexibility.</p>
          <p style="margin-top: 12px;"><strong>The credit will be automatically deducted from future class charges.</strong></p>
        </div>

        <hr class="divider">

        <p style="margin-top: 24px;">
          This credit has been added to your account and will automatically be applied to future classes. 
          You can view your current credit balance anytime in your student portal.
        </p>

        <hr class="divider">

        <p style="margin-top: 24px;">
          <strong>Need Help?</strong><br>
          If you have any questions about this credit or your account balance, please don't hesitate to reach out to us.
        </p>
      </div>

      <!-- Footer -->
      <div class="email-footer">
        <img src="https://raw.githubusercontent.com/easylearnrn-hash/ARNOMA/main/richyfesta-logo.png" alt="ARNOMA Logo">
        <p><strong style="font-size: 18px;">ARNOMA ‚Äì NCLEX RN</strong></p>
        <p style="font-size: 14px;">Professional NCLEX Preparation & Medical Education</p>
        <p style="font-size: 13px;">
          nclex.rn@arnoma.us<br>
          richy@arnoma.us<br>
          909-808-1818
        </p>
        <p style="font-size: 12px; color: #95a5a6;">
          ¬© ${new Date().getFullYear()} ARNOMA. All rights reserved.
        </p>
        <p style="font-size: 12px; color: #7f8c8d;">
          This is an automated notification from your ARNOMA NCLEX prep program.
        </p>
      </div>
    </div>
  </div>
</body>
</html>`;
      }

      // ============================================================
      // ABSENT MANAGER
      // ============================================================
      window.AbsentManager = (function () {
        // Absences data structure: { studentId: { 'YYYY-MM-DD': true } }
        let absences = {};
        let isInitialized = false;

        // Load absences from Supabase
        async function loadAbsences() {
          try {
            debugLog('‚òÅÔ∏è Loading absences from Supabase...');
            const { data, error } = await supabaseClient.from('student_absences').select('*');

            if (error) {
              console.error('‚ùå Error loading absences from Supabase:', error);
              loadAbsencesFromLocalStorage();
              return;
            }

            // Convert array to nested object: { studentId: { 'YYYY-MM-DD': true } }
            absences = {};
            let supabaseCount = 0;
            (data || []).forEach(record => {
              const studentId = record.student_id != null ? String(record.student_id) : null;
              const dateStr = normalizeDateInput(record.class_date || record.date);

              if (!studentId || !dateStr) {
                // console.warn('‚ö†Ô∏è AbsentManager: Skipping invalid record:', record);
                return;
              }
              if (!absences[studentId]) {
                absences[studentId] = {};
              }
              absences[studentId][dateStr] = true;
              supabaseCount++;
            });
            
            // Always merge with localStorage as fallback (in case of RLS issues)
            const localAbsences = getAbsencesFromLocalStorage();
            if (localAbsences && Object.keys(localAbsences).length > 0) {
              // Merge localStorage data into absences
              for (const studentId in localAbsences) {
                if (!absences[studentId]) {
                  absences[studentId] = {};
                }
                for (const dateStr in localAbsences[studentId]) {
                  if (localAbsences[studentId][dateStr]) {
                    absences[studentId][dateStr] = true;
                  }
                }
              }
            }
          } catch (err) {
            console.error('‚ùå Exception loading absences:', err);
            loadAbsencesFromLocalStorage();
          }
        }

        // Save absences to Supabase
        async function saveAbsences() {
          try {
            debugLog('‚òÅÔ∏è Saving absences to Supabase...');

            // Convert nested object to array of records
            const records = [];
            for (const studentId in absences) {
              for (const dateStr in absences[studentId]) {
                if (absences[studentId][dateStr]) {
                  records.push({
                    student_id: parseInt(studentId),
                    class_date: dateStr,
                  });
                }
              }
            }

            // Delete all existing records
            const { error: deleteError } = await supabaseClient.from('student_absences').delete().neq('id', 0);

            if (deleteError) {
              console.error('‚ùå Error deleting absences:', deleteError);
              saveAbsencesToLocalStorage();
              return;
            }

            // Insert new records
            if (records.length > 0) {
              const { error: insertError } = await supabaseClient.from('student_absences').insert(records);

              if (insertError) {
                console.error('‚ùå Error inserting absences:', insertError);
                saveAbsencesToLocalStorage();
                return;
              }
            }

            debugLog('‚úÖ Saved absences to Supabase:', records.length, 'records');
            saveAbsencesToLocalStorage(); // Keep localStorage as backup
          } catch (err) {
            console.error('‚ùå Exception saving absences:', err);
            saveAbsencesToLocalStorage();
          }
        }

        // Fallback: Load from localStorage
        function getAbsencesFromLocalStorage() {
          // Migrate from old format: absent:studentId:dateStr
          const localAbsences = {};
          for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key && key.startsWith('absent:')) {
              const [, studentId, dateStr] = key.split(':');
              if (localStorage.getItem(key) === 'true') {
                if (!localAbsences[studentId]) {
                  localAbsences[studentId] = {};
                }
                localAbsences[studentId][dateStr] = true;
              }
            }
          }
          return localAbsences;
        }

        function loadAbsencesFromLocalStorage() {
          debugLog('üì¶ Loading absences from localStorage (fallback)...');
          absences = getAbsencesFromLocalStorage();
          debugLog('üì¶ Loaded absences from localStorage:', Object.keys(absences).length, 'students');
        }

        // Fallback: Save to localStorage
        function saveAbsencesToLocalStorage() {
          debugLog('üì¶ Saving absences to localStorage (fallback)...');
          // Clear old absence keys
          const keysToRemove = [];
          for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key && key.startsWith('absent:')) {
              keysToRemove.push(key);
            }
          }
          keysToRemove.forEach(key => localStorage.removeItem(key));

          // Save new absences
          for (const studentId in absences) {
            for (const dateStr in absences[studentId]) {
              if (absences[studentId][dateStr]) {
                const key = `absent:${studentId}:${dateStr}`;
                localStorage.setItem(key, 'true');
              }
            }
          }
        }

        // Initialize: Load from Supabase
        async function init() {
          if (isInitialized) return;
          await loadAbsences();
          isInitialized = true;

          // Set up real-time subscription for cross-device sync
          const channel = supabaseClient
            .channel('student_absences_changes')
            .on('postgres_changes', { event: '*', schema: 'public', table: 'student_absences' }, async payload => {
              // Reload absences from Supabase to stay in sync
              await loadAbsences();
              // Refresh calendar if visible
              if (typeof clearMonthCache === 'function') {
                clearMonthCache();
              }
              if (typeof renderCalendar === 'function') {
                renderCalendar();
              }
            })
            .subscribe();
        }

        // Public API
        return {
          init,

          // Check if student is absent on a date
          isAbsent(studentId, dateStr) {
            const idKey = studentId != null ? String(studentId) : null;
            if (!idKey) return false;
            return !!(absences[idKey] && absences[idKey][dateStr]);
          },

          // Mark student as absent
          async markAbsent(studentId, dateStr) {
            const idKey = studentId != null ? String(studentId) : null;
            if (!idKey) return;
            if (!absences[idKey]) {
              absences[idKey] = {};
            }
            absences[idKey][dateStr] = true;
            
            // Save to localStorage first (primary storage due to RLS restrictions)
            saveAbsencesToLocalStorage();
            
            // Try to sync to Supabase (will fail silently if RLS blocks it)
            try {
              const { error } = await supabaseClient
                .from('student_absences')
                .upsert({
                  student_id: parseInt(studentId),
                  class_date: dateStr,
                }, {
                  onConflict: 'student_id,class_date'
                });
              
              if (error) {
                // console.warn('‚ö†Ô∏è Could not sync absence to Supabase (RLS restricted):', error.message);
                debugLog('‚úÖ Absence saved to localStorage');
              } else {
                debugLog('‚úÖ Absence saved to Supabase and localStorage');
              }
            } catch (err) {
              // console.warn('‚ö†Ô∏è Exception syncing absence to Supabase:', err.message);
              debugLog('‚úÖ Absence saved to localStorage');
            }
            
            // üìß AUTOMATICALLY SEND ABSENCE EMAIL
            debugLog(`üìß Attempting to send absence email for student ${studentId} on ${dateStr}`);
            try {
              const emailResult = await sendAbsenceEmail(studentId, dateStr);
              debugLog(`‚úÖ Absence email sent successfully:`, emailResult);
            } catch (emailErr) {
              console.error('‚ùå Failed to send absence email:', emailErr);
              console.error('   Error details:', {
                message: emailErr.message,
                stack: emailErr.stack
              });
              // Don't block absence marking if email fails
            }
          },

          // Remove absent mark
          async removeAbsent(studentId, dateStr) {
            const idKey = studentId != null ? String(studentId) : null;
            if (!idKey) return;
            if (absences[idKey]) {
              delete absences[idKey][dateStr];
              if (Object.keys(absences[idKey]).length === 0) {
                delete absences[idKey];
              }
            }
            
            // Save to localStorage first (primary storage due to RLS restrictions)
            saveAbsencesToLocalStorage();
            
            // Try to sync to Supabase (will fail silently if RLS blocks it)
            try {
              const { error } = await supabaseClient
                .from('student_absences')
                .delete()
                .eq('student_id', parseInt(studentId))
                .eq('class_date', dateStr);
              
              if (error) {
                // console.warn('‚ö†Ô∏è Could not sync absence removal to Supabase (RLS restricted):', error.message);
                debugLog('‚úÖ Absence removed from localStorage');
              } else {
                debugLog('‚úÖ Absence removed from Supabase and localStorage');
              }
            } catch (err) {
              // console.warn('‚ö†Ô∏è Exception syncing absence removal to Supabase:', err.message);
              debugLog('‚úÖ Absence removed from localStorage');
            }
          },

          // Reload from Supabase (for manual sync)
          async reloadFromSupabase() {
            debugLog('üîÑ Reloading absences from Supabase...');
            await loadAbsences();
          },
        };
      })();

      // ============================================================================
      // CREDIT PAYMENT MANAGER - Cloud Sync for Credit Payments ‚òÅÔ∏è
      // ============================================================================
      /**
       * Credit Payment Manager - Supabase Cloud Sync Version
       * - Tracks when student credit/balance is applied to pay for a class
       * - Syncs across all devices via Supabase
       * - Fallback to localStorage for offline support
       */
      window.CreditPaymentManager = (function () {
        // Credit payments data structure: { studentId: { 'YYYY-MM-DD': {amount, balance} } }
        let creditPayments = {};
        let isInitialized = false;

        // Load credit payments from Supabase
        async function loadCreditPayments() {
          try {
            debugLog('‚òÅÔ∏è Loading credit payments from Supabase...');
            const { data, error } = await supabaseClient.from('credit_payments').select('*');

            if (error) {
              console.error('‚ùå Error loading credit payments from Supabase:', error);
              loadCreditPaymentsFromLocalStorage();
              return;
            }

            // Convert array to nested object
            creditPayments = {};
            (data || []).forEach(record => {
              const studentId = record.student_id;
              const dateStr = record.class_date;

              if (!creditPayments[studentId]) {
                creditPayments[studentId] = {};
              }
              creditPayments[studentId][dateStr] = {
                amount: parseFloat(record.amount),
                balance: record.balance_after ? parseFloat(record.balance_after) : null,
              };
            });
          } catch (err) {
            console.error('‚ùå Exception loading credit payments:', err);
            loadCreditPaymentsFromLocalStorage();
          }
        }

        // Save credit payments to Supabase
        async function saveCreditPayments() {
          try {
            debugLog('‚òÅÔ∏è Saving credit payments to Supabase...');

            // Convert nested object to array of records
            const records = [];
            for (const studentId in creditPayments) {
              for (const dateStr in creditPayments[studentId]) {
                const payment = creditPayments[studentId][dateStr];
                records.push({
                  student_id: parseInt(studentId),
                  class_date: dateStr,
                  amount: payment.amount,
                  balance_after: payment.balance,
                });
              }
            }

            // Delete all existing records
            const { error: deleteError } = await supabaseClient.from('credit_payments').delete().neq('id', 0);

            if (deleteError) {
              console.error('‚ùå Error deleting credit payments:', deleteError);
              saveCreditPaymentsToLocalStorage();
              return;
            }

            // Insert new records
            if (records.length > 0) {
              const { error: insertError } = await supabaseClient.from('credit_payments').insert(records);

              if (insertError) {
                console.error('‚ùå Error inserting credit payments:', insertError);
                saveCreditPaymentsToLocalStorage();
                return;
              }
            }

            debugLog('‚úÖ Saved credit payments to Supabase:', records.length, 'records');
            saveCreditPaymentsToLocalStorage(); // Keep localStorage as backup
          } catch (err) {
            console.error('‚ùå Exception saving credit payments:', err);
            saveCreditPaymentsToLocalStorage();
          }
        }

        // Fallback: Load from localStorage
        function loadCreditPaymentsFromLocalStorage() {
          debugLog('üì¶ Loading credit payments from localStorage (fallback)...');
          creditPayments = {};
          for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key && key.startsWith('credit-payment:')) {
              const [, , studentId, dateStr] = key.split(':');
              const value = localStorage.getItem(key);
              if (value) {
                try {
                  const data = JSON.parse(value);
                  if (!creditPayments[studentId]) {
                    creditPayments[studentId] = {};
                  }
                  creditPayments[studentId][dateStr] = {
                    amount: data.amount,
                    balance: data.balance,
                  };
                } catch (e) {
                  console.error('Error parsing credit payment:', e);
                }
              }
            }
          }
          debugLog('üì¶ Loaded credit payments from localStorage:', Object.keys(creditPayments).length, 'students');
        }

        // Fallback: Save to localStorage
        function saveCreditPaymentsToLocalStorage() {
          debugLog('üì¶ Saving credit payments to localStorage (fallback)...');
          // Clear old credit payment keys
          const keysToRemove = [];
          for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key && key.startsWith('credit-payment:')) {
              keysToRemove.push(key);
            }
          }
          keysToRemove.forEach(key => localStorage.removeItem(key));

          // Save new credit payments
          for (const studentId in creditPayments) {
            for (const dateStr in creditPayments[studentId]) {
              const payment = creditPayments[studentId][dateStr];
              const key = `credit-payment:${studentId}:${dateStr}`;
              localStorage.setItem(key, JSON.stringify(payment));
            }
          }
        }

        // Initialize: Load from Supabase
        async function init() {
          if (isInitialized) return;
          debugLog('üöÄ Initializing CreditPaymentManager...');
          await loadCreditPayments();
          isInitialized = true;
        }

        // Public API
        return {
          init,

          // Check if credit was applied for a student on a date
          getCreditPayment(studentId, dateStr) {
            return creditPayments[studentId] && creditPayments[studentId][dateStr];
          },

          // Apply credit payment
          async applyCreditPayment(studentId, dateStr, amount, balance) {
            if (!creditPayments[studentId]) {
              creditPayments[studentId] = {};
            }
            creditPayments[studentId][dateStr] = { amount, balance };
            await saveCreditPayments();
          },

          // Remove credit payment
          async removeCreditPayment(studentId, dateStr) {
            if (creditPayments[studentId]) {
              delete creditPayments[studentId][dateStr];
              if (Object.keys(creditPayments[studentId]).length === 0) {
                delete creditPayments[studentId];
              }
            }
            await saveCreditPayments();
          },

          // Reload from Supabase (for manual sync)
          async reloadFromSupabase() {
            debugLog('üîÑ Reloading credit payments from Supabase...');
            await loadCreditPayments();
          },
        };
      })();
      
      // Initialize managers
      if (window.supabase) {
        window.AbsentManager.init().catch(err => {
          console.error('Failed to initialize AbsentManager:', err);
        });
        window.CreditPaymentManager.init().catch(err => {
          console.error('Failed to initialize CreditPaymentManager:', err);
        });
      }
      
      // Initialize all data
  absencesData = {};
      let skippedClassesData = {};
  creditPaymentsLookup = {};
      
      async function initializeData() {
        console.time('‚è±Ô∏è initializeData Total');
        debugLog('üöÄ Initializing calendar data...');
        debugLog('üåé Using timezone:', LA_TIMEZONE);
        
        // Verify current LA time
        const now = new Date();
        const laParts = getLAParts(now);
        debugLog('üïí Current LA time:', laParts ? `${laParts.year}-${laParts.month}-${laParts.day} ${laParts.hour}:${laParts.minute}` : 'Unable to determine');
        
        // ‚ö° LAZY LOADING: Calculate date range for current month +/- 2 months
        const currentYear = laParts ? Number(laParts.year) : new Date().getFullYear();
        const currentMonth = laParts ? Number(laParts.month) - 1 : new Date().getMonth();
        
        // Start date: 2 months before current month
        const startDate = new Date(currentYear, currentMonth - 2, 1);
        const startDateStr = startDate.toISOString().split('T')[0];
        
        // End date: 2 months after current month (last day of that month)
        const endDate = new Date(currentYear, currentMonth + 3, 0);
        const endDateStr = endDate.toISOString().split('T')[0];
        
        const dateRange = { start: startDateStr, end: endDateStr };
        debugLog('üìÖ Initial load range:', startDateStr, 'to', endDateStr, '(5 months total)');
        
        // ‚ö° LAZY LOADING: Track loaded range
        loadedPaymentRange = { start: startDateStr, end: endDateStr };
        
        // Load all data in parallel (students/groups: all, payments: range-limited)
        console.time('‚è±Ô∏è Parallel Data Load');
        
        // Time each individual load
        const loadPromises = [
          (async () => { console.time('  ‚Ü≥ loadStudents'); const r = await loadStudents(); console.timeEnd('  ‚Ü≥ loadStudents'); return r; })(),
          (async () => { console.time('  ‚Ü≥ loadGroups'); const r = await loadGroups(); console.timeEnd('  ‚Ü≥ loadGroups'); return r; })(),
          (async () => { console.time('  ‚Ü≥ loadPayments'); const r = await loadPayments(dateRange); console.timeEnd('  ‚Ü≥ loadPayments'); return r; })(),
          (async () => { console.time('  ‚Ü≥ loadAbsences'); const r = await loadAbsences(); console.timeEnd('  ‚Ü≥ loadAbsences'); return r; })(),
          (async () => { console.time('  ‚Ü≥ loadSkippedClasses'); const r = await loadSkippedClasses(); console.timeEnd('  ‚Ü≥ loadSkippedClasses'); return r; })(),
          (async () => { console.time('  ‚Ü≥ loadCreditPayments'); const r = await loadCreditPayments(); console.timeEnd('  ‚Ü≥ loadCreditPayments'); return r; })(),
          (async () => { console.time('  ‚Ü≥ loadManualPaymentMoves'); const r = await loadManualPaymentMovesFromSupabase(); console.timeEnd('  ‚Ü≥ loadManualPaymentMoves'); return r; })()
        ];
        
        const [students, groups, payments, absences, skipped, credits, manualMoves] = await Promise.all(loadPromises);
        console.timeEnd('‚è±Ô∏è Parallel Data Load');
        
        absencesData = absences;
        skippedClassesData = skipped;
        creditPaymentsLookup = credits;
        debugLog('üì¶ Manual payment moves ready:', manualMoves instanceof Map ? manualMoves.size : 0);
        clearMonthCache();
        calendarBaseEvents = [];
        currentMonthEventMap = {};
        currentMonthEventsFlat = [];
        lastMergedEventsCount = 0;
        
        // Set up real-time subscriptions for automatic updates
        console.time('‚è±Ô∏è Setup Realtime');
        setupRealtimeSubscriptions();
        console.timeEnd('‚è±Ô∏è Setup Realtime');
        
        // ‚ö° PROGRESSIVE LOADING: Render calendar with loaded data
        console.time('‚è±Ô∏è Progressive Render');
        renderCalendar();
        console.timeEnd('‚è±Ô∏è Progressive Render');
        
        console.timeEnd('‚è±Ô∏è initializeData Total');
      }

      // ‚ö° PERFORMANCE: Debounced render to prevent excessive re-renders
      let renderDebounceTimer = null;
      function debouncedRenderCalendar() {
        if (renderDebounceTimer) {
          clearTimeout(renderDebounceTimer);
        }
        renderDebounceTimer = setTimeout(() => {
          renderCalendar();
          renderDebounceTimer = null;
        }, 500); // Wait 500ms after last change before re-rendering
      }

      // Set up real-time subscriptions to auto-refresh when data changes
      function setupRealtimeSubscriptions() {
        // ‚ö° PERFORMANCE: Disabled realtime subscriptions to reduce CPU usage
        // Calendar now refreshes manually or on user interaction
        // To re-enable realtime updates, uncomment the subscriptions below
        
        /* REALTIME UPDATES DISABLED FOR PERFORMANCE
        
        // Subscribe to student changes (group, price, etc.)
        supabaseClient
          .channel('students_changes')
          .on('postgres_changes', { event: '*', schema: 'public', table: 'students' }, async payload => {
            // Reload students and re-render calendar
            await loadStudents();
            clearMonthCache();
            debouncedRenderCalendar();
          })
          .subscribe();

        // Subscribe to group changes (schedule, price, etc.)
        supabaseClient
          .channel('groups_changes')
          .on('postgres_changes', { event: '*', schema: 'public', table: 'groups' }, async payload => {
            // Reload groups and re-render calendar
            await loadGroups();
            clearMonthCache();
            debouncedRenderCalendar();
          })
          .subscribe();

        // Subscribe to payment changes
        supabaseClient
          .channel('payments_changes')
          .on('postgres_changes', { event: '*', schema: 'public', table: 'payments' }, async payload => {
            // Reload payments and re-render calendar
            await loadPayments();
            clearMonthCache();
            debouncedRenderCalendar();
          })
          .subscribe();

        // Subscribe to absences changes
        supabaseClient
          .channel('absences_changes')
          .on('postgres_changes', { event: '*', schema: 'public', table: 'absences' }, async payload => {
            try {
              // Absences affect per-day stats; only invalidate affected day if available
              const d = payload?.new?.class_date || payload?.old?.class_date;
              if (d) {
                const dateStr = formatDateYYYYMMDD(new Date(d));
                invalidateDayCache(dateStr);
              } else {
                clearMonthCache();
              }
              debouncedRenderCalendar();
            } catch (e) {
              if (DEBUG_MODE) {
                console.warn('‚ö†Ô∏è Absences realtime update issue', e);
              }
              clearMonthCache();
              debouncedRenderCalendar();
            }
          })
          .subscribe();

        // Subscribe to credit payments changes
        supabaseClient
          .channel('credit_payments_changes')
          .on('postgres_changes', { event: '*', schema: 'public', table: 'credit_payments' }, async payload => {
            try {
              // Credit payments can resolve unpaid for a specific class_date
              const d = payload?.new?.class_date || payload?.old?.class_date;
              if (d) {
                const dateStr = formatDateYYYYMMDD(new Date(d));
                invalidateDayCache(dateStr);
              } else {
                clearMonthCache();
              }
              debouncedRenderCalendar();
            } catch (e) {
              if (DEBUG_MODE) {
                console.warn('‚ö†Ô∏è Credit payments realtime update issue', e);
              }
              clearMonthCache();
              debouncedRenderCalendar();
            }
          })
          .subscribe();
        
        END REALTIME UPDATES */
        
        debugLog('‚ö° Performance Mode: Realtime subscriptions disabled. Calendar updates on manual refresh.');
      }


      const SIDEBAR_ALERT_LIMIT = 6;

      // Filter state
      const filters = {
        classes: true,
        payments: true,
        absences: true,
        skipped: true,
      };

      // ============================================================
      // MODULE POPUP SYSTEM
      // ============================================================
      
      /**
       * Open a module in a popup overlay
       */
      function openModulePopup(moduleUrl, moduleTitle) {
        console.log(`üì¶ Opening module popup: ${moduleTitle} (${moduleUrl})`);

        const overlay = document.getElementById('modulePopupOverlay');
        const iframe = document.getElementById('modulePopupIframe');

        if (!overlay || !iframe) {
          console.error('‚ùå Module popup elements not found');
          return;
        }

        // Force complete reload: clear iframe first, then load with cache buster
        iframe.src = 'about:blank';
        
        // Use setTimeout to ensure the blank loads first
        setTimeout(() => {
          const cacheBuster = `?reload=${Date.now()}`;
          iframe.src = moduleUrl + cacheBuster;
          console.log('üì¶ Loading module with cache buster:', moduleUrl + cacheBuster);
        }, 10);

        // Show overlay with animation
        overlay.classList.add('active');

        // Log success
        console.log(`‚úÖ Module popup opened: ${moduleTitle}`);

        // Add escape key listener
        document.addEventListener('keydown', handleModulePopupEscape);
      }

      /**
       * Close the module popup overlay
       */
      function closeModulePopup() {
        console.log('üì¶ Closing module popup');

        const overlay = document.getElementById('modulePopupOverlay');
        const iframe = document.getElementById('modulePopupIframe');

        if (!overlay || !iframe) return;

        // Hide overlay
        overlay.classList.remove('active');

        // Clear iframe source after animation completes
        setTimeout(() => {
          iframe.src = 'about:blank';
        }, 300);

        // Remove escape key listener
        document.removeEventListener('keydown', handleModulePopupEscape);

        console.log('‚úÖ Module popup closed');
      }

      /**
       * Handle escape key press to close module popup
       */
      function handleModulePopupEscape(event) {
        if (event.key === 'Escape') {
          closeModulePopup();
        }
      }

      // Expose globally for module cross-communication
      window.openModulePopup = openModulePopup;
      window.closeModulePopup = closeModulePopup;

      // Initialize Calendar
      async function initCalendar() {
        try {
          console.time('‚è±Ô∏è Total Calendar Init');
          console.time('‚è±Ô∏è DOM Cache Init');
          
          // ‚ö° Performance: Initialize DOM cache first
          DOMCache.init();
          console.timeEnd('‚è±Ô∏è DOM Cache Init');
          
          console.time('‚è±Ô∏è Sync Current Date');
          syncCurrentDateToLAToday();
          console.timeEnd('‚è±Ô∏è Sync Current Date');
          
          // ‚ö° INSTANT OPEN: Render empty calendar immediately
          console.time('‚è±Ô∏è Initial Empty Render');
          renderEmptyCalendar();
          console.timeEnd('‚è±Ô∏è Initial Empty Render');
          
          // Attach event listeners immediately so UI is interactive
          console.time('‚è±Ô∏è Attach Event Listeners');
          attachEventListeners();
          console.timeEnd('‚è±Ô∏è Attach Event Listeners');
          
          console.timeEnd('‚è±Ô∏è Total Calendar Init');
          
          // ‚ö° PROGRESSIVE LOADING: Load data in background, update when ready
          console.time('‚è±Ô∏è Background Data Load');
          initializeData().then(() => {
            console.timeEnd('‚è±Ô∏è Background Data Load');
          });
        } catch (e) {
          console.error('InitCalendar failed:', e);
        }
      }
      
      // ‚ö° INSTANT OPEN: Render calendar shell without data
      function renderEmptyCalendar() {
        const { year, month } = getCurrentViewYearMonth();
        
        // Update header
        document.getElementById('currentMonth').textContent = monthNames[month];
        document.getElementById('currentYear').textContent = year;
        
        const firstDay = getLAWeekdayIndex(createDateFromParts(year, month, 1)) ?? 0;
        const daysInMonth = new Date(year, month + 1, 0).getDate();
        const daysInPrevMonth = new Date(year, month, 0).getDate();
        
        const calendarDays = document.getElementById('calendarDays');
        calendarDays.innerHTML = '';
        
        const todayParts = getTodayLAParts();
        const isCurrentMonth = todayParts && Number(todayParts.year) === year && Number(todayParts.month) - 1 === month;
        const todayDate = todayParts ? Number(todayParts.day) : null;
        
        // Previous month days (grayed out)
        for (let i = firstDay - 1; i >= 0; i--) {
          const prevDay = daysInPrevMonth - i;
          const dayEl = document.createElement('div');
          dayEl.className = 'day other-month';
          dayEl.innerHTML = `<div class="day-number">${prevDay}</div>`;
          calendarDays.appendChild(dayEl);
        }
        
        // Current month days - show with placeholder dots
        for (let day = 1; day <= daysInMonth; day++) {
          const dayEl = document.createElement('div');
          dayEl.className = 'day';
          if (isCurrentMonth && day === todayDate) dayEl.classList.add('today');
          
          dayEl.innerHTML = `
            <div class="day-number">${day}</div>
            <div class="day-indicators">
              <span class="indicator-dot" style="background: rgba(255,255,255,0.2)"></span>
            </div>
          `;
          calendarDays.appendChild(dayEl);
        }
        
        // Next month days (fill remaining slots)
        const totalCells = calendarDays.children.length;
        const remainingCells = totalCells % 7 === 0 ? 0 : 7 - (totalCells % 7);
        for (let i = 1; i <= remainingCells; i++) {
          const dayEl = document.createElement('div');
          dayEl.className = 'day other-month';
          dayEl.innerHTML = `<div class="day-number">${i}</div>`;
          calendarDays.appendChild(dayEl);
        }
      }

      // Update Stats (Sidebar)
      async function updateStats() {
        const { year, month } = getCurrentViewYearMonth();
        const monthData = await getMonthData(year, month);
        const aggregates = monthData?.aggregates || {};

        document.getElementById('totalClasses').textContent = aggregates.classes || 0;
        document.getElementById('totalPayments').textContent = aggregates.payments || 0;
        document.getElementById('totalAbsences').textContent = aggregates.absences || 0;
        document.getElementById('totalSkipped').textContent = aggregates.skipped || 0;
      }

      // Update Calendar Stats (Header)
      async function updateCalendarStats() {
        try {
          const { year, month } = getCurrentViewYearMonth();
          const monthData = await getMonthData(year, month);
          if (!monthData) {
            console.warn('updateCalendarStats: No monthData');
            return;
          }
          const aggregates = monthData.aggregates || {};
          const totals = monthData.totals || { paid: 0, unpaid: 0 };

          const activeStudentCount = aggregates.activeStudents || 0;
          const totalScheduledClasses = aggregates.classes || 0;
          const totalPaid = totals.paid || 0;
          const totalPending = totals.unpaid || 0;

          document.getElementById('activeStudentsCount').textContent =
            `${activeStudentCount} active student${activeStudentCount === 1 ? '' : 's'}`;
          document.getElementById('scheduledClassesCount').textContent =
            `${totalScheduledClasses} scheduled class${totalScheduledClasses === 1 ? '' : 'es'}`;
          document.getElementById('monthPaid').textContent = `üí∞ ${totalPaid.toLocaleString()} $ paid`;
          document.getElementById('monthPending').textContent = `‚ö†Ô∏è ${totalPending.toLocaleString()} $ pending`;
        } catch (e) {
          console.error('updateCalendarStats failed:', e);
        }
      }

      function buildSidebarAlerts(monthData) {
        const alerts = { upcoming: [], unpaid: [] };
        if (!monthData?.dayMap) return alerts;

        const todayParts = getTodayLAParts();
        const todayStr = todayParts ? formatDateYYYYMMDD(createDateFromParts(
          Number(todayParts.year),
          Number(todayParts.month) - 1,
          Number(todayParts.day)
        )) : formatDateYYYYMMDD(new Date());
        const dayEntries = Object.values(monthData.dayMap);

        dayEntries.forEach(dayEntry => {
          if (!dayEntry?.dateStr) return;
          const isFutureDay = dayEntry.dateStr > todayStr;
          const isToday = dayEntry.dateStr === todayStr;
          const isPastOrToday = dayEntry.dateStr <= todayStr;
          const dateLabel = formatHumanDateInLA(dayEntry.date);

          (dayEntry.groups || []).forEach(group => {
            const groupName = group.groupName || group.group || 'Group';
            const timeLabel = group.laTime || '';

            (group.students || []).forEach(student => {
              const status = student.status || 'unpaid';
              const baseEntry = {
                studentName: student.name || 'Student',
                groupName,
                dateStr: dayEntry.dateStr,
                dateLabel,
                timeLabel,
                status,
                price: Number(student.pricePerClass) || 0,
              };

              const isUpcomingEntry = (isFutureDay || (isToday && status === 'upcoming')) && status !== 'canceled' && status !== 'skipped';

              if (isUpcomingEntry) {
                alerts.upcoming.push(baseEntry);
              }

              if (status === 'unpaid' && isPastOrToday) {
                alerts.unpaid.push(baseEntry);
              }
            });
          });
        });

        const sortByDate = (a, b) => {
          if (a.dateStr === b.dateStr) {
            return parseTimeToMinutes(a.timeLabel) - parseTimeToMinutes(b.timeLabel);
          }
          return a.dateStr.localeCompare(b.dateStr);
        };

        alerts.upcoming.sort(sortByDate);
        alerts.unpaid.sort(sortByDate);

        return alerts;
      }

      // Track last rendered sidebar alerts to avoid unnecessary rebuilds
      let lastSidebarAlerts = {
        upcoming: [],
        unpaid: [],
      };

      function renderSidebarAlerts(monthData) {
        const upcomingContainer = document.getElementById('upcomingClassesList');
        const unpaidContainer = document.getElementById('unpaidClassesList');
        if (!upcomingContainer || !unpaidContainer) return;

        const alerts = buildSidebarAlerts(monthData);
        const upcomingItems = (alerts.upcoming || []).slice(0, SIDEBAR_ALERT_LIMIT);
        const unpaidItems = (alerts.unpaid || []).slice(0, SIDEBAR_ALERT_LIMIT);

        // ‚ö° INCREMENTAL: Only re-render if alerts changed
        const upcomingChanged = !arraysEqual(upcomingItems, lastSidebarAlerts.upcoming);
        const unpaidChanged = !arraysEqual(unpaidItems, lastSidebarAlerts.unpaid);

        if (upcomingChanged) {
          renderList(upcomingContainer, upcomingItems, alerts.upcoming?.length || 0, 'upcoming');
          lastSidebarAlerts.upcoming = upcomingItems;
          debugLog('üìä Updated upcoming alerts');
        }

        if (unpaidChanged) {
          renderList(unpaidContainer, unpaidItems, alerts.unpaid?.length || 0, 'unpaid');
          lastSidebarAlerts.unpaid = unpaidItems;
          debugLog('üìä Updated unpaid alerts');
        }

        function arraysEqual(a, b) {
          if (a.length !== b.length) return false;
          for (let i = 0; i < a.length; i++) {
            if (a[i].dateStr !== b[i].dateStr || a[i].studentName !== b[i].studentName) {
              return false;
            }
          }
          return true;
        }

        function renderList(container, items, totalCount, type) {
          if (!items.length) {
            const empty = document.createElement('div');
            empty.className = 'insight-empty';
            empty.textContent = type === 'upcoming' ? 'No future classes in view' : 'No unpaid classes in view';
            container.replaceChildren(empty);
            return;
          }

          const fragment = document.createDocumentFragment();

          items.forEach(entry => {
            fragment.appendChild(createInsightCard(entry, type));
          });

          if (totalCount > items.length) {
            fragment.appendChild(createRemainingIndicator(totalCount - items.length, type));
          }

          container.replaceChildren(fragment);
        }

        function createInsightCard(entry, type) {
          const card = document.createElement('div');
          card.className = 'insight-card';

          const topRow = document.createElement('div');
          topRow.className = 'insight-meta';

          const dateSpan = document.createElement('span');
          dateSpan.textContent = entry.dateLabel || entry.dateStr;
          topRow.appendChild(dateSpan);

          const secondarySpan = document.createElement('span');
          if (type === 'upcoming') {
            secondarySpan.textContent = entry.timeLabel || 'Time TBA';
          } else {
            secondarySpan.textContent = `${formatCurrency(entry.price)} $`;
          }
          topRow.appendChild(secondarySpan);
          card.appendChild(topRow);

          const title = document.createElement('div');
          title.className = 'insight-title';
          title.textContent = entry.studentName;
          card.appendChild(title);

          const bottomRow = document.createElement('div');
          bottomRow.className = 'insight-meta';

          const groupSpan = document.createElement('span');
          groupSpan.textContent = entry.groupName;
          bottomRow.appendChild(groupSpan);

          const badge = document.createElement('span');
          const isUnpaid = type === 'unpaid' || entry.status === 'unpaid';
          badge.className = `insight-badge ${isUnpaid ? 'unpaid' : 'upcoming'}`;
          badge.textContent = isUnpaid ? 'Unpaid' : 'Upcoming';
          bottomRow.appendChild(badge);

          card.appendChild(bottomRow);

          return card;
        }

        function createRemainingIndicator(remainingCount, type) {
          const more = document.createElement('div');
          more.className = 'insight-empty';
          more.textContent = `+${remainingCount} more ${type === 'upcoming' ? 'class' : 'alert'} this month`;
          return more;
        }
      }

      let paymentReviewPromptState = { key: null, count: 0 };
      let paymentReviewDrawerOpen = false;

      function notifyPaymentAllocationReview(unresolvedList = [], monthKey = 'current', rawList = []) {
        window.paymentAllocationReviewSource = {
          monthKey,
          raw: Array.isArray(rawList) ? [...rawList] : [],
          unresolved: Array.isArray(unresolvedList) ? [...unresolvedList] : [],
        };

        updatePaymentAllocationReviewUI(window.paymentAllocationReviewSource.unresolved, monthKey);

        if (!unresolvedList.length) {
          return;
        }

        const promptKey = `${monthKey}-${unresolvedList.length}`;
        if (paymentReviewPromptState.key === promptKey) {
          return;
        }

        paymentReviewPromptState = { key: promptKey, count: unresolvedList.length };

        setTimeout(() => {
          showConfirmDialog(
            'Payment allocation review needed',
            `We couldn't auto-match ${unresolvedList.length} payment${unresolvedList.length === 1 ? '' : 's'} between Nov 1 and today. Would you like to review them now?`
          ).then(openNow => {
            if (openNow) {
              openPaymentReviewDrawer();
            }
          });
        }, 400);
      }

      function updatePaymentAllocationReviewUI(alerts = [], monthKey = 'current') {
        const banner = document.getElementById('paymentReviewBanner');
        if (!banner) return;

        if (!window.paymentAllocationReviewSource) {
          window.paymentAllocationReviewSource = { monthKey, raw: alerts, unresolved: alerts };
        } else {
          window.paymentAllocationReviewSource.unresolved = Array.isArray(alerts) ? [...alerts] : [];
          if (monthKey) {
            window.paymentAllocationReviewSource.monthKey = monthKey;
          }
        }

        const countEl = document.getElementById('paymentReviewCount');
        const pluralEl = document.getElementById('paymentReviewPlural');
        const totalEl = document.getElementById('paymentReviewTotal');
        const summaryEl = document.getElementById('paymentReviewSummary');
        const drawerCountEl = document.getElementById('paymentReviewDrawerCount');
        const drawerTotalEl = document.getElementById('paymentReviewDrawerTotal');

        if (!alerts.length) {
          banner.classList.add('hidden');
          if (countEl) countEl.textContent = '0';
          if (pluralEl) pluralEl.textContent = 's';
          if (totalEl) totalEl.textContent = '0';
          if (summaryEl) summaryEl.textContent = 'All payments have been matched.';
          if (drawerCountEl) drawerCountEl.textContent = '0 pending';
          if (drawerTotalEl) drawerTotalEl.textContent = '0 $ unresolved';
          if (paymentReviewDrawerOpen) {
            renderPaymentReviewList([]);
          }
          closePaymentReviewDrawer(true);
          return;
        }

        const totalAmount = alerts.reduce((sum, entry) => sum + (Number(entry.amount) || 0), 0);

        banner.classList.remove('hidden');
        if (countEl) countEl.textContent = alerts.length;
        if (pluralEl) pluralEl.textContent = alerts.length === 1 ? '' : 's';
        if (totalEl) totalEl.textContent = formatCurrency(totalAmount);
        if (summaryEl) {
          summaryEl.textContent = 'Click review to tell us whether these become credits or stay on hold.';
        }
        if (drawerCountEl) {
          drawerCountEl.textContent = `${alerts.length} payment${alerts.length === 1 ? '' : 's'} pending`;
        }
        if (drawerTotalEl) {
          drawerTotalEl.textContent = `${formatCurrency(totalAmount)} $ unresolved`;
        }

        if (paymentReviewDrawerOpen) {
          renderPaymentReviewList(alerts);
        }
      }

      function initPaymentReviewUI() {
        if (window.paymentReviewEventsBound) return;
        window.paymentReviewEventsBound = true;
        const bannerBtn = document.getElementById('paymentReviewBannerBtn');
        if (bannerBtn && !bannerBtn.dataset.bound) {
          bannerBtn.dataset.bound = 'true';
          bannerBtn.addEventListener('click', openPaymentReviewDrawer);
        }

        const exportBtn = document.getElementById('paymentReviewExportBtn');
        if (exportBtn && !exportBtn.dataset.bound) {
          exportBtn.dataset.bound = 'true';
          exportBtn.addEventListener('click', exportPaymentAllocationAlerts);
        }

        const closeBtn = document.getElementById('paymentReviewCloseBtn');
        if (closeBtn && !closeBtn.dataset.bound) {
          closeBtn.dataset.bound = 'true';
          closeBtn.addEventListener('click', () => closePaymentReviewDrawer());
        }

        const resetBtn = document.getElementById('paymentReviewResetBtn');
        if (resetBtn && !resetBtn.dataset.bound) {
          resetBtn.dataset.bound = 'true';
          resetBtn.addEventListener('click', handleResetPaymentAllocations);
        }

        const scrim = document.getElementById('paymentReviewScrim');
        if (scrim && !scrim.dataset.bound) {
          scrim.dataset.bound = 'true';
          scrim.addEventListener('click', () => closePaymentReviewDrawer());
        }

        const searchInput = document.getElementById('paymentReviewSearch');
        if (searchInput && !searchInput.dataset.bound) {
          searchInput.dataset.bound = 'true';
          searchInput.addEventListener('input', () => {
            if (paymentReviewDrawerOpen) {
              renderPaymentReviewList(window.paymentAllocationReviewSource?.unresolved || []);
            }
          });
        }

        if (!window.paymentReviewKeyListenerAttached) {
          window.paymentReviewKeyListenerAttached = true;
          document.addEventListener('keydown', event => {
            if (event.key === 'Escape' && paymentReviewDrawerOpen) {
              closePaymentReviewDrawer();
            }
          });
        }
      }

      function openPaymentReviewDrawer() {
        const drawer = document.getElementById('paymentReviewDrawer');
        const scrim = document.getElementById('paymentReviewScrim');
        if (!drawer || !scrim) return;
        paymentReviewDrawerOpen = true;
        drawer.setAttribute('aria-hidden', 'false');
        drawer.classList.add('open');
        scrim.classList.add('visible');
        renderPaymentReviewList(window.paymentAllocationReviewSource?.unresolved || []);
      }

      function closePaymentReviewDrawer(force = false) {
        if (!paymentReviewDrawerOpen && !force) return;
        const drawer = document.getElementById('paymentReviewDrawer');
        const scrim = document.getElementById('paymentReviewScrim');
        if (!drawer || !scrim) return;
        paymentReviewDrawerOpen = false;
        drawer.setAttribute('aria-hidden', 'true');
        drawer.classList.remove('open');
        scrim.classList.remove('visible');
      }

      function renderPaymentReviewList(entries = []) {
        const container = document.getElementById('paymentReviewList');
        if (!container) return;
        const searchTerm = (document.getElementById('paymentReviewSearch')?.value || '').trim().toLowerCase();
        const filteredEntries = filterPaymentReviewEntries(entries, searchTerm);

        const drawerCountEl = document.getElementById('paymentReviewDrawerCount');
        const drawerTotalEl = document.getElementById('paymentReviewDrawerTotal');
        const totalAmount = filteredEntries.reduce((sum, entry) => sum + (Number(entry.amount) || 0), 0);

        if (drawerCountEl) {
          drawerCountEl.textContent = `${filteredEntries.length} payment${filteredEntries.length === 1 ? '' : 's'} pending`;
        }
        if (drawerTotalEl) {
          drawerTotalEl.textContent = `${formatCurrency(totalAmount)} $ unresolved`;
        }

        container.innerHTML = '';

        if (!filteredEntries.length) {
          container.innerHTML = "<div class=\"payment-review-empty\">You're all caught up üôå</div>";
          return;
        }

        const grouped = groupPaymentAllocationsByStudent(filteredEntries);

        grouped.forEach(group => {
          const card = document.createElement('div');
          card.className = 'payment-review-card';

          const title = document.createElement('h4');
          title.textContent = group.studentName;
          card.appendChild(title);

          const subtitle = document.createElement('small');
          subtitle.textContent = `${group.payments.length} payment${group.payments.length === 1 ? '' : 's'} ¬∑ ${formatCurrency(group.totalAmount)} $`;
          card.appendChild(subtitle);

          const list = document.createElement('div');
          list.className = 'payment-review-payments';

          group.payments
            .sort((a, b) => (b.payDate || '').localeCompare(a.payDate || ''))
            .forEach(entry => {
              const row = document.createElement('div');
              row.className = 'payment-review-row';

              const details = document.createElement('div');
              details.style.flex = '1';
              details.innerHTML = `<strong>${entry.payDate || 'Unknown date'}</strong><br/><span>${formatCurrency(entry.amount)} $ ¬∑ ${entry.paymentId || 'Untracked payment'}</span>`;

              const actions = document.createElement('div');
              actions.className = 'payment-review-actions';

              const creditBtn = document.createElement('button');
              creditBtn.className = 'allocation-action credit';
              creditBtn.textContent = 'Mark credit';
              creditBtn.addEventListener('click', () => handlePaymentAllocationResolution(entry, 'credit'));

              const dismissBtn = document.createElement('button');
              dismissBtn.className = 'allocation-action dismiss';
              dismissBtn.textContent = 'Ignore this month';
              dismissBtn.addEventListener('click', () => handlePaymentAllocationResolution(entry, 'ignore'));

              actions.appendChild(creditBtn);
              actions.appendChild(dismissBtn);

              row.appendChild(details);
              row.appendChild(actions);
              list.appendChild(row);
            });

          card.appendChild(list);
          container.appendChild(card);
        });
      }

      function filterPaymentReviewEntries(entries, searchTerm) {
        if (!searchTerm) return entries;
        return entries.filter(entry => {
          const haystack = [
            entry.studentName,
            entry.studentId,
            entry.payDate,
            entry.paymentId,
            entry.amount != null ? String(entry.amount) : '',
          ]
            .filter(Boolean)
            .map(value => value.toString().toLowerCase());
          return haystack.some(value => value.includes(searchTerm));
        });
      }

      function groupPaymentAllocationsByStudent(entries) {
        const groups = new Map();
        entries.forEach(entry => {
          const key = entry.studentId || entry.studentName || entry.paymentId || Math.random().toString(36).slice(2, 8);
          if (!groups.has(key)) {
            groups.set(key, {
              studentId: entry.studentId,
              studentName: entry.studentName || 'Unknown Student',
              totalAmount: 0,
              payments: [],
            });
          }
          const group = groups.get(key);
          group.totalAmount += Number(entry.amount) || 0;
          group.payments.push(entry);
        });
        return Array.from(groups.values()).sort((a, b) => b.totalAmount - a.totalAmount);
      }

      async function handlePaymentAllocationResolution(entry, action) {
        const actionLabel = action === 'credit' ? 'mark as credit/rollover' : 'ignore for this month';
        const confirmed = await showConfirmDialog(
          'Resolve payment allocation',
          `Do you want to ${actionLabel} for ${entry.studentName || 'this student'} ‚Äî ${formatCurrency(entry.amount)} $ from ${entry.payDate || 'unknown date'}? This hides it from the alert list.`
        );
        if (!confirmed) return;

        markPaymentAllocationResolution(entry, action);
        showSuccessToast(action === 'credit' ? 'Saved as credit note locally' : 'Dismissed until new activity arrives');
        refreshPaymentAllocationAlerts();
      }

      function refreshPaymentAllocationAlerts() {
        const source = window.paymentAllocationReviewSource;
        if (!source) {
          updatePaymentAllocationReviewUI(window.paymentAllocationAlerts || [], null);
          return;
        }
        const refreshed = filterResolvedPaymentAllocations(source.raw || []);
        source.unresolved = refreshed;
        window.paymentAllocationAlerts = refreshed;
        updatePaymentAllocationReviewUI(refreshed, source.monthKey);
        if (paymentReviewDrawerOpen) {
          renderPaymentReviewList(refreshed);
        }
      }

      function exportPaymentAllocationAlerts() {
        const entries = window.paymentAllocationReviewSource?.unresolved || [];
        if (!entries.length) {
          showErrorToast('No pending payments to export.');
          return;
        }

        const header = ['Student', 'Student ID', 'Payment Date', 'Amount', 'Payment ID'];
        const rows = entries.map(entry => [
          entry.studentName || '',
          entry.studentId || '',
          entry.payDate || '',
          Number(entry.amount || 0).toFixed(2),
          entry.paymentId || '',
        ]);

        const csv = [header, ...rows]
          .map(row => row.map(value => `"${String(value).replace(/"/g, '""')}"`).join(','))
          .join('\n');

        const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = `payment-allocation-review-${formatDateYYYYMMDD(new Date())}.csv`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
      }

      async function handleResetPaymentAllocations() {
        const confirmed = await showConfirmDialog(
          'Reset hidden alerts',
          'This clears all previous review decisions so every payment will show up again. Continue?'
        );
        if (!confirmed) return;
        resetPaymentAllocationResolutions();
        showSuccessToast('Payment review decisions cleared');
        refreshPaymentAllocationAlerts();
      }

      // Render Calendar
      // ============================================================
      // EXCESS PAYMENTS DETECTION & NOTIFICATION SYSTEM
      // ============================================================
      // Tracks payments that exceed scheduled classes and prompts admin
      // to either apply as credit or dismiss the alert.
      //
      // Features:
      // - Dismissed alerts are saved to localStorage and never shown again
      // - Each payment is uniquely identified by: studentId_paymentId_date_amount
      // - Skip button permanently dismisses alerts for specific payments
      // - Confirm button applies credits and removes from alert queue
      // - Notification bell shows count of remaining alerts
      // - Admin can reset dismissed alerts via: clearDismissedExcessPayments()
      // ============================================================
      
      // Check for excess payments and notify user
      function checkAndNotifyExcessPayments() {
        if (!window.excessPaymentsForCredit || window.excessPaymentsForCredit.length === 0) {
          // Hide notification bell
          updateCreditNotificationBell(0);
          return; // No excess payments detected
        }
        
        // Initialize dismissed payments tracking in localStorage
        let dismissedPayments = [];
        try {
          const stored = localStorage.getItem('dismissedExcessPayments');
          if (stored) {
            dismissedPayments = JSON.parse(stored);
            // Ensure it's an array
            if (!Array.isArray(dismissedPayments)) {
              dismissedPayments = [];
            }
          }
        } catch (e) {
          console.error('Failed to load dismissed payments, resetting:', e);
          dismissedPayments = [];
          localStorage.removeItem('dismissedExcessPayments');
        }
        
        // Filter out already dismissed payments
        const newExcessPayments = window.excessPaymentsForCredit.filter(payment => {
          // Create unique key for this payment
          const paymentKey = `${payment.studentId}_${payment.paymentId}_${payment.date}_${payment.amount}`;
          const isDismissed = dismissedPayments.includes(paymentKey);
          return !isDismissed;
        });
        
        // If all payments were previously dismissed, don't show modal
        if (newExcessPayments.length === 0) {
          window.excessPaymentsForCredit = [];
          updateCreditNotificationBell(0);
          return;
        }
        
        // Update the list to only show new excess payments
        window.excessPaymentsForCredit = newExcessPayments;
        
        // Group by student to count unique students
        const byStudent = {};
        newExcessPayments.forEach(item => {
          const studentName = item.studentName || 'Unknown';
          if (!byStudent[studentName]) {
            byStudent[studentName] = [];
          }
          byStudent[studentName].push(item);
        });
        
        const studentCount = Object.keys(byStudent).length;
        
        // Show notification bell with count instead of auto-opening modal
        updateCreditNotificationBell(studentCount);
      }
      
      // Update notification bell visibility and count
      function updateCreditNotificationBell(count) {
        const bell = document.getElementById('creditNotificationBell');
        const badge = document.getElementById('creditNotificationBadge');
        
        if (!bell || !badge) return;
        
        // Bell is always visible
        bell.style.display = 'flex';
        
        if (count > 0) {
          // Has notifications - green and highlighted
          bell.classList.add('has-notifications');
          badge.style.display = 'flex';
          badge.textContent = count;
        } else {
          // No notifications - subtle appearance
          bell.classList.remove('has-notifications');
          badge.style.display = 'none';
        }
      }
      
      // Utility: Clear all dismissed excess payment alerts (for debugging/reset)
      // Call from console: window.clearDismissedExcessPayments()
      window.clearDismissedExcessPayments = function() {
        localStorage.removeItem('dismissedExcessPayments');
        alert('Dismissed excess payment alerts have been cleared. Refresh the page to see all alerts again.');
      };
      
      // Trigger credit review workflow manually
      function triggerCreditReview() {
        if (!window.excessPaymentsForCredit || window.excessPaymentsForCredit.length === 0) {
          return;
        }
        
        // Group by student
        const byStudent = {};
        window.excessPaymentsForCredit.forEach(item => {
          const studentName = item.studentName || 'Unknown';
          if (!byStudent[studentName]) {
            byStudent[studentName] = [];
          }
          byStudent[studentName].push(item);
        });
        
        // Convert to array and sort by student name
        const studentArray = Object.keys(byStudent).sort().map(name => ({
          name,
          payments: byStudent[name]
        }));
        
        // Show modal for first student
        showCreditModalForStudent(studentArray, 0);
      }
      
      // üóëÔ∏è REMOVED: Orphaned formatCurrency function (replaced by advanced version at line ~9008)
      // The active version uses toLocaleString() with smart decimal handling
      
      // Show credit modal for a specific student
      function showCreditModalForStudent(studentArray, currentIndex) {
        if (currentIndex >= studentArray.length) {
          // All students processed - hide notification bell
          updateCreditNotificationBell(0);
          window.excessPaymentsForCredit = [];
          return;
        }
        
        // Update bell to show remaining students
        const remainingStudents = studentArray.length - currentIndex;
        updateCreditNotificationBell(remainingStudents);
        
        const student = studentArray[currentIndex];
        const totalStudents = studentArray.length;
        const studentTotal = student.payments.reduce((sum, p) => sum + p.amount, 0);
        
        // Build modal content for this student
        let modalHTML = `
          <div class="credit-summary">
            <div class="credit-summary-info">
              <h3>${student.name}</h3>
              <p>${student.payments.length} excess payment(s) ‚Ä¢ Student ${currentIndex + 1} of ${totalStudents}</p>
            </div>
            <div class="credit-summary-total">$${formatCurrency(studentTotal)}</div>
          </div>
          
          <div class="credit-student-list">
            <div class="credit-student-card">
              <div class="credit-payment-list">
        `;
        
        student.payments.forEach(p => {
          modalHTML += `
            <div class="credit-payment-item">
              <span class="credit-payment-date">${p.date}</span>
              <span class="credit-payment-amount">$${formatCurrency(p.amount)}</span>
            </div>
          `;
        });
        
        modalHTML += `
              </div>
            </div>
          </div>
        `;
        
        // Show modal
        const modal = document.getElementById('creditModal');
        const modalBody = document.getElementById('creditModalBody');
        const applyBtn = document.getElementById('applyCreditBtn');
        
        modalBody.innerHTML = modalHTML;
        
        // Update button text to show progress
        if (totalStudents > 1) {
          applyBtn.textContent = `Confirm (${currentIndex + 1}/${totalStudents})`;
        } else {
          applyBtn.textContent = 'Confirm';
        }
        
        modal.classList.add('active');
        
        // Setup event listeners
        const closeBtn = document.getElementById('closeCreditModal');
        const cancelBtn = document.getElementById('cancelCreditBtn');
        const skipAllBtn = document.getElementById('skipAllCreditBtn');
        
        const skipStudent = () => {
          modal.classList.remove('active');
          
          // Mark THIS student's payments as dismissed permanently
          try {
            const paymentKeys = student.payments.map(p => 
              `${p.studentId}_${p.paymentId}_${p.date}_${p.amount}`
            );
            const existingDismissed = JSON.parse(localStorage.getItem('dismissedExcessPayments') || '[]');
            const updatedDismissed = [...new Set([...existingDismissed, ...paymentKeys])];
            localStorage.setItem('dismissedExcessPayments', JSON.stringify(updatedDismissed));
            
            // Remove these payments from the global list
            window.excessPaymentsForCredit = window.excessPaymentsForCredit.filter(p => {
              const key = `${p.studentId}_${p.paymentId}_${p.date}_${p.amount}`;
              return !paymentKeys.includes(key);
            });
          } catch (e) {
            console.error('Failed to save dismissed payments:', e);
          }
          
          // Show next student after a short delay
          setTimeout(() => {
            showCreditModalForStudent(studentArray, currentIndex + 1);
          }, 300);
        };
        
        const skipAllStudents = () => {
          modal.classList.remove('active');
          
          // Mark ALL remaining students' payments as dismissed permanently
          try {
            const allPaymentKeys = [];
            
            // Collect payment keys from current student and all remaining students
            for (let i = currentIndex; i < studentArray.length; i++) {
              const s = studentArray[i];
              s.payments.forEach(p => {
                allPaymentKeys.push(`${p.studentId}_${p.paymentId}_${p.date}_${p.amount}`);
              });
            }
            
            const existingDismissed = JSON.parse(localStorage.getItem('dismissedExcessPayments') || '[]');
            const updatedDismissed = [...new Set([...existingDismissed, ...allPaymentKeys])];
            localStorage.setItem('dismissedExcessPayments', JSON.stringify(updatedDismissed));
            
            // Remove all these payments from the global list
            window.excessPaymentsForCredit = window.excessPaymentsForCredit.filter(p => {
              const key = `${p.studentId}_${p.paymentId}_${p.date}_${p.amount}`;
              return !allPaymentKeys.includes(key);
            });
            
            // Hide notification bell since all are dismissed
            updateCreditNotificationBell(0);
          } catch (e) {
            console.error('Failed to save dismissed payments:', e);
          }
        };
        
        const applyCredit = () => {
          modal.classList.remove('active');
          
          // Apply credit for THIS student only
          applyCreditForStudent(student.payments, () => {
            // After successful application, show next student
            setTimeout(() => {
              showCreditModalForStudent(studentArray, currentIndex + 1);
            }, 300);
          });
        };
        
        // Remove old event listeners by cloning buttons
        const newCloseBtn = closeBtn.cloneNode(true);
        const newCancelBtn = cancelBtn.cloneNode(true);
        const newSkipAllBtn = skipAllBtn.cloneNode(true);
        const newApplyBtn = applyBtn.cloneNode(true);
        
        closeBtn.parentNode.replaceChild(newCloseBtn, closeBtn);
        cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);
        skipAllBtn.parentNode.replaceChild(newSkipAllBtn, skipAllBtn);
        applyBtn.parentNode.replaceChild(newApplyBtn, applyBtn);
        
        newCloseBtn.onclick = skipStudent;
        newCancelBtn.onclick = skipStudent;
        newSkipAllBtn.onclick = skipAllStudents;
        newApplyBtn.onclick = applyCredit;
        
        // Close on overlay click
        modal.onclick = (e) => {
          if (e.target === modal) skipStudent();
        };
      }
      
      // Apply credit for a single student
      async function applyCreditForStudent(payments, onSuccess) {
        const creditRecords = payments.map(item => ({
          student_id: item.studentId,
          amount: item.amount,
          date: item.date,
          notes: `Auto-applied from excess payment (${item.reason})`,
          created_at: new Date().toISOString()
        }));
        
        try {
          const { data, error } = await supabaseClient
            .from('credit_payments')
            .insert(creditRecords);
          
          if (error) {
            console.error('‚ùå Failed to apply credits:', error);
            alert(`Failed to apply credits: ${error.message}`);
            return;
          }
          
          // Clear dismissed payments for these specific payments
          try {
            const appliedKeys = payments.map(p => 
              `${p.studentId}_${p.paymentId}_${p.date}_${p.amount}`
            );
            const existingDismissed = JSON.parse(localStorage.getItem('dismissedExcessPayments') || '[]');
            const updatedDismissed = existingDismissed.filter(key => !appliedKeys.includes(key));
            localStorage.setItem('dismissedExcessPayments', JSON.stringify(updatedDismissed));
            
            // Also remove from global excess payments list
            window.excessPaymentsForCredit = window.excessPaymentsForCredit.filter(p => {
              const key = `${p.studentId}_${p.paymentId}_${p.date}_${p.amount}`;
              return !appliedKeys.includes(key);
            });
          } catch (e) {
            console.error('Failed to update dismissed payments list:', e);
          }
          
          // Show success message
          const studentName = payments[0].studentName;
          alert(`‚úÖ Applied $${formatCurrency(total)} as credit for ${studentName}`);
          
          // Call success callback to show next student
          if (onSuccess) onSuccess();
          
        } catch (err) {
          console.error('‚ùå Error applying credits:', err);
          alert(`Error: ${err.message}`);
        }
      }
      
      // ============================================================
      // INCREMENTAL RENDERING SYSTEM
      // ============================================================
      // Track the last rendered calendar state to avoid full DOM rebuilds
      let lastRenderedCalendar = {
        year: null,
        month: null,
        dayElements: new Map(), // dateStr -> DOM element
        dataFingerprints: new Map(), // dateStr -> data hash
      };

      // Generate a simple fingerprint for day data to detect changes
      function getDayDataFingerprint(dayData) {
        if (!dayData) return 'empty';
        
        const stats = dayData.stats || {};
        const totals = dayData.totals || {};
        const indicators = Array.from(dayData.indicators || []).sort().join(',');
        
        return `${stats.classes || 0}:${stats.payments || 0}:${stats.absences || 0}:${stats.skipped || 0}:${totals.paid || 0}:${totals.unpaid || 0}:${indicators}`;
      }

      // Invalidate a specific day's cache to force re-render on next update
      function invalidateDayCache(dateStr) {
        lastRenderedCalendar.dataFingerprints.delete(dateStr);
        debugLog(`üîÑ Invalidated cache for ${dateStr}`);
      }

      // Invalidate entire calendar cache (for major data changes)
      function invalidateCalendarCache() {
        lastRenderedCalendar.dataFingerprints.clear();
        lastRenderedCalendar.dayElements.clear();
        clearMonthCache();
        debugLog('üîÑ Invalidated entire calendar cache');
      }

      // Update payment summary in day header without rebuilding entire element
      function updateDayPaymentSummary(dayEl, dayData) {
        const dayHeader = dayEl.querySelector('.day-header');
        if (!dayHeader) return;
        
        // Remove existing payment summary if present
        const existingSummary = dayHeader.querySelector('.day-payment-summary');
        if (existingSummary) {
          existingSummary.remove();
        }
        
        // Add new payment summary if there's data
        if (dayData && dayData.totals) {
          const paid = Number(dayData.totals.paid || 0);
          const unpaid = Number(dayData.totals.unpaid || 0);
          
          if (paid > 0 || unpaid > 0) {
            const paymentSummary = document.createElement('div');
            paymentSummary.className = 'day-payment-summary';

            // Paid amount
            const paidSpan = document.createElement('span');
            paidSpan.className = 'day-payment-paid';
            paidSpan.textContent = `${formatCurrency(paid)} $`;
            paymentSummary.appendChild(paidSpan);

            // Divider
            const divider = document.createElement('span');
            divider.className = 'day-payment-divider';
            divider.textContent = '/';
            paymentSummary.appendChild(divider);

            // Unpaid amount
            const unpaidSpan = document.createElement('span');
            unpaidSpan.className = 'day-payment-unpaid';
            unpaidSpan.textContent = `${formatCurrency(unpaid)} $`;
            paymentSummary.appendChild(unpaidSpan);

            dayHeader.appendChild(paymentSummary);
          }
        }
      }

      async function renderCalendar() {
        const { year, month } = getCurrentViewYearMonth();

        // Reset payment allocation tracker for fresh calculation
        resetPaymentAllocation();

        // ‚ö° Performance: Check if month data is already cached
        let monthData = DataCache.getMonth(year, month);
        if (!monthData) {
          monthData = await getMonthData(year, month) || {};
          DataCache.setMonth(year, month, monthData);
        }

        // Update header using cached elements
        document.getElementById('currentMonth').textContent = monthNames[month];
        document.getElementById('currentYear').textContent = year;
        const firstDay =
          monthData.firstDay ?? getLAWeekdayIndex(createDateFromParts(year, month, 1)) ?? 0;
        const daysInMonth = monthData.daysInMonth ?? new Date(year, month + 1, 0).getDate();
        const daysInPrevMonth = new Date(year, month, 0).getDate();

        calendarBaseEvents = [...(monthData.eventsFlat || [])];
        currentMonthEventMap = monthData.dayMap || {};
        window.currentDayMap = currentMonthEventMap; // Make available globally for reassignment modal
        currentMonthEventsFlat = [...(monthData.eventsFlat || [])];
        lastMergedEventsCount = currentMonthEventsFlat.length;

        const calendarDays = document.getElementById('calendarDays');
        
        // ‚ö° INCREMENTAL RENDERING: Check if we're viewing the same month
        const isSameMonth = lastRenderedCalendar.year === year && lastRenderedCalendar.month === month;
        
        const todayParts = getTodayLAParts();
        const isCurrentMonth =
          todayParts && Number(todayParts.year) === year && Number(todayParts.month) - 1 === month;
        const todayDate = todayParts ? Number(todayParts.day) : null;

        if (isSameMonth && calendarDays.children.length > 0) {
          // ‚ö° INCREMENTAL UPDATE: Only update changed days
          debugLog('üìä Incremental calendar update (same month)');
          
          let cellIndex = 0;
          
          // Update previous month days (usually no data changes here)
          cellIndex += firstDay;
          
          // Update current month days
          for (let day = 1; day <= daysInMonth; day++) {
            const dayData = monthData.dayMap ? monthData.dayMap[day] : null;
            const dateStr = dayData?.dateStr || formatDateYYYYMMDD(createDateFromParts(year, month, day));
            const newFingerprint = getDayDataFingerprint(dayData);
            const oldFingerprint = lastRenderedCalendar.dataFingerprints.get(dateStr);
            
            // Only update if data changed
            if (newFingerprint !== oldFingerprint) {
              const dayEl = calendarDays.children[cellIndex];
              if (dayEl) {
                // Update classes
                dayEl.className = 'day';
                if (isCurrentMonth && day === todayDate) dayEl.classList.add('today');
                
                // Update payment summary in header
                updateDayPaymentSummary(dayEl, dayData);
                
                // Update state classes and indicators
                applyDayStateClasses(dayEl, dayData);
                addIndicators(dayEl, dayData);
                
                // Update fingerprint
                lastRenderedCalendar.dataFingerprints.set(dateStr, newFingerprint);
                
                debugLog(`üìù Updated day ${day} (${dateStr})`);
              }
            }
            
            cellIndex++;
          }
          
        } else {
          // ‚ö° FULL RENDER: Different month or first render
          debugLog('üîÑ Full calendar render (month changed)');
          
          calendarDays.innerHTML = '';
          lastRenderedCalendar.dayElements.clear();
          lastRenderedCalendar.dataFingerprints.clear();

          // Previous month days
          for (let i = firstDay - 1; i >= 0; i--) {
            const day = daysInPrevMonth - i;
            const prevDate = createDateFromParts(year, month - 1, day);
            const dayEl = createDayElement({ dayNumber: day, isOtherMonth: true, dateObj: prevDate });
            calendarDays.appendChild(dayEl);
          }

          // Current month days
          for (let day = 1; day <= daysInMonth; day++) {
            const dayData = monthData.dayMap ? monthData.dayMap[day] : null;
            const dateStr = dayData?.dateStr || formatDateYYYYMMDD(createDateFromParts(year, month, day));
            
            const dayEl = createDayElement({
              dayNumber: day,
              dayData,
              isToday: isCurrentMonth && day === todayDate,
            });

            applyDayStateClasses(dayEl, dayData);
            addIndicators(dayEl, dayData);
            calendarDays.appendChild(dayEl);
            
            // Cache element and fingerprint
            lastRenderedCalendar.dayElements.set(dateStr, dayEl);
            lastRenderedCalendar.dataFingerprints.set(dateStr, getDayDataFingerprint(dayData));
          }

          // Next month days
          const totalCells = calendarDays.children.length;
          const remainingCells = 42 - totalCells; // 6 rows √ó 7 days
          for (let day = 1; day <= remainingCells; day++) {
            const nextDate = createDateFromParts(year, month + 1, day);
            const dayEl = createDayElement({ dayNumber: day, isOtherMonth: true, dateObj: nextDate });
            calendarDays.appendChild(dayEl);
          }
          
          // Update last rendered state
          lastRenderedCalendar.year = year;
          lastRenderedCalendar.month = month;
        }

        updateStats();
        updateCalendarStats();
        renderSidebarAlerts(monthData);

        if (monthData) {
          if (
            monthData.paymentAllocationSource &&
            (!window.paymentAllocationReviewSource || window.paymentAllocationReviewSource.monthKey !== monthData.key)
          ) {
            window.paymentAllocationReviewSource = {
              monthKey: monthData.key,
              raw: monthData.paymentAllocationSource || [],
              unresolved: monthData.ambiguousPaymentAllocations || [],
            };
          } else if (window.paymentAllocationReviewSource && monthData.paymentAllocationSource) {
            window.paymentAllocationReviewSource.raw = monthData.paymentAllocationSource || [];
            window.paymentAllocationReviewSource.unresolved = monthData.ambiguousPaymentAllocations || [];
          }

          updatePaymentAllocationReviewUI(
            window.paymentAllocationReviewSource?.unresolved || monthData.ambiguousPaymentAllocations || [],
            monthData.key || `${year}-${String(month + 1).padStart(2, '0')}`
          );
        }
        
        // Check for excess payments that could be applied as credit
        checkAndNotifyExcessPayments();
      }

      // Create Day Element
      function createDayElement({ dayNumber, dayData = null, isOtherMonth = false, isToday = false, dateObj = null }) {
        const dayEl = document.createElement('div');
        dayEl.className = 'day';
        if (isOtherMonth) dayEl.classList.add('other-month');
        if (isToday) dayEl.classList.add('today');

        // Create header container
        const dayHeader = document.createElement('div');
        dayHeader.className = 'day-header';

        // Create day number
        const dayNumberEl = document.createElement('div');
        dayNumberEl.className = 'day-number';
        dayNumberEl.textContent = dayNumber;
        dayHeader.appendChild(dayNumberEl);

        if (dayData && dayData.totals) {
          const paid = Number(dayData.totals.paid || 0);
          const unpaid = Number(dayData.totals.unpaid || 0);
          if (paid > 0 || unpaid > 0) {
            const paymentSummary = document.createElement('div');
            paymentSummary.className = 'day-payment-summary';

            // Paid amount
            const paidSpan = document.createElement('span');
            paidSpan.className = 'day-payment-paid';
            paidSpan.textContent = `${formatCurrency(paid)} $`;
            paymentSummary.appendChild(paidSpan);

            // Divider
            const divider = document.createElement('span');
            divider.className = 'day-payment-divider';
            divider.textContent = '/';
            paymentSummary.appendChild(divider);

            // Unpaid amount
            const unpaidSpan = document.createElement('span');
            unpaidSpan.className = 'day-payment-unpaid';
            unpaidSpan.textContent = `${formatCurrency(unpaid)} $`;
            paymentSummary.appendChild(unpaidSpan);

            dayHeader.appendChild(paymentSummary);
          }
        }

        dayEl.appendChild(dayHeader);

        const indicatorContainer = document.createElement('div');
        indicatorContainer.className = 'day-indicator';
        dayEl.appendChild(indicatorContainer);

        const dateStr = dayData?.dateStr || (dateObj instanceof Date ? formatDateYYYYMMDD(dateObj) : null);
        if (dateStr) {
          dayEl.dataset.date = dateStr;
        }

        // ‚ö° PERFORMANCE: Removed individual click listener - using event delegation instead
        // Old code created 42 listeners every render, causing memory leaks
        // Now handled by ONE delegated listener in attachEventListeners()

        return dayEl;
      }

      // Add Indicators to Day
      function addIndicators(dayEl, dayData) {
        const indicatorContainer = dayEl.querySelector('.day-indicator');
        indicatorContainer.innerHTML = '';
        if (!dayData) return;

        // ============================================================
        // üé® DOT RENDERING - Uses status to determine color
        // paid = green, unpaid = red, scheduled = gray, etc.
        // ============================================================
        (dayData.groups || []).forEach((group) => {
          const groupRow = document.createElement('div');
          groupRow.className = 'group-dots-row';
          
          // Add group label
          const groupLabel = document.createElement('span');
          groupLabel.className = 'group-label';
          
          const displayLetter = group.groupCode || (group.groupName || 'Group').replace(/^Group\s*/i, '').charAt(0) || '?';
          groupLabel.textContent = displayLetter.toUpperCase();
          groupLabel.title = group.groupName || 'Group';
          groupRow.appendChild(groupLabel);
          
          // Add one dot per student (color based on status)
          (group.students || []).forEach(student => {
            const dot = document.createElement('div');
            dot.className = 'indicator-dot';
            
            // Use the proper dot class function that handles all statuses
            const dotClass = getDotClassForStudent(student);
            dot.classList.add(dotClass);
            
            // Set tooltip based on status
            const statusLabel = {
              'paid': 'Paid',
              'unpaid': 'Unpaid',
              'credit': 'Paid via Credit',
              'absent': 'Absent',
              'canceled': 'Canceled',
              'skipped': 'Skipped',
              'partial': 'Partial Payment',
              'upcoming': 'Upcoming'
            }[student.status] || 'Scheduled';
            
            dot.setAttribute('data-tooltip', `${student.name} ‚Äì ${statusLabel}`);
            
            // Store student data for click modal
            dot.setAttribute('data-student-id', student.id);
            dot.setAttribute('data-student-name', student.name);
            dot.setAttribute('data-student', JSON.stringify(student));
            dot.setAttribute('data-class-date', dayData.dateStr);
            groupRow.appendChild(dot);
          });
          
          // Only add row if it has dots
          if (group.students && group.students.length > 0) {
            indicatorContainer.appendChild(groupRow);
          }
        });

        // ============================================================
        // üî¥ RENDER FUCHSIA DOTS (Misallocated Payments)
        // ============================================================
        if (dayData.fuchsiaDots && dayData.fuchsiaDots.length > 0) {
          const fuchsiaRow = document.createElement('div');
          fuchsiaRow.className = 'group-dots-row fuchsia-row';
          
          // Add special label for fuchsia dots
          const fuchsiaLabel = document.createElement('span');
          fuchsiaLabel.className = 'group-label fuchsia-label';
          fuchsiaLabel.textContent = '!';
          fuchsiaLabel.title = 'Misallocated Payments (Need Reassignment)';
          fuchsiaLabel.style.color = '#ff00ff';
          fuchsiaLabel.style.fontWeight = 'bold';
          fuchsiaRow.appendChild(fuchsiaLabel);
          
          // Add fuchsia dots
          dayData.fuchsiaDots.forEach((fuchsiaDot, index) => {
            const dot = document.createElement('div');
            dot.className = 'indicator-dot dot-fuchsia';
            dot.style.background = 'linear-gradient(135deg, #ff00ff 0%, #ff66ff 100%)';
            dot.style.cursor = 'pointer';
            dot.style.width = '8px';
            dot.style.height = '8px';
            dot.style.borderRadius = '50%';
            dot.style.display = 'inline-block';
            dot.style.margin = '0 2px';
            
            dot.setAttribute('data-tooltip', fuchsiaDot.label);
            dot.setAttribute('data-student-id', fuchsiaDot.studentId);
            dot.setAttribute('data-student-name', fuchsiaDot.studentName);
            dot.setAttribute('data-payment-id', fuchsiaDot.paymentId);
            dot.setAttribute('data-for-class', fuchsiaDot.forClass);
            dot.setAttribute('data-receipt-date', fuchsiaDot.receiptDate);
            dot.setAttribute('data-class-date', dayData.dateStr);
            
            // Make fuchsia dots clickable for reassignment
            dot.addEventListener('click', () => {
              showReassignmentModal(fuchsiaDot);
            });
            
            fuchsiaRow.appendChild(dot);
          });
          
          indicatorContainer.appendChild(fuchsiaRow);
        }
      }

      function applyDayStateClasses(dayEl, dayData) {
        dayEl.classList.remove('has-class', 'has-payment', 'has-absence', 'skipped');
        if (!dayData) return;
        if (filters.classes && dayData.stats?.classes) {
          dayEl.classList.add('has-class');
        }
        if (filters.payments && (dayData.stats?.payments || dayData.stats?.credits)) {
          dayEl.classList.add('has-payment');
        }
        if (filters.absences && dayData.stats?.absences) {
          dayEl.classList.add('has-absence');
        }
        if (filters.skipped && dayData.stats?.skipped) {
          dayEl.classList.add('skipped');
        }
      }

      function getDotClassForStudent(student) {
        if (!student) return 'dot-class';
        
        // Check status in priority order
        if (student.status === 'canceled') return 'dot-canceled';
        if (student.status === 'skipped') return 'dot-skipped';
        if (student.absent || student.status === 'absent') return 'dot-absent';
        if (student.status === 'credit') return 'dot-credit';
        if (student.paid || student.status === 'paid') return 'dot-paid';
        if (student.status === 'partial') return 'dot-partial';
        if (student.status === 'upcoming') return 'dot-future';
        if (student.status === 'unpaid') return 'dot-unpaid';
        
        // Default for scheduled classes
        return 'dot-class';
      }

      // Custom Tooltip Functions (using fixed positioning to escape stacking context)
      let tooltipElement = null;
      let activeTooltipDot = null;

      function showCustomTooltip(event) {
        // ‚ö° EVENT DELEGATION FIX: Use closest() instead of currentTarget
        // If target is already a dot element, use it directly; otherwise use closest()
        let dotElement = event.target;
        if (!dotElement.classList || !dotElement.classList.contains('indicator-dot')) {
          dotElement = event.target.closest('.indicator-dot');
        }
        if (!dotElement) return;
        
        const studentData = dotElement.getAttribute('data-student');
        const classDate = dotElement.getAttribute('data-class-date');
        
        if (!studentData) return;

        let student;
        try {
          student = JSON.parse(studentData);
        } catch (e) {
          console.error('Failed to parse student data:', e);
          return;
        }

        // Get full student record from cache to get latest balance
        const students = window.studentsCache || [];
        const fullStudent = students.find(s => s.id === student.id) || student;
        const studentBalance = parseFloat(fullStudent.balance) || 0;
        const pricePerClass = parseFloat(student.pricePerClass) || 0;

        // Create or get modal
        let modal = document.getElementById('studentDotModal');
        if (!modal) {
          modal = document.createElement('div');
          modal.id = 'studentDotModal';
          document.body.appendChild(modal);
        }

        // Determine status
        const statusMap = {
          paid: { icon: '‚úì', class: 'paid', label: 'Paid' },
          unpaid: { icon: '‚úï', class: 'unpaid', label: 'Unpaid' },
          absent: { icon: '‚óã', class: 'absent', label: 'Absent' },
          credit: { icon: '‚òÖ', class: 'credit', label: 'Paid via Credit' },
          upcoming: { icon: '‚è∞', class: 'upcoming', label: 'Upcoming' },
          skipped: { icon: '‚è≠', class: 'upcoming', label: 'Skipped' }
        };

        const status = statusMap[student.status] || statusMap.unpaid;
        const safeName = student.name.replace(/'/g, "\\'");

        // Build action buttons
        // Build standardized action buttons based on student status
        let actionButtons = '';
        
        // For absent students: only show unmark button
        if (student.status === 'absent' || student.absent) {
          actionButtons = `
            <button class="dot-action-btn success wide" onclick="unmarkAbsent(${student.id}, '${classDate}')">
              <span class="btn-icon">‚Ü©Ô∏è</span>
              <span class="btn-text">Unmark Absent</span>
            </button>
          `;
        } else {
          // For all non-absent students, show relevant action buttons
          
          // Email Reminder - show for unpaid and upcoming students
          if (student.status === 'unpaid' || student.status === 'upcoming') {
            actionButtons += `
              <button class="dot-action-btn primary" onclick="event.stopPropagation(); sendManualReminder(${student.id}, '${safeName}')">
                <span class="btn-icon">üìß</span>
                <span class="btn-text">Email Reminder</span>
              </button>
            `;
          }
          
          // Apply Credit - show when student has sufficient balance AND is unpaid
          if (student.status === 'unpaid' && studentBalance >= pricePerClass && pricePerClass > 0) {
            actionButtons += `
              <button class="dot-action-btn success" onclick="applyFromCredit(${student.id}, '${classDate}', ${pricePerClass})">
                <span class="btn-icon">üí∞</span>
                <span class="btn-text">Apply Credit ($${formatCurrency(studentBalance)})</span>
              </button>
            `;
          }
          
          // Mark Absent - show for all non-absent students
          actionButtons += `
            <button class="dot-action-btn danger" onclick="markAsAbsent(${student.id}, '${classDate}')">
              <span class="btn-icon">‚ö™</span>
              <span class="btn-text">Mark Absent</span>
            </button>
          `;
          
          // Add Credit - always show (allows adding credit at any time)
          actionButtons += `
            <button class="dot-action-btn success" onclick="openAddCreditModal(${student.id}, '${safeName}')">
              <span class="btn-icon">üí≥</span>
              <span class="btn-text">Add Credit</span>
            </button>
          `;
          
          // Pause/Forward - only for unpaid students
          if (student.status === 'unpaid') {
            actionButtons += `
              <button class="dot-action-btn warning" onclick="event.stopPropagation(); pauseStudent(${student.id}, '${safeName}')">
                <span class="btn-icon">‚è∏</span>
                <span class="btn-text">Pause</span>
              </button>
              <button class="dot-action-btn purple" onclick="event.stopPropagation(); forwardStudent(${student.id}, '${safeName}')">
                <span class="btn-icon">‚è≠</span>
                <span class="btn-text">Forward</span>
              </button>
            `;
          }
          
          // Move Payment to Older/Newer Class - only for paid students (bidirectional arrows)
          if (student.status === 'paid' || student.status === 'credit') {
            actionButtons += `
              <button class="dot-action-btn primary" onclick="event.stopPropagation(); movePaymentToPrevious(${student.id}, '${classDate}')" title="Move payment to previous unpaid class">
                <span class="btn-icon">‚Üê</span>
                <span class="btn-text">Move ‚Üê Previous</span>
              </button>
              <button class="dot-action-btn primary" onclick="event.stopPropagation(); movePaymentToNext(${student.id}, '${classDate}')" title="Move payment to next unpaid class">
                <span class="btn-icon">‚Üí</span>
                <span class="btn-text">Move ‚Üí Next</span>
              </button>
            `;
          }
        }

        // Balance display with colors
        // In the database, if a student overpaid, balance is stored as POSITIVE (e.g., 500 means $500 credit)
        // If they owe, balance would be negative (but we show as owed)
        const balanceClass = studentBalance > 0 ? 'highlight-green' : studentBalance < 0 ? 'highlight-red' : '';
        const balanceLabel = studentBalance > 0 ? 'Credit (extra money)' : studentBalance < 0 ? 'Owed' : 'Balanced';
        const balanceClickable = true; // Make balance always editable

        // Get all dots for navigation
        const allDots = Array.from(document.querySelectorAll('.indicator-dot[data-student]'));
        const currentDotIndex = allDots.findIndex(d => 
          d.getAttribute('data-student-id') === String(student.id) && 
          d.getAttribute('data-class-date') === classDate
        );
        
        const hasPrevious = currentDotIndex > 0;
        const hasNext = currentDotIndex < allDots.length - 1;
        
        // Build new modal HTML
        const modalHTML = `
          <div class="dot-modal-container">
            <div class="dot-modal-accent"></div>
            
            <div class="dot-modal-header">
              <button class="dot-modal-close" onclick="hideCustomTooltip()">√ó</button>
              
              <div class="dot-modal-nav-arrows">
                <button class="dot-nav-arrow ${hasPrevious ? '' : 'disabled'}" 
                        onclick="${hasPrevious ? `navigateToDot(${currentDotIndex - 1})` : 'return false'}"
                        ${!hasPrevious ? 'disabled' : ''}
                        title="Previous dot">
                  ‚Üê
                </button>
                <span class="dot-nav-position">${currentDotIndex + 1} / ${allDots.length}</span>
                <button class="dot-nav-arrow ${hasNext ? '' : 'disabled'}" 
                        onclick="${hasNext ? `navigateToDot(${currentDotIndex + 1})` : 'return false'}"
                        ${!hasNext ? 'disabled' : ''}
                        title="Next dot">
                  ‚Üí
                </button>
              </div>
              
              <div class="dot-modal-status-badge ${status.class}">
                <span>${status.icon}</span>
                <span>${status.label}</span>
              </div>
              
              <h2 class="dot-modal-student-name">${student.name || 'Unknown'}</h2>
              <div class="dot-modal-group">${student.groupName || 'No Group'}</div>
            </div>
            
            <div class="dot-modal-body">
              <div class="dot-info-grid">
                <div class="dot-info-card">
                  <div class="dot-info-label">Class Date</div>
                  <div class="dot-info-value">${classDate || 'N/A'}</div>
                </div>
                
                <div class="dot-info-card">
                  <div class="dot-info-label">Price</div>
                  <div class="dot-info-value">$${formatCurrency(pricePerClass)}</div>
                </div>
                
                ${student.paidAmount && student.paidAmount > 0 ? `
                  <div class="dot-info-card">
                    <div class="dot-info-label">Amount Paid</div>
                    <div class="dot-info-value highlight-cyan">$${formatCurrency(student.paidAmount)}</div>
                  </div>
                ` : ''}
                
                ${student.status === 'unpaid' ? `
                  <div class="dot-info-card ${student.paidAmount ? '' : 'full-width'}">
                    <div class="dot-info-label">Amount Due</div>
                    <div class="dot-info-value highlight-red">$${formatCurrency(pricePerClass)}</div>
                  </div>
                ` : ''}
                
                <div class="dot-info-card ${student.paidAmount || student.status === 'unpaid' ? '' : 'full-width'} ${balanceClickable ? 'clickable-balance' : ''}" ${balanceClickable ? `onclick="editStudentBalance(${student.id}, '${safeName}', ${studentBalance})"` : ''}>
                  <div class="dot-info-label">
                    ${balanceLabel}
                    ${balanceClickable ? '<span style="font-size: 0.7rem; opacity: 0.6; margin-left: 4px;">‚úèÔ∏è click to edit</span>' : ''}
                  </div>
                  <div class="dot-info-value ${balanceClass}">$${formatCurrency(Math.abs(studentBalance))}</div>
                </div>
              </div>
              
              ${actionButtons ? `
                <div class="dot-actions-section">
                  <div class="dot-actions-title">Quick Actions</div>
                  <div class="dot-actions-grid">
                    ${actionButtons}
                  </div>
                </div>
              ` : ''}
            </div>
          </div>
        `;

        modal.innerHTML = modalHTML;
        modal.setAttribute('data-class-date', classDate); // Store class date for later refresh
        modal.setAttribute('data-student-id', student.id); // Store student ID for later refresh
        modal.classList.add('active');
        document.body.style.overflow = 'hidden';
      }

      // Refresh the dot modal with updated student data
      async function refreshDotModal(studentId, classDate) {
        // Reload students to get fresh data
        await loadStudents();
        
        // Find the dot element for this student and date
        const dotElement = document.querySelector(
          `.student-dot[data-student*='"id":${studentId}'][data-class-date="${classDate}"]`
        );
        
        if (dotElement) {
          // Re-trigger the tooltip with updated data
          // Create a synthetic event that works with event delegation
          const syntheticEvent = {
            target: dotElement,
            stopPropagation: () => {}
          };
          showCustomTooltip(syntheticEvent);
        }
      }

      // Navigate to a specific dot by index
      function navigateToDot(index) {
        const allDots = Array.from(document.querySelectorAll('.indicator-dot[data-student]'));
        if (index < 0 || index >= allDots.length) return;
        
        const targetDot = allDots[index];
        if (!targetDot) return;
        
        // Create synthetic event to open the target dot's modal
        const syntheticEvent = {
          target: targetDot,
          stopPropagation: () => {}
        };
        
        showCustomTooltip(syntheticEvent);
      }

      // Hover tooltip functions - shows simple name/status tooltip on hover
      let hoverTooltipElement = null;

      function showHoverTooltip(e) {
        const dot = e.target.closest('.indicator-dot');
        if (!dot) return;

        const tooltipText = dot.getAttribute('data-tooltip');
        if (!tooltipText) return;

        if (!hoverTooltipElement) {
          hoverTooltipElement = document.createElement('div');
          hoverTooltipElement.className = 'hover-tooltip';
          document.body.appendChild(hoverTooltipElement);
        }

        hoverTooltipElement.textContent = tooltipText;

        const rect = dot.getBoundingClientRect();
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;
        const margin = 16;

        const pointerX = typeof e.clientX === 'number' ? e.clientX : rect.left + rect.width / 2;
        const pointerY = typeof e.clientY === 'number' ? e.clientY : rect.top + rect.height / 2;

        const tooltipRect = hoverTooltipElement.getBoundingClientRect();
        const tooltipWidth = tooltipRect.width || hoverTooltipElement.offsetWidth || 0;
        const tooltipHeight = tooltipRect.height || hoverTooltipElement.offsetHeight || 0;

        let left = pointerX - tooltipWidth / 2;
        if (left < margin) left = margin;
        if (left + tooltipWidth > viewportWidth - margin) left = viewportWidth - margin - tooltipWidth;

        let top = pointerY - tooltipHeight - 18;
        let placeAbove = true;
        if (top < margin) {
          top = pointerY + 18;
          placeAbove = false;
        }

        if (top + tooltipHeight > viewportHeight - margin) {
          const clampedTop = Math.max(margin, viewportHeight - margin - tooltipHeight);
          placeAbove = clampedTop < pointerY;
          top = clampedTop;
        }

        hoverTooltipElement.style.left = `${left}px`;
        hoverTooltipElement.style.top = `${top}px`;

        if (placeAbove) {
          hoverTooltipElement.classList.remove('below');
        } else {
          hoverTooltipElement.classList.add('below');
        }

        hoverTooltipElement.classList.add('visible');
      }

      function hideHoverTooltip() {
        if (hoverTooltipElement) {
          hoverTooltipElement.classList.remove('visible');
        }
      }

      function hideCustomTooltip() {
        const modal = document.getElementById('studentDotModal');
        if (modal) {
          modal.classList.remove('active');
          document.body.style.overflow = '';
        }
      }

      // Close modal when clicking on overlay (outside modal)
      document.addEventListener('click', (e) => {
        const modal = document.getElementById('studentDotModal');
        if (modal && e.target === modal) {
          hideCustomTooltip();
        }
      });

      // Keyboard navigation for dot modal
      document.addEventListener('keydown', (e) => {
        const modal = document.getElementById('studentDotModal');
        if (!modal || !modal.classList.contains('active')) return;
        
        // Left arrow = previous dot
        if (e.key === 'ArrowLeft') {
          e.preventDefault();
          const allDots = Array.from(document.querySelectorAll('.indicator-dot[data-student]'));
          const currentStudentId = modal.getAttribute('data-student-id');
          const currentDate = modal.getAttribute('data-class-date');
          
          const currentIndex = allDots.findIndex(d => 
            d.getAttribute('data-student-id') === currentStudentId && 
            d.getAttribute('data-class-date') === currentDate
          );
          
          if (currentIndex > 0) {
            navigateToDot(currentIndex - 1);
          }
        }
        
        // Right arrow = next dot
        if (e.key === 'ArrowRight') {
          e.preventDefault();
          const allDots = Array.from(document.querySelectorAll('.indicator-dot[data-student]'));
          const currentStudentId = modal.getAttribute('data-student-id');
          const currentDate = modal.getAttribute('data-class-date');
          
          const currentIndex = allDots.findIndex(d => 
            d.getAttribute('data-student-id') === currentStudentId && 
            d.getAttribute('data-class-date') === currentDate
          );
          
          if (currentIndex >= 0 && currentIndex < allDots.length - 1) {
            navigateToDot(currentIndex + 1);
          }
        }
        
        // Escape = close modal
        if (e.key === 'Escape') {
          hideCustomTooltip();
        }
      });

      // Edit Student Balance
      async function editStudentBalance(studentId, studentName, currentBalance) {
        // Don't close the modal - keep it open
        
        const balanceDisplay = Math.abs(currentBalance).toFixed(2);
        const balanceType = currentBalance > 0 ? '(credit)' : currentBalance < 0 ? '(owed)' : '';
        
        const newBalanceStr = await customPrompt(
          `Edit balance for ${studentName}`,
          `Current balance: $${balanceDisplay} ${balanceType}\n\n` +
          `Enter new balance:\n` +
          `‚Ä¢ Positive number = Credit (student has extra money)\n` +
          `‚Ä¢ Negative number = Owed (student owes money)\n` +
          `‚Ä¢ 0 = Balanced`,
          currentBalance.toString()
        );
        
        if (newBalanceStr === null) return; // User cancelled
        
        const newBalance = parseFloat(newBalanceStr);
        if (isNaN(newBalance)) {
          await customAlert('‚ùå Invalid Input', 'Please enter a valid number for the balance.');
          return;
        }
        
        try {
          const { error } = await supabaseClient
            .from('students')
            .update({ balance: newBalance })
            .eq('id', studentId);
          
          if (error) throw error;
          
          await loadStudents();
          clearMonthCache();
          renderCalendar();
          
          const modalUpdate = updateActiveDotModalBalance(studentId, newBalance);
          if (modalUpdate?.classDate) {
            await refreshDotModal(studentId, modalUpdate.classDate);
          }

          const newBalanceDisplay = Math.abs(newBalance).toFixed(2);
          const newBalanceType = newBalance > 0 ? '(credit)' : newBalance < 0 ? '(owed)' : '(balanced)';
          await customAlert(
            '‚úÖ Balance Updated', 
            `Balance updated for ${studentName}\nNew balance: $${newBalanceDisplay} ${newBalanceType}`
          );
        } catch (error) {
          console.error('‚ùå Error updating balance:', error);
          alert(`‚ùå Failed to update balance: ${error.message}`);
        }
      }

      // üóëÔ∏è REMOVED: Orphaned applyFromCredit function (replaced by advanced version at line ~10024)
      // The active version uses CreditPaymentManager, custom dialogs, and incremental cache invalidation

      // Open Add Credit Modal for a specific student
      async function openAddCreditModal(studentId, studentName) {
        // Don't hide the tooltip - keep modal open
        
        // Prompt for credit amount using custom dialog
        const amount = await customPrompt(
          `Add Credit for ${studentName}`,
          `Enter the amount in USD to add to the student's credit balance:`,
          '0'
        );
        
        if (!amount || isNaN(parseFloat(amount))) {
          if (amount !== null) { // null means user clicked cancel
            await customAlert('‚ùå Invalid Amount', 'Please enter a valid number.');
          }
          return;
        }
        
        const creditAmount = parseFloat(amount);
        if (creditAmount <= 0) {
          await customAlert('‚ùå Invalid Amount', 'Amount must be greater than 0.');
          return;
        }
        
        try {
          // Get student data to update balance
          const { data: studentData, error: fetchError } = await supabaseClient
            .from('students')
            .select('balance')
            .eq('id', studentId)
            .single();
          
          if (fetchError) throw fetchError;
          
          const currentBalance = parseFloat(studentData.balance) || 0;
          const newBalance = currentBalance + creditAmount; // Add credit (positive balance = credit)
          
          // Update student balance
          const { error: updateError } = await supabaseClient
            .from('students')
            .update({ balance: newBalance })
            .eq('id', studentId);
          
          if (updateError) throw updateError;
          
          // ‚ö° INSTANT UPDATE: Refresh calendar data FIRST (before showing alert)
          await loadStudents();
          clearMonthCache();
          
          // Update the dot modal if it's open - DO THIS BEFORE SHOWING ALERT
          const modalUpdate = updateActiveDotModalBalance(studentId, newBalance);
          if (modalUpdate?.classDate) {
            if (DEBUG_MODE) {
              console.log('üîÑ Calling refreshDotModal...');
            }
            await refreshDotModal(studentId, modalUpdate.classDate);
            if (DEBUG_MODE) {
              console.log('‚úÖ refreshDotModal completed');
            }
          } else {
            if (DEBUG_MODE) {
              console.warn('‚ö†Ô∏è Modal not found or not active');
            }
          }
          
          // Re-render calendar to update dot colors
          renderCalendar();
          
          // Show success message AFTER everything is updated
          await customAlert(
            '‚úÖ Credit Added Successfully',
            `${studentName}\nAdded: $${creditAmount.toFixed(2)}\nNew Balance: $${newBalance.toFixed(2)} (credit)`
          );
          
        } catch (error) {
          console.error('Error adding credit:', error);
          await customAlert('‚ùå Failed to Add Credit', error.message);
        }
      }

      function formatCurrency(value) {
        const amount = Number(value) || 0;
        const hasCents = Math.abs(amount % 1) > 0;
        return amount.toLocaleString(undefined, {
          minimumFractionDigits: hasCents ? 2 : 0,
          maximumFractionDigits: hasCents ? 2 : 0,
        });
      }

      function updateActiveDotModalBalance(studentId, newBalance) {
        const modal = document.getElementById('studentDotModal');
        if (!modal || !modal.classList.contains('active')) return null;

        const modalStudentId = modal.getAttribute('data-student-id');
        if (modalStudentId && String(modalStudentId) !== String(studentId)) return null;

        const balanceCard = modal.querySelector('.clickable-balance');
        if (!balanceCard) return { modal };

        const balanceLabel = newBalance > 0 ? 'Credit (extra money)' : newBalance < 0 ? 'Owed' : 'Balanced';
        const balanceClass = newBalance > 0 ? 'highlight-green' : newBalance < 0 ? 'highlight-red' : '';

        const labelElement = balanceCard.querySelector('.dot-info-label');
        const valueElement = balanceCard.querySelector('.dot-info-value');
        if (labelElement && valueElement) {
          labelElement.innerHTML = `
            ${balanceLabel}
            <span style="font-size: 0.7rem; opacity: 0.6; margin-left: 4px;">‚úèÔ∏è click to edit</span>
          `;
          valueElement.className = `dot-info-value ${balanceClass}`;
          valueElement.textContent = `$${formatCurrency(Math.abs(newBalance))}`;

          valueElement.style.transition = 'all 0.3s ease';
          valueElement.style.transform = 'scale(1.1)';
          valueElement.style.textShadow = '0 0 10px rgba(34, 197, 94, 0.8)';
          setTimeout(() => {
            valueElement.style.transform = 'scale(1)';
            valueElement.style.textShadow = 'none';
          }, 300);
        }

        const applyBtn = modal.querySelector('button[onclick*="applyFromCredit"] .btn-text');
        if (applyBtn) {
          applyBtn.textContent = `Apply Credit ($${formatCurrency(newBalance)})`;
        }

        const classDate = modal.getAttribute('data-class-date') || new Date().toISOString().split('T')[0];
        return { modal, classDate };
      }

      function generatePaymentId() {
        if (window.crypto && window.crypto.randomUUID) {
          return window.crypto.randomUUID();
        }
        return `pay-${Date.now()}-${Math.random().toString(16).slice(2, 10)}`;
      }

      // Event Listeners
      function attachEventListeners() {
        // Navigation
        document.getElementById('prevMonth').addEventListener('click', () => {
          shiftCurrentView(-1);
          renderCalendar();
        });

        document.getElementById('nextMonth').addEventListener('click', () => {
          shiftCurrentView(1);
          renderCalendar();
        });

        document.getElementById('todayBtn').addEventListener('click', () => {
          syncCurrentDateToLAToday();
          renderCalendar();
        });

        // ‚ö° PERFORMANCE: EVENT DELEGATION - ONE listener instead of 42+ day listeners
        // This prevents memory leaks when re-rendering the calendar
        const calendarDays = document.getElementById('calendarDays');
        
        // Handle day clicks (opens day modal)
        // Handle both dot clicks and day cell clicks in single listener
        calendarDays.addEventListener('click', (e) => {
          // Handle dot clicks first (highest priority)
          const dot = e.target.closest('.indicator-dot');
          if (dot) {
            e.stopPropagation(); // Prevent day modal from opening
            showCustomTooltip(e);
            return; // Early exit
          }

          // Handle day cell clicks
          const dayCell = e.target.closest('.day');
          if (dayCell && !dayCell.classList.contains('other-month') && dayCell.dataset.date) {
            openDayModal(dayCell.dataset.date);
          }
        });
        
        // Handle dot hover - show custom tooltip with viewport clamping
        calendarDays.addEventListener('mouseenter', (e) => {
          const dot = e.target.closest('.indicator-dot');
          if (dot && dot.hasAttribute('data-tooltip')) {
            showHoverTooltip(e);
          }
        }, true);

        calendarDays.addEventListener('mousemove', (e) => {
          const dot = e.target.closest('.indicator-dot');
          if (dot && dot.hasAttribute('data-tooltip')) {
            showHoverTooltip(e);
          }
        }, true);

        calendarDays.addEventListener('mouseleave', (e) => {
          const dot = e.target.closest('.indicator-dot');
          if (dot && dot.hasAttribute('data-tooltip')) {
            hideHoverTooltip();
          }
        }, true); // Use capture phase for delegation

        // ‚ö° PERFORMANCE: Manual refresh button with elite loading animation
        document.getElementById('refreshBtn').addEventListener('click', async () => {
          const btn = document.getElementById('refreshBtn');
          const icon = btn.querySelector('.refresh-icon');
          
          // Add loading state
          btn.classList.add('loading');
          btn.disabled = true;
          
          try {
            // Reload all data
            await Promise.all([
              loadStudents(),
              loadGroups(),
              loadPayments(),
              loadAbsences(),
              loadSkippedClasses(),
              loadCreditPayments()
            ]);
            
            // Clear cache and re-render
            clearMonthCache();
            renderCalendar();
            
            // Success animation
            btn.classList.remove('loading');
            btn.style.borderColor = 'rgba(34, 197, 94, 0.6)';
            btn.style.background = 'linear-gradient(135deg, rgba(34, 197, 94, 0.15), rgba(16, 185, 129, 0.15))';
            icon.style.stroke = '#22c55e';
            
            setTimeout(() => {
              btn.style.borderColor = '';
              btn.style.background = '';
              icon.style.stroke = '';
              btn.disabled = false;
            }, 1000);
          } catch (error) {
            console.error('‚ùå Error refreshing data:', error);
            
            // Error animation
            btn.classList.remove('loading');
            btn.style.borderColor = 'rgba(239, 68, 68, 0.6)';
            btn.style.background = 'linear-gradient(135deg, rgba(239, 68, 68, 0.15), rgba(220, 38, 38, 0.15))';
            icon.style.stroke = '#ef4444';
            
            setTimeout(() => {
              btn.style.borderColor = '';
              btn.style.background = '';
              icon.style.stroke = '';
              btn.disabled = false;
            }, 2000);
          }
        });

        // Credit notification bell - opens Notification Center
        const creditBell = document.getElementById('creditNotificationBell');
        if (creditBell) {
          creditBell.addEventListener('click', () => {
            openModulePopup('Notification-Center.html', 'üîî Notifications');
          });
        }

        // Filters
        document.querySelectorAll('.filter-item[data-filter]').forEach(item => {
          item.addEventListener('click', () => {
            const filterType = item.getAttribute('data-filter');
            filters[filterType] = !filters[filterType];
            item.classList.toggle('active');
            renderCalendar();
          });
        });

        // Group Filters
        let activeGroups = new Set(['all', 'A', 'B', 'C', 'D', 'E', 'F']);
        let searchQuery = '';

        document.querySelectorAll('.filter-item[data-group]').forEach(item => {
          item.addEventListener('click', () => {
            const group = item.getAttribute('data-group');
            
            if (group === 'all') {
              // Toggle all groups
              if (activeGroups.has('all')) {
                activeGroups.clear();
              } else {
                activeGroups = new Set(['all', 'A', 'B', 'C', 'D', 'E', 'F']);
              }
              // Update all filter items
              document.querySelectorAll('.filter-item[data-group]').forEach(g => {
                if (activeGroups.size === 0) {
                  g.classList.remove('active');
                } else {
                  g.classList.add('active');
                }
              });
            } else {
              // Toggle individual group
              if (activeGroups.has(group)) {
                activeGroups.delete(group);
                item.classList.remove('active');
              } else {
                activeGroups.add(group);
                item.classList.add('active');
              }
              
              // Update "All Groups" checkbox
              const allItem = document.querySelector('.filter-item[data-group="all"]');
              if (activeGroups.size === 6) {
                activeGroups.add('all');
                allItem.classList.add('active');
              } else {
                activeGroups.delete('all');
                allItem.classList.remove('active');
              }
            }
            
            applyStudentFilters();
          });
        });

        // Multi-Select Status Filter - handled by global functions above
        
        // Close dropdown when clicking outside
        document.addEventListener('click', (e) => {
          const dropdown = document.getElementById('statusFilterDropdown');
          const button = document.getElementById('statusFilterBtn');
          if (dropdown && button && !dropdown.contains(e.target) && !button.contains(e.target)) {
            dropdown.style.display = 'none';
          }
        });

        // Student Search
        const searchInput = document.getElementById('studentSearchInput');
        if (searchInput) {
          searchInput.addEventListener('input', (e) => {
            searchQuery = e.target.value.toLowerCase().trim();
            applyStudentFilters();
          });
        }

        // Search Recap Close Button
        const searchRecapClose = document.getElementById('searchRecapClose');
        if (searchRecapClose) {
          searchRecapClose.addEventListener('click', () => {
            searchQuery = '';
            if (searchInput) searchInput.value = '';
            applyStudentFilters();
          });
        }

        // Apply filters to dots
        function applyStudentFilters() {
          const allDots = document.querySelectorAll('.indicator-dot[data-student-name]');
          const searchRecap = document.getElementById('searchRecap');
          const searchRecapTitle = document.getElementById('searchRecapTitle');
          const searchRecapStats = document.getElementById('searchRecapStats');
          
          let hasMatches = false;
          let searchedStudentName = '';
          let isGroupSearch = false;
          let searchedGroupCode = '';
          let statusCounts = {
            paid: 0,
            unpaid: 0,
            absent: 0,
            credit: 0,
            partial: 0,
            pending: 0,
            canceled: 0
          };
          
          allDots.forEach(dot => {
            const studentData = JSON.parse(dot.getAttribute('data-student') || '{}');
            const studentName = dot.getAttribute('data-student-name') || '';
            const groupCode = studentData.groupCode || studentData.group_letter || '';
            const studentStatus = studentData.status || '';
            
            // Debug logging for first few dots when searching
            if (searchQuery && allDots[0] === dot) {
              console.log('üîç Search Debug:', {
                searchQuery,
                studentName,
                groupCode,
                studentData,
                hasGroupCode: !!studentData.groupCode,
                hasGroupLetter: !!studentData.group_letter
              });
            }
            
            let visible = true;
            let matchesSearch = false;
            
            // Don't show "upcoming" dots when any search/filter is active
            if ((searchQuery || selectedStatuses.size > 0) && studentStatus === 'upcoming') {
              visible = false;
            }
            
            // Filter by status/color (multi-select dropdown)
            if (visible && selectedStatuses.size > 0) {
              visible = selectedStatuses.has(studentStatus);
            }
            
            // Filter by group (from sidebar checkboxes)
            if (visible && activeGroups.size > 0 && !activeGroups.has('all')) {
              visible = activeGroups.has(groupCode);
            }
            
            // Filter by search (supports both student name and group name)
            if (visible && searchQuery) {
              const nameMatch = studentName.toLowerCase().includes(searchQuery);
              
              // Group search: support various formats (a, A, group a, Group A, etc.)
              const groupCodeLower = groupCode.toLowerCase();
              const groupMatch = 
                groupCodeLower === searchQuery || // "a" matches "A"
                groupCodeLower.includes(searchQuery) || // partial match
                `group ${groupCodeLower}` === searchQuery || // "group a"
                `group${groupCodeLower}` === searchQuery || // "groupa"
                `group ${groupCodeLower}`.includes(searchQuery) || // "group" matches "Group A"
                searchQuery.replace(/^group\s*/i, '').toLowerCase() === groupCodeLower; // "Group A" -> "a" matches "A"
              
              // Debug logging for matches
              if (allDots[0] === dot) {
                console.log('üîç Match Check:', {
                  groupCodeLower,
                  searchQuery,
                  checks: {
                    exact: groupCodeLower === searchQuery,
                    includes: groupCodeLower.includes(searchQuery),
                    withSpace: `group ${groupCodeLower}` === searchQuery,
                    noSpace: `group${groupCodeLower}` === searchQuery,
                    includesGroup: `group ${groupCodeLower}`.includes(searchQuery),
                    stripped: searchQuery.replace(/^group\s*/i, '').toLowerCase() === groupCodeLower
                  },
                  nameMatch,
                  groupMatch
                });
              }
              
              matchesSearch = nameMatch || groupMatch;
              visible = matchesSearch;
              
              // Track stats for searched student or group
              if (matchesSearch && studentStatus && statusCounts.hasOwnProperty(studentStatus)) {
                statusCounts[studentStatus]++;
                
                if (nameMatch && !groupMatch) {
                  // Individual student search
                  if (!searchedStudentName) {
                    searchedStudentName = studentName;
                  }
                } else if (groupMatch) {
                  // Group search
                  isGroupSearch = true;
                  if (!searchedGroupCode) {
                    searchedGroupCode = groupCode;
                  }
                }
              }
            }
            
            // Hide/show dot and apply highlight
            if (visible) {
              dot.style.display = '';
              if (searchQuery && matchesSearch) {
                dot.classList.add('search-highlight');
                hasMatches = true;
              } else {
                dot.classList.remove('search-highlight');
              }
            } else {
              dot.style.display = 'none';
              dot.classList.remove('search-highlight');
            }
          });
          
          // Update search recap - show for both individual student and group searches
          if (searchQuery && hasMatches && (searchedStudentName || isGroupSearch)) {
            // Set title based on search type
            if (searchedStudentName) {
              searchRecapTitle.textContent = searchedStudentName.toUpperCase();
            } else if (isGroupSearch && searchedGroupCode) {
              searchRecapTitle.textContent = `GROUP ${searchedGroupCode.toUpperCase()}`;
            }
            
            // Build stats HTML
            const statsHTML = [];
            const statusConfig = {
              paid: { color: '#00ff41', label: 'Paid' },
              unpaid: { color: '#ff1744', label: 'Unpaid' },
              absent: { color: '#9e9e9e', label: 'Absences' },
              credit: { color: '#ffeb3b', label: 'Credit' },
              partial: { color: '#ff6d00', label: 'Partial' },
              pending: { color: '#2979ff', label: 'Pending' },
              canceled: { color: '#757575', label: 'Canceled' }
            };
            
            for (const [status, count] of Object.entries(statusCounts)) {
              if (count > 0 && statusConfig[status]) {
                const config = statusConfig[status];
                statsHTML.push(`
                  <div class="search-recap-stat">
                    <span class="search-recap-dot" style="background: ${config.color}; box-shadow: 0 0 8px ${config.color}80;"></span>
                    <span>${count} ${config.label}</span>
                  </div>
                `);
              }
            }
            
            searchRecapStats.innerHTML = statsHTML.join('');
            searchRecap.classList.add('active');
          } else {
            searchRecap.classList.remove('active');
          }
          
          // Hide empty group rows
          document.querySelectorAll('.group-dots-row').forEach(row => {
            const visibleDots = row.querySelectorAll('.indicator-dot[data-student-name]:not([style*="display: none"])');
            if (visibleDots.length === 0) {
              row.style.display = 'none';
            } else {
              row.style.display = '';
            }
          });
        }

        // Quick Actions
        document.querySelectorAll('.action-btn').forEach(btn => {
          btn.addEventListener('click', () => {
            debugLog('Action clicked:', btn.textContent.trim());
            // Add your action handlers here
          });
        });

        // Modal close handlers
        document.getElementById('closeModal').addEventListener('click', closeDayModal);
        document.getElementById('dayModal').addEventListener('click', e => {
          if (e.target.id === 'dayModal') {
            closeDayModal();
          }
        });

        // Confirm modal close handlers
        document.getElementById('closeConfirmModal').addEventListener('click', () => {
          document.getElementById('confirmModal').classList.remove('active');
        });
        document.getElementById('confirmModal').addEventListener('click', e => {
          if (e.target.id === 'confirmModal') {
            document.getElementById('confirmModal').classList.remove('active');
          }
        });

        // ESC key to close modal
        document.addEventListener('keydown', e => {
          if (e.key === 'Escape') {
            closeDayModal();
            document.getElementById('confirmModal').classList.remove('active');
          }
        });

        // Sidebar toggle
        document.getElementById('sidebarToggle').addEventListener('click', toggleSidebar);
        document.getElementById('floatingToggle').addEventListener('click', toggleSidebar);

        initPaymentReviewUI();
      }

      // Toggle Sidebar
      function toggleSidebar() {
        const sidebar = document.getElementById('sidebar');
        const container = document.querySelector('.container');
        const floatingToggle = document.getElementById('floatingToggle');

        sidebar.classList.toggle('expanded');
        container.classList.toggle('sidebar-expanded');
        floatingToggle.classList.toggle('hidden');
      }

      // Open Day Modal
      async function openDayModal(dateInput) {
        let targetDate = null;
        if (typeof dateInput === 'string') {
          targetDate = createDateFromDateStr(dateInput) || new Date(dateInput);
        } else {
          const numericDay = Number(dateInput);
          const { year, month } = getCurrentViewYearMonth();
          targetDate = createDateFromParts(year, month, numericDay);
        }

        if (!targetDate || isNaN(targetDate.getTime())) return;

        const targetDateStr = formatDateYYYYMMDD(targetDate);
        const targetParts = parseDateParts(targetDateStr);
        if (!targetParts) return;

        const formattedDate = formatHumanDateInLA(targetDate);
        const dayOfWeek = getLAWeekdayName(targetDate);

        document.getElementById('modalDate').textContent = formattedDate;
        document.getElementById('modalDayOfWeek').textContent = dayOfWeek;

        const monthData = await getMonthData(targetParts.year, targetParts.month - 1);
        const dayEntry = monthData?.dayMap?.[targetParts.day];
        const modalBody = document.getElementById('modalBody');

        if (!dayEntry) {
          modalBody.innerHTML = `<div class="modal-tab-content">${renderEmptyState('No events recorded for this day')}</div>`;
          showModal();
          return;
        }

        const groups = dayEntry.groups || [];
        const payments = dayEntry.payments || [];
        const credits = dayEntry.credits || [];
        const studentEvents = dayEntry.studentEvents || [];

        // Create tabs structure
        let tabsHtml = '';
        let tabPanelsHtml = '';

        if (groups.length) {
          // Collect all unpaid students from all groups (ONLY actually unpaid, not upcoming/absent/canceled)
          let unpaidStudents = [];
          groups.forEach(group => {
            if (group.students && group.students.length) {
              group.students.forEach((student, idx) => {
                if (student.status === 'unpaid') {
                  unpaidStudents.push({
                    student: student,
                    group: group,
                    index: idx
                  });
                }
              });
            }
          });

          // Add "Unpaid" tab
          const unpaidCount = unpaidStudents.length;
          tabsHtml += `<div class="modal-tab active" onclick="switchModalTab(event, 'unpaid')">Unpaid (${unpaidCount})</div>`;
          
          let unpaidContent = '';
          if (unpaidStudents.length > 0) {
            const unpaidStudentsHtml = unpaidStudents
              .map(item => renderStudentCard(item.student, item.group, formattedDate, item.index))
              .join('');
            
            unpaidContent = `
              <div class="group-section">
                <div class="group-header">
                  <div class="group-header-content">
                    <div class="group-icon">ÔøΩ</div>
                    <div class="group-info">
                      <h3>Unpaid Students</h3>
                      <div class="group-time">${unpaidCount} student${unpaidCount === 1 ? '' : 's'} need payment</div>
                    </div>
                  </div>
                </div>
                <div class="students-list">
                  ${unpaidStudentsHtml}
                </div>
              </div>
            `;
          } else {
            unpaidContent = renderEmptyState('All students are paid! üéâ');
          }
          
          tabPanelsHtml += `<div class="tab-panel active" data-tab="unpaid">${unpaidContent}</div>`;

          // Add individual group tabs
          groups.forEach((group, groupIndex) => {
            const groupName = group.groupName || group.group || 'Group';
            const tabId = `group-${groupIndex}`;
            const studentCount = group.students?.length || 0;
            
            tabsHtml += `<div class="modal-tab" onclick="switchModalTab(event, '${tabId}')">${groupName} (${studentCount})</div>`;
            
            const studentsHtml = group.students && group.students.length
              ? group.students.map((student, idx) => renderStudentCard(student, group, formattedDate, idx)).join('')
              : renderEmptyState(group.skipInfo?.note || 'Class canceled - no students');

            const laTime = group.laTime ? `${group.laTime} LA` : '';
            const times = [group.day, laTime].filter(Boolean).join(' ‚Ä¢ ');
            const skipBadge = group.skipped
              ? `<span class="badge absent">${group.skipInfo?.note || (group.skipInfo?.type === 'class-canceled' ? 'Class canceled' : 'Class skipped')}</span>`
              : '';
            
            const cancelButton = group.skipped
              ? `<button class="quick-action-btn secondary" onclick="uncancelClass('${group.groupName}', '${targetDateStr}')" style="padding: 8px 16px; font-size: 12px;">‚Ü©Ô∏è Uncancel</button>`
              : `<button class="quick-action-btn tertiary" onclick="cancelClass('${group.groupName}', '${targetDateStr}')" style="padding: 8px 16px; font-size: 12px;">üö´ Cancel Class</button>`;

            const groupContent = `
              <div class="group-section">
                <div class="group-header">
                  <div class="group-header-content">
                    <div class="group-icon">üë•</div>
                    <div class="group-info">
                      <h3>${groupName}</h3>
                      <div class="group-time">${times || group.day || ''}</div>
                    </div>
                    ${skipBadge}
                  </div>
                  <div class="group-header-actions">
                    ${cancelButton}
                  </div>
                </div>
                <div class="students-list">
                  ${studentsHtml}
                </div>
              </div>
            `;
            
            tabPanelsHtml += `<div class="tab-panel" data-tab="${tabId}">${groupContent}</div>`;
          });
        }

        // Add "Payments Received" tab - shows ALL payments received on this date
        const paymentsReceivedToday = [];
        const paymentsCache = window.paymentsCache || [];
        const studentsData = window.studentsCache || [];
        
        console.log('üîç Payments Received Tab - Checking date:', targetDateStr);
        console.log('üîç Total payments in cache:', paymentsCache.length);
        
        // Find all payments received on this date
        paymentsCache.forEach(payment => {
          // Extract receipt date from payment (email_date or date field)
          const dateSource = payment.email_date || payment.emailDate || payment.date || payment.payment_date || payment.created_at;
          if (!dateSource) return;
          
          const receiptDate = normalizeDateInput(dateSource);
          
          // Log all Dec 13 payments
          if (receiptDate === '2025-12-13') {
            console.log('üîç Found Dec 13 payment:', {
              id: payment.id,
              student_id: payment.student_id,
              linked_student_id: payment.linked_student_id,
              amount: payment.amount,
              for_class: payment.for_class,
              receiptDate
            });
          }
          
          if (receiptDate === targetDateStr) {
            // Find the student this payment belongs to
            // CRITICAL: Check linked_student_id FIRST (this is the resolved student)
            const studentId = payment.linked_student_id || payment.student_id;
            const student = studentsData.find(s => String(s.id) === String(studentId));
            
            console.log('üîç Payment matches target date:', {
              paymentId: payment.id,
              studentId,
              studentFound: !!student,
              studentName: student?.name
            });
            
            if (student && student.show_in_grid) {
              const allocatedTo = payment.for_class ? normalizeDateInput(payment.for_class) : 'Not allocated';
              const amount = Number(payment.amount) || Number(payment.amountUSD) || Number(payment.amount_paid_usd) || 0;
              const paymentId = payment.id || payment.gmail_id;
              
              paymentsReceivedToday.push({
                student,
                payment: {
                  id: paymentId,
                  amount,
                  dateStr: receiptDate,
                  forClass: allocatedTo
                },
                allocatedTo,
                isAllocatedElsewhere: allocatedTo && allocatedTo !== targetDateStr && allocatedTo !== 'Not allocated'
              });
            }
          }
        });

        if (paymentsReceivedToday.length > 0) {
          const paymentsTabId = 'payments-received';
          const paymentsCount = paymentsReceivedToday.length;
          tabsHtml += `<div class="modal-tab" onclick="switchModalTab(event, '${paymentsTabId}')">Payments (${paymentsCount})</div>`;
          
          const paymentsHtml = paymentsReceivedToday.map(item => {
            const { student, payment, allocatedTo, isAllocatedElsewhere } = item;
            const initials = student.name.split(' ').map(n => n[0]).join('');
            const statusBadge = isAllocatedElsewhere
              ? `<span class="badge pending">Allocated to ${allocatedTo}</span>`
              : `<span class="badge paid">Allocated to this class</span>`;
            
            const reassignButton = isAllocatedElsewhere
              ? `<button class="quick-action-btn primary" onclick='reassignPaymentFromModal(${JSON.stringify(payment.id)}, ${JSON.stringify(student.id)}, ${JSON.stringify(student.name)}, ${JSON.stringify(payment.amount)}, ${JSON.stringify(targetDateStr)}, ${JSON.stringify(allocatedTo)})' style="padding: 6px 12px; font-size: 12px;">‚ÜîÔ∏è Reassign</button>`
              : '';

            return `
              <div class="student-card">
                <div class="student-info">
                  <div class="student-avatar">${initials}</div>
                  <div class="student-details">
                    <div class="student-name">${student.name}</div>
                    <div class="student-status">$${payment.amount} ‚Ä¢ Received ${targetDateStr}</div>
                  </div>
                </div>
                <div style="display: flex; align-items: center; gap: 10px;">
                  ${reassignButton}
                  <div class="student-badges">
                    ${statusBadge}
                  </div>
                </div>
              </div>
            `;
          }).join('');

          const paymentsContent = `
            <div class="group-section">
              <div class="group-header">
                <div class="group-header-content">
                  <div class="group-icon">üí∞</div>
                  <div class="group-info">
                    <h3>Payments Received</h3>
                    <div class="group-time">${paymentsCount} payment${paymentsCount === 1 ? '' : 's'} received on this date</div>
                  </div>
                </div>
              </div>
              <div class="students-list">
                ${paymentsHtml}
              </div>
            </div>
          `;
          
          tabPanelsHtml += `<div class="tab-panel" data-tab="${paymentsTabId}">${paymentsContent}</div>`;
        }

        if (studentEvents.length) {
          const eventsHtml = studentEvents
            .map(event => {
              const icon = getEventIcon(event.type);
              return `
                <div class="student-card">
                  <div class="student-info">
                    <div class="student-avatar">${icon}</div>
                    <div class="student-details">
                      <div class="student-name">${event.studentName}</div>
                      <div class="student-status">${event.label || 'Milestone'}</div>
                    </div>
                  </div>
                </div>
              `;
            })
            .join('');

          const eventsContent = `
            <div class="group-section">
              <div class="group-header">
                <div class="group-icon">üéâ</div>
                <div class="group-info">
                  <h3>Student Events</h3>
                  <div class="group-time">${studentEvents.length} event${studentEvents.length === 1 ? '' : 's'}</div>
                </div>
              </div>
              <div class="students-list">
                ${eventsHtml}
              </div>
            </div>
          `;
          
          // Add events tab if there are any
          if (tabsHtml) {
            tabsHtml += `<div class="modal-tab" onclick="switchModalTab(event, 'events')">Events (${studentEvents.length})</div>`;
            tabPanelsHtml += `<div class="tab-panel" data-tab="events">${eventsContent}</div>`;
          } else {
            // If only events, no tabs needed
            modalBody.innerHTML = `<div class="modal-tab-content">${eventsContent}</div>`;
            showModal();
            return;
          }
        }

        if (!tabsHtml) {
          modalBody.innerHTML = `<div class="modal-tab-content">${renderEmptyState('No classes, payments, or events for this day')}</div>`;
          showModal();
          return;
        }

        // Build final modal structure with tabs
        modalBody.innerHTML = `
          <div class="modal-tabs">
            ${tabsHtml}
          </div>
          <div class="modal-tab-content">
            ${tabPanelsHtml}
          </div>
        `;

        showModal();

        function renderStudentCard(student, group, classDate, index) {
          const displayName = student.name || 'Student';
          const initials = displayName
            .split(' ')
            .map(n => n[0])
            .join('');
          const normalizedId = `student-${dayEntry.dateStr}-${student.id || `${group.groupName || 'group'}-${index}`}`
            .replace(/[^a-zA-Z0-9-_]/g, '_');
          const safeName = displayName.replace(/'/g, "\\'");
          const studentId = student.id;
          const dateStr = dayEntry.dateStr;
          const pricePerClass = student.pricePerClass || 0;
          const studentBalance = student.balance || 0;
          
          // Debug log
          debugLog('üí≥ Student Card DEBUG:', {
            name: displayName,
            id: studentId,
            balance: studentBalance,
            rawBalance: student.balance,
            pricePerClass,
            status: student.status,
            showCredit: studentBalance >= pricePerClass && pricePerClass > 0,
            studentObject: student
          });

          let badges = '';
          if (student.status === 'canceled') {
            badges += '<span class="badge absent">Class canceled</span>';
          } else if (student.status === 'skipped') {
            badges += '<span class="badge absent">Class skipped</span>';
          } else if (student.status === 'absent' || student.absent) {
            badges += '<span class="badge absent">Absent</span>';
          } else if (student.status === 'paid' || student.paid) {
            badges += `<span class="badge paid">Paid ${formatCurrency(student.paidAmount || student.pricePerClass)} $</span>`;
          } else if (student.status === 'credit') {
            badges += `<span class="badge paid">Credit</span>`;
          } else if (student.status === 'upcoming') {
            badges += '<span class="badge unpaid">Upcoming</span>';
          } else {
            badges += '<span class="badge unpaid">Unpaid</span>';
          }

          // Build action buttons based on student status
          let actionButtons = '';
          
          if (student.status === 'canceled' || student.status === 'skipped') {
            // No action buttons for canceled/skipped classes
            actionButtons = '';
          } else if (student.status === 'absent' || student.absent) {
            // Show unmark absent button
            actionButtons = `
              <div class="student-actions">
                <button class="action-icon-btn unmark"
                        data-tooltip="Unmark Absent"
                        onclick="event.stopPropagation(); unmarkAbsent(${studentId}, '${dateStr}')">
                  <span class="btn-icon">‚Ü©Ô∏è</span>
                </button>
              </div>
            `;
          } else if (student.status === 'unpaid') {
            // Show full action buttons for unpaid students ONLY (not upcoming)
            let actionButtonsHtml = `
              <button class="action-icon-btn pause ${student.autoPaused ? 'paused' : ''}"
                      data-student-id="${normalizedId}"
                      data-tooltip="${student.autoPaused ? 'Resume' : 'Pause'}"
                      onclick="event.stopPropagation(); toggleAutoReminder('${normalizedId}', '${safeName}')">
                <span class="btn-icon">${student.autoPaused ? '‚ñ∂Ô∏è' : '‚è∏Ô∏è'}</span>
                <span class="btn-label">${student.autoPaused ? 'Resume' : 'Pause'}</span>
              </button>
              <button class="action-icon-btn send"
                      data-student-id="${normalizedId}"
                      data-tooltip="Send Email"
                      onclick="event.stopPropagation(); sendManualReminder(${studentId}, '${safeName}')">
                <span class="btn-icon">
                  <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M5 12h14M12 5l7 7-7 7"/>
                  </svg>
                </span>
                <span class="btn-label">Email</span>
              </button>
              <button class="action-icon-btn mark-paid"
                      data-tooltip="Cash Payment"
                      onclick="event.stopPropagation(); markPaidManually(${studentId}, '${dateStr}', ${pricePerClass}, '${safeName}')">
                <span class="btn-icon">üíµ</span>
                <span class="btn-label">Cash</span>
              </button>
            `;
            
            // Add credit button if student has sufficient balance
            if (studentBalance >= pricePerClass && pricePerClass > 0) {
              actionButtonsHtml += `
                <button class="action-icon-btn credit"
                        data-tooltip="Use Credit"
                        onclick="event.stopPropagation(); applyFromCredit(${studentId}, '${dateStr}', ${pricePerClass})">
                  <span class="btn-icon">üí≥</span>
                  <span class="btn-label">Credit</span>
                </button>
              `;
            }
            
            actionButtonsHtml += `
              <button class="action-icon-btn absent"
                      data-tooltip="Mark Absent"
                      onclick="event.stopPropagation(); markAsAbsent(${studentId}, '${dateStr}')">
                <span class="btn-icon">‚ö™</span>
                <span class="btn-label">Absent</span>
              </button>
            `;
            
            actionButtons = `<div class="student-actions">${actionButtonsHtml}</div>`;
          } else if (student.status === 'upcoming') {
            // Upcoming classes get limited actions (can only mark absent, no payment reminders)
            actionButtons = `
              <div class="student-actions">
                <button class="action-icon-btn absent"
                        data-tooltip="Mark Absent"
                        onclick="event.stopPropagation(); markAsAbsent(${studentId}, '${dateStr}')">
                  <span class="btn-icon">‚ö™</span>
                </button>
              </div>
            `;
          } else if (student.status === 'paid' || student.status === 'credit') {
            // Show absent button even for paid students (allow marking paid students as absent)
            actionButtons = `
              <div class="student-actions">
                <button class="action-icon-btn absent"
                        data-tooltip="Mark Absent"
                        onclick="event.stopPropagation(); markAsAbsent(${studentId}, '${dateStr}')">
                  <span class="btn-icon">‚ö™</span>
                </button>
              </div>
            `;
          }

          const studentPayload = JSON.stringify(student).replace(/"/g, '&quot;');

          return `
            <div class="student-card">
              <div class="student-info">
                <div class="student-avatar">${initials}</div>
                <div class="student-details">
                  <div class="student-name student-name-clickable" onclick="openStudentDetails(${studentPayload}, '${classDate}')">${displayName}</div>
                  <div class="student-status">${student.statusLabel || 'Active student'}</div>
                </div>
              </div>
              <div style="display: flex; align-items: center; gap: 10px; flex-wrap: wrap;">
                ${actionButtons}
                <div class="student-badges">
                  ${badges}
                </div>
              </div>
            </div>
          `;
        }

        function renderEmptyState(text) {
          return `
            <div class="empty-state">
              <div class="empty-state-icon">üìÖ</div>
              <div class="empty-state-text">${text}</div>
            </div>
          `;
        }

        function getEventIcon(type) {
          return EVENT_STYLE_MAP[type]?.icon || 'üìå';
        }

        function showModal() {
          const modal = document.getElementById('dayModal');
          modal.classList.add('active');
          document.body.style.overflow = 'hidden';
        }
      }

      // ============================================================
      // üî¥ FUCHSIA DOT - Reassignment Modal
      // ============================================================
      async function reassignPaymentFromModal(paymentId, studentId, studentName, amount, receiptDate, currentForClass) {
        // Get student's unpaid classes
        const student = (window.studentsCache || []).find(s => 
          String(s.id) === String(studentId) || s.name === studentName
        );

        if (!student) {
          await customAlert('Error', 'Student not found');
          return;
        }

        const unpaidClasses = await getStudentUnpaidClasses(student);

        // Create custom modal
        const result = await showReassignmentPickerModal({
          studentName,
          currentForClass,
          receiptDate,
          paymentAmount: amount,
          unpaidClasses,
          paymentId,
          studentId
        });

        if (!result) {
          return; // User canceled
        }

        // Handle ignore action
        if (result.action === 'ignore') {
          await ignorePayment(paymentId, studentId, studentName, amount, currentForClass);
          return;
        }

        // Handle reassignment
        const newDate = result.date;

        // Validate date format
        if (!/^\d{4}-\d{2}-\d{2}$/.test(newDate)) {
          await customAlert('Invalid Date', 'Please enter a date in YYYY-MM-DD format (e.g., 2025-12-15)');
          return;
        }

        // Update the for_class column in Supabase
        try {
          const { error } = await supabaseClient
            .from('payments')
            .update({ for_class: newDate })
            .eq('id', paymentId);

          if (error) {
            console.error('‚ùå Error reassigning payment:', error);
            await customAlert('Error', `Failed to reassign payment: ${error.message}`);
            return;
          }

          // ‚úÖ CREATE NOTIFICATION
          await createNotification('payment_reassignment', studentName);

          // ‚ö° IMMEDIATE VISUAL FEEDBACK - Change fuchsia dot to green and remove it
          const fuchsiaDot = document.querySelector(`.fuchsia-dot[data-payment-id="${paymentId}"]`);
          if (fuchsiaDot) {
            fuchsiaDot.style.background = 'linear-gradient(135deg, #00ff00 0%, #00cc00 100%)';
            fuchsiaDot.style.boxShadow = '0 0 8px rgba(0, 255, 0, 0.6)';
            fuchsiaDot.classList.remove('fuchsia-dot');
            fuchsiaDot.classList.add('green-dot');
            
            // Remove the dot after a short delay
            setTimeout(() => {
              fuchsiaDot.style.opacity = '0';
              setTimeout(() => fuchsiaDot.remove(), 300);
            }, 800);
          }

          await customAlert('Success', `‚úÖ Payment reassigned from ${currentForClass} to ${newDate}`);

          // DON'T reload calendar - keep the visual changes visible
          // User can manually refresh if needed
          
          // Close the day modal
          closeDayModal();
        } catch (err) {
          console.error('‚ùå Exception reassigning payment:', err);
          await customAlert('Error', `Failed to reassign payment: ${err.message}`);
        }
      }

      async function ignorePayment(paymentId, studentId, studentName = 'Unknown', amount = 0, forClass = 'Unknown') {
        try {
          // Get current user email from Supabase session
          let userEmail = 'admin';
          try {
            const { data: { session } } = await supabaseClient.auth.getSession();
            if (session?.user?.email) {
              userEmail = session.user.email;
            }
          } catch (err) {
            console.warn('Could not get user email:', err);
          }

          const { error } = await supabaseClient
            .from('ignored_fuchsia_payments')
            .insert({
              payment_id: paymentId,
              student_id: studentId,
              ignored_by: userEmail
            });

          if (error) {
            console.error('‚ùå Error ignoring payment:', error);
            await customAlert('Error', `Failed to ignore payment: ${error.message}`);
            return false;
          }

          // ‚úÖ CREATE NOTIFICATION
          await createNotification('payment_ignored', studentName);

          await customAlert('Success', '‚úÖ Payment ignored. Fuchsia dot will no longer appear.');
          
          // Reload calendar to reflect changes
          if (typeof renderCalendar === 'function') {
            await loadPayments(); // Refresh payment data
            renderCalendar();
          }
          
          return true;
        } catch (err) {
          console.error('‚ùå Exception ignoring payment:', err);
          await customAlert('Error', `Failed to ignore payment: ${err.message}`);
          return false;
        }
      }

      // ============================================================
      async function showReassignmentModal(fuchsiaDot) {
        const studentName = fuchsiaDot.studentName;
        const currentForClass = fuchsiaDot.forClass;
        const receiptDate = fuchsiaDot.receiptDate;
        const paymentAmount = fuchsiaDot.paymentAmount;
        const paymentId = fuchsiaDot.paymentId;
        const studentId = fuchsiaDot.studentId;

        // Find the student object
        const student = (window.studentsCache || []).find(s => 
          String(s.id) === String(studentId) || s.name === studentName
        );

        if (!student) {
          await customAlert('Error', 'Student not found');
          return;
        }

        // Get student's unpaid classes
        const unpaidClasses = await getStudentUnpaidClasses(student);

        // Create custom modal
        const result = await showReassignmentPickerModal({
          studentName,
          currentForClass,
          receiptDate,
          paymentAmount,
          unpaidClasses,
          paymentId,
          studentId
        });

        if (!result) {
          return; // User canceled
        }

        // Handle ignore action
        if (result.action === 'ignore') {
          await ignorePayment(paymentId, studentId, studentName, paymentAmount, currentForClass);
          return;
        }

        // Handle reassignment
        const newDate = result.date;

        // Validate date format
        if (!/^\d{4}-\d{2}-\d{2}$/.test(newDate)) {
          await customAlert('Invalid Date', 'Please enter a date in YYYY-MM-DD format (e.g., 2025-12-15)');
          return;
        }

        // Update the for_class column in Supabase
        try {
          const { error } = await supabaseClient
            .from('payments')
            .update({ for_class: newDate })
            .eq('id', paymentId);

          if (error) {
            console.error('‚ùå Error reassigning payment:', error);
            await customAlert('Error', `Failed to reassign payment: ${error.message}`);
            return;
          }

          await customAlert('Success', `‚úÖ Payment reassigned from ${currentForClass} to ${newDate}`);

          // Reload calendar to reflect changes
          if (typeof renderCalendar === 'function') {
            await loadPayments(); // Refresh payment data
            renderCalendar();
          }
        } catch (err) {
          console.error('‚ùå Exception reassigning payment:', err);
          await customAlert('Error', `Failed to reassign payment: ${err.message}`);
        }
      }

      async function getStudentUnpaidClasses(student) {
        const unpaidClasses = [];
        const studentId = String(student.id);

        // Get all days from the current dayMap that have classes
        // dayMap is available from the parent scope where this function is called
        if (!window.currentDayMap) {
          console.warn('No dayMap available for unpaid classes lookup');
          return [];
        }

        Object.values(window.currentDayMap).forEach(dayEntry => {
          if (!dayEntry || !dayEntry.groups || !dayEntry.dateStr) return;

          const dateStr = dayEntry.dateStr;

          // Check each group on this day
          dayEntry.groups.forEach(groupEntry => {
            if (!groupEntry.students) return;

            // Check if this student is in this class
            const studentInClass = groupEntry.students.find(s => 
              String(s.id) === studentId || s.name === student.name
            );

            if (!studentInClass) return;

            // Check if student is unpaid for this class
            if (studentInClass.status === 'unpaid') {
              unpaidClasses.push({
                dateStr,
                groupName: groupEntry.groupName,
                groupDisplay: groupEntry.groupName
              });
            }
          });
        });

        // Remove duplicates and sort by date (newest first)
        const uniqueClasses = Array.from(new Map(unpaidClasses.map(cls => [cls.dateStr, cls])).values());
        return uniqueClasses.sort((a, b) => b.dateStr.localeCompare(a.dateStr));
      }

      function showReassignmentPickerModal({ studentName, currentForClass, receiptDate, paymentAmount, unpaidClasses, paymentId, studentId }) {
        return new Promise((resolve) => {
          // Create modal overlay
          const overlay = document.createElement('div');
          overlay.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(8px);
            z-index: 10000;
            display: flex;
            align-items: center;
            justify-content: center;
            animation: fadeIn 0.2s ease;
          `;

          // Create modal container
          const modal = document.createElement('div');
          modal.style.cssText = `
            background: linear-gradient(135deg, rgba(30, 30, 50, 0.95), rgba(50, 50, 80, 0.95));
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: 30px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
          `;

          // Build modal content
          modal.innerHTML = `
            <h2 style="color: #ff00ff; margin: 0 0 20px 0; font-size: 24px;">Reassign Payment</h2>
            
            <div style="background: rgba(255, 0, 255, 0.1); border-left: 4px solid #ff00ff; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
              <h3 style="margin: 0 0 10px 0; color: #ff00ff; font-size: 16px;">üî¥ Misallocated Payment</h3>
              <p style="margin: 5px 0; color: #fff;"><strong>Student:</strong> ${studentName}</p>
              <p style="margin: 5px 0; color: #fff;"><strong>Payment Amount:</strong> $${paymentAmount}</p>
              <p style="margin: 5px 0; color: #fff;"><strong>Receipt Date:</strong> ${receiptDate}</p>
              <p style="margin: 5px 0; color: #fff;"><strong>Currently Allocated To:</strong> ${currentForClass}</p>
              <p style="margin: 10px 0 0 0; color: #ff6b6b;">
                <strong>Issue:</strong> This payment is allocated to ${currentForClass}, but ${studentName} has NO scheduled class on this date.
              </p>
            </div>

            <div style="margin-bottom: 20px;">
              <label style="display: block; margin-bottom: 10px; color: #fff; font-weight: bold;">Select New Class Date:</label>
              <input type="date" id="reassignDatePicker" value="${currentForClass}" 
                style="width: 100%; padding: 12px; border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.2); 
                background: rgba(255, 255, 255, 0.1); color: #fff; font-size: 16px; cursor: pointer;">
            </div>

            ${unpaidClasses.length > 0 ? `
              <div style="margin-bottom: 20px;">
                <label style="display: block; margin-bottom: 10px; color: #fff; font-weight: bold;">Or Quick Select from Unpaid Classes:</label>
                <div id="unpaidClassesList" style="display: flex; flex-direction: column; gap: 8px; max-height: 200px; overflow-y: auto;">
                  ${unpaidClasses.map(cls => `
                    <button class="unpaid-class-btn" data-date="${cls.dateStr}" 
                      style="background: linear-gradient(135deg, rgba(255, 107, 107, 0.2), rgba(255, 107, 107, 0.3)); 
                      border: 1px solid rgba(255, 107, 107, 0.4); color: #fff; padding: 12px; 
                      border-radius: 8px; cursor: pointer; text-align: left; transition: all 0.2s; font-size: 14px;">
                      <div style="font-weight: bold;">${cls.dateStr}</div>
                      <div style="font-size: 12px; opacity: 0.8;">${cls.groupDisplay} ‚Ä¢ Unpaid</div>
                    </button>
                  `).join('')}
                </div>
              </div>
            ` : `
              <div style="padding: 15px; background: rgba(76, 175, 80, 0.1); border-radius: 8px; margin-bottom: 20px;">
                <p style="margin: 0; color: #4caf50;">‚úÖ No unpaid classes found for ${studentName}</p>
              </div>
            `}

            <div style="display: flex; gap: 10px; margin-top: 20px; flex-wrap: wrap;">
              <button id="addCreditBtn" style="flex: 1; min-width: 140px; padding: 12px; background: rgba(255, 235, 59, 0.2); 
                border: 1px solid rgba(255, 235, 59, 0.4); color: #ffeb3b; border-radius: 8px; 
                cursor: pointer; font-size: 16px; transition: all 0.2s; font-weight: bold;">Add as Credit</button>
              <button id="ignoreBtn" style="flex: 1; min-width: 120px; padding: 12px; background: rgba(255, 152, 0, 0.2); 
                border: 1px solid rgba(255, 152, 0, 0.4); color: #ff9800; border-radius: 8px; 
                cursor: pointer; font-size: 16px; transition: all 0.2s;">Ignore</button>
              <button id="cancelBtn" style="flex: 1; min-width: 120px; padding: 12px; background: rgba(255, 255, 255, 0.1); 
                border: 1px solid rgba(255, 255, 255, 0.2); color: #fff; border-radius: 8px; 
                cursor: pointer; font-size: 16px; transition: all 0.2s;">Cancel</button>
              <button id="okBtn" style="flex: 1; min-width: 120px; padding: 12px; background: linear-gradient(135deg, #667eea, #764ba2); 
                border: none; color: #fff; border-radius: 8px; cursor: pointer; font-size: 16px; 
                font-weight: bold; transition: all 0.2s;">Reassign</button>
            </div>
          `;

          overlay.appendChild(modal);
          document.body.appendChild(overlay);

          const datePicker = modal.querySelector('#reassignDatePicker');
          const okBtn = modal.querySelector('#okBtn');
          const cancelBtn = modal.querySelector('#cancelBtn');
          const addCreditBtn = modal.querySelector('#addCreditBtn');
          const ignoreBtn = modal.querySelector('#ignoreBtn');
          const unpaidBtns = modal.querySelectorAll('.unpaid-class-btn');

          // Unpaid class button click handlers
          unpaidBtns.forEach(btn => {
            btn.addEventListener('click', () => {
              const date = btn.getAttribute('data-date');
              datePicker.value = date;
              // Highlight selected
              unpaidBtns.forEach(b => b.style.background = 'linear-gradient(135deg, rgba(255, 107, 107, 0.2), rgba(255, 107, 107, 0.3))');
              btn.style.background = 'linear-gradient(135deg, rgba(102, 126, 234, 0.4), rgba(118, 75, 162, 0.4))';
            });

            // Hover effect
            btn.addEventListener('mouseenter', () => {
              if (btn.style.background.includes('234')) return; // Skip if selected
              btn.style.background = 'linear-gradient(135deg, rgba(255, 107, 107, 0.3), rgba(255, 107, 107, 0.4))';
            });
            btn.addEventListener('mouseleave', () => {
              if (btn.style.background.includes('234')) return; // Skip if selected
              btn.style.background = 'linear-gradient(135deg, rgba(255, 107, 107, 0.2), rgba(255, 107, 107, 0.3))';
            });
          });

          // Ignore button hover effect
          ignoreBtn.addEventListener('mouseenter', () => {
            ignoreBtn.style.background = 'rgba(255, 152, 0, 0.3)';
          });
          ignoreBtn.addEventListener('mouseleave', () => {
            ignoreBtn.style.background = 'rgba(255, 152, 0, 0.2)';
          });

          // Button hover effects
          okBtn.addEventListener('mouseenter', () => {
            okBtn.style.transform = 'translateY(-2px)';
            okBtn.style.boxShadow = '0 8px 20px rgba(102, 126, 234, 0.4)';
          });
          okBtn.addEventListener('mouseleave', () => {
            okBtn.style.transform = 'translateY(0)';
            okBtn.style.boxShadow = 'none';
          });

          cancelBtn.addEventListener('mouseenter', () => {
            cancelBtn.style.background = 'rgba(255, 255, 255, 0.15)';
          });
          cancelBtn.addEventListener('mouseleave', () => {
            cancelBtn.style.background = 'rgba(255, 255, 255, 0.1)';
          });

          // Add as Credit button hover effect
          addCreditBtn.addEventListener('mouseenter', () => {
            addCreditBtn.style.background = 'rgba(255, 235, 59, 0.3)';
            addCreditBtn.style.transform = 'translateY(-2px)';
            addCreditBtn.style.boxShadow = '0 8px 20px rgba(255, 235, 59, 0.4)';
          });
          addCreditBtn.addEventListener('mouseleave', () => {
            addCreditBtn.style.background = 'rgba(255, 235, 59, 0.2)';
            addCreditBtn.style.transform = 'translateY(0)';
            addCreditBtn.style.boxShadow = 'none';
          });

          // Add as Credit button handler
          addCreditBtn.addEventListener('click', async () => {
            try {
              addCreditBtn.disabled = true;
              addCreditBtn.textContent = 'Adding...';
              
              // Fetch student data first
              const { data: studentData, error: studentError } = await supabaseClient
                .from('students')
                .select('*')
                .eq('id', studentId)
                .single();
              
              if (studentError || !studentData) {
                throw new Error('Could not fetch student data');
              }
              
              // Check if credit already exists for this student and date
              const { data: existingCredit, error: creditCheckError } = await supabaseClient
                .from('credit_payments')
                .select('id, amount')
                .eq('student_id', studentId)
                .eq('class_date', currentForClass)
                .maybeSingle();
              
              if (creditCheckError) {
                console.error('Error checking existing credit:', creditCheckError);
              }
              
              if (existingCredit) {
                throw new Error(`Credit of $${existingCredit.amount} already exists for this date. Cannot add duplicate credit.`);
              }
              
              // Add credit payment record
              const { data, error } = await supabaseClient
                .from('credit_payments')
                .insert({
                  student_id: studentId,
                  amount: paymentAmount,
                  class_date: currentForClass,
                  created_at: new Date().toISOString()
                })
                .select();

              if (error) throw error;

              // Update student balance
              const { error: balanceError } = await supabaseClient
                .from('students')
                .update({ 
                  balance: (studentData.balance || 0) + paymentAmount 
                })
                .eq('id', studentId);

              if (balanceError) throw balanceError;

              // Send email notification to student
              try {
                const studentEmail = studentData.email;
                if (studentEmail) {
                  // Parse email if it's JSON array string
                  let cleanEmail = String(studentEmail).trim();
                  
                  // Check if email is a JSON array string like '["email@example.com"]'
                  if (cleanEmail.startsWith('[') && cleanEmail.endsWith(']')) {
                    try {
                      const parsed = JSON.parse(cleanEmail);
                      if (Array.isArray(parsed) && parsed.length > 0) {
                        cleanEmail = String(parsed[0]).trim();
                        debugLog('üìß Parsed email from JSON array:', cleanEmail);
                      }
                    } catch (e) {
                      console.warn('‚ö†Ô∏è Failed to parse email JSON:', e);
                    }
                  }
                  
                  if (cleanEmail) {
                    addCreditBtn.textContent = 'Sending email...';
                    
                    const emailHTML = generateCreditAddedEmailHTML(studentName, paymentAmount, currentForClass);
                    const emailSubject = `üí≥ Payment Applied as Credit - $${paymentAmount}`;
                    
                    const response = await fetch(`${SUPABASE_URL}/functions/v1/send-email`, {
                      method: 'POST',
                      headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                      },
                      body: JSON.stringify({
                        to: cleanEmail,
                        subject: emailSubject,
                        html: emailHTML,
                      }),
                    });

                    if (response.ok) {
                      const result = await response.json();
                      const resendEmailId = result?.id || result?.data?.id || null;
                      
                      // 1. Log to sent_emails table (for Email System)
                      const sentEmailRecord = {
                        recipient_email: cleanEmail,
                        recipient_name: studentName,
                        subject: emailSubject,
                        html_content: emailHTML,
                        template_name: 'Credit Added',
                        email_type: 'credit_added',
                        resend_id: resendEmailId,
                        delivery_status: 'delivered',
                        status: 'sent',
                        sent_at: new Date().toISOString()
                      };
                      
                      const { data: logData, error: logError } = await supabaseClient.from('sent_emails').insert([sentEmailRecord]).select();
                      
                      if (logError) {
                        console.error('‚ö†Ô∏è Failed to log to sent_emails:', logError);
                      } else {
                        console.log('‚úÖ Credit email logged to sent_emails:', logData[0]);
                      }
                      
                      // 2. Log to notifications table (for Notification Center bell)
                      const notificationRecord = {
                        type: 'email_sent',
                        category: 'email',
                        title: 'Credit Added Notification Sent',
                        description: `Sent credit added notification to ${studentName} (${cleanEmail}) for $${paymentAmount}`,
                        student_name: studentName,
                        metadata: {
                          student_id: studentId,
                          student_name: studentName,
                          email: cleanEmail,
                          amount: paymentAmount,
                          original_date: currentForClass,
                          email_type: 'credit_added',
                          subject: emailSubject,
                          html: emailHTML
                        },
                        timestamp: new Date().toISOString(),
                        read: false,
                        created_at: new Date().toISOString()
                      };
                      
                      const { data: notifData, error: notifError } = await supabaseClient.from('notifications').insert([notificationRecord]).select();
                      
                      if (notifError) {
                        console.error('‚ö†Ô∏è Failed to log to notifications:', notifError);
                      } else {
                        console.log('‚úÖ Notification logged to notifications table:', notifData[0]);
                      }
                      
                      console.log('‚úÖ Credit email sent successfully to:', cleanEmail);
                    } else {
                      console.warn('‚ö†Ô∏è Failed to send credit email, but credit was added successfully');
                    }
                  }
                }
              } catch (emailErr) {
                console.error('‚ùå Error sending credit email:', emailErr);
                // Don't fail the entire operation if email fails
              }

              // Mark the payment as ignored so fuchsia dot disappears
              try {
                // Get current user email from Supabase session
                let userEmail = 'admin';
                try {
                  const { data: { session } } = await supabaseClient.auth.getSession();
                  if (session?.user?.email) {
                    userEmail = session.user.email;
                  }
                } catch (err) {
                  console.warn('Could not get user email:', err);
                }

                const { error } = await supabaseClient
                  .from('ignored_fuchsia_payments')
                  .insert({
                    payment_id: paymentId,
                    student_id: studentId,
                    ignored_by: userEmail
                  });

                if (error) {
                  console.error('‚ùå Error ignoring payment:', error);
                } else {
                  console.log('‚úÖ Payment marked as ignored (fuchsia dot will disappear)');
                  
                  // Create notification
                  await createNotification('payment_ignored', studentName);
                }
              } catch (ignoreErr) {
                console.error('‚ùå Exception ignoring payment:', ignoreErr);
              }

              document.body.removeChild(overlay);
              
              await customAlert('Credit Added', `$${paymentAmount} credit added to ${studentName}'s account and notification email sent.`);
              
              // Reload the calendar to update UI
              await loadPayments();
              await loadStudents();
              initializeCalendar();
              
              resolve({ action: 'credit' });
            } catch (err) {
              console.error('Error adding credit:', err);
              const errorMessage = err.message || 'Failed to add credit. Please try again.';
              await customAlert('Error', errorMessage);
              addCreditBtn.disabled = false;
              addCreditBtn.textContent = 'Add as Credit';
            }
          });

          // Ignore button handler
          ignoreBtn.addEventListener('click', () => {
            document.body.removeChild(overlay);
            resolve({ action: 'ignore' });
          });

          // OK button handler (reassign)
          okBtn.addEventListener('click', () => {
            const selectedDate = datePicker.value;
            document.body.removeChild(overlay);
            resolve({ action: 'reassign', date: selectedDate });
          });

          // Cancel button handler
          cancelBtn.addEventListener('click', () => {
            document.body.removeChild(overlay);
            resolve(null);
          });

          // ESC key handler
          const escHandler = (e) => {
            if (e.key === 'Escape') {
              document.body.removeChild(overlay);
              document.removeEventListener('keydown', escHandler);
              resolve(null);
            }
          };
          document.addEventListener('keydown', escHandler);
        });
      }

      // Close Day Modal
      function closeDayModal() {
        const modal = document.getElementById('dayModal');
        modal.classList.remove('active');
        document.body.style.overflow = '';
      }

      // Switch Modal Tab
      function switchModalTab(event, tabId) {
        // Remove active class from all tabs and panels
        const tabs = document.querySelectorAll('.modal-tab');
        const panels = document.querySelectorAll('.tab-panel');
        
        tabs.forEach(tab => tab.classList.remove('active'));
        panels.forEach(panel => panel.classList.remove('active'));
        
        // Add active class to clicked tab and corresponding panel
        event.currentTarget.classList.add('active');
        const targetPanel = document.querySelector(`[data-tab="${tabId}"]`);
        if (targetPanel) {
          targetPanel.classList.add('active');
        }
      }

      // Toggle Auto Reminder
      function toggleAutoReminder(studentId, studentName) {
        const button = document.querySelector(`[data-student-id="${studentId}"].pause`);
        if (!button) {
          // console.warn('Toggle auto reminder button not found for', studentId);
          return;
        }
        const isPaused = button.classList.contains('paused');

        button.classList.toggle('paused');
        button.innerHTML = isPaused ? '‚è∏' : '‚ñ∂';
        button.setAttribute('data-tooltip', isPaused ? 'Pause Auto Reminder' : 'Resume Auto Reminder');

        debugLog(`${isPaused ? 'Resumed' : 'Paused'} auto reminder for ${studentName}`);

        // Here you would make an API call to update the student's auto-reminder status
        // Example: await updateAutoReminder(studentId, !isPaused);
      }

      // Pause Student
      async function pauseStudent(studentId, studentName) {
        try {
          debugLog(`Preparing to pause student ${studentName}`, { studentId });

          // Show confirmation dialog
          const confirmed = await showConfirmDialog(
            'Pause Student?',
            `
              <div style="text-align: left; line-height: 1.6;">
                <div style="margin-bottom: 12px;"><strong>Student:</strong> ${studentName}</div>
                <div style="margin-top: 16px; padding: 12px; background: rgba(255,193,7,0.1); border-radius: 8px; font-size: 13px; color: rgba(255,255,255,0.8);">
                  This will temporarily pause all classes for this student. They won't appear on the calendar until resumed.
                </div>
              </div>
            `
          );

          if (!confirmed) return;

          // Update student status to paused
          try {
            const { error } = await window.supabaseClient
              .from('students')
              .update({ status: 'paused' })
              .eq('id', studentId);

            if (error) throw error;

            showSuccessToast(`‚è∏ ${studentName} has been paused`);
            debugLog(`‚úÖ Student paused: ${studentName}`);
            
            // Refresh calendar
            await loadAllData();
            renderCalendar(currentDate);
          } catch (dbErr) {
            console.error('‚ùå Failed to pause student:', dbErr);
            showErrorToast(`‚ùå Failed to pause student: ${dbErr.message}`);
          }
        } catch (err) {
          console.error('‚ùå Error pausing student:', err);
          showErrorToast('‚ùå Error pausing student. Please try again.');
        }
      }

      // Forward Student to Next Payment Cycle
      async function forwardStudent(studentId, studentName) {
        try {
          debugLog(`Preparing to forward student ${studentName}`, { studentId });

          // Show confirmation dialog
          const confirmed = await showConfirmDialog(
            'Forward to Next Cycle?',
            `
              <div style="text-align: left; line-height: 1.6;">
                <div style="margin-bottom: 12px;"><strong>Student:</strong> ${studentName}</div>
                <div style="margin-top: 16px; padding: 12px; background: rgba(38,255,230,0.1); border-radius: 8px; font-size: 13px; color: rgba(255,255,255,0.8);">
                  This will move the student to the next payment cycle, clearing current unpaid classes.
                </div>
              </div>
            `
          );

          if (!confirmed) return;

          // Update last payment date to current date
          try {
            const today = new Date().toISOString().split('T')[0];
            const { error } = await window.supabaseClient
              .from('students')
              .update({ last_payment_date: today })
              .eq('id', studentId);

            if (error) throw error;

            showSuccessToast(`‚è≠ ${studentName} forwarded to next cycle`);
            debugLog(`‚úÖ Student forwarded: ${studentName}`);
            
            // Refresh calendar
            await loadAllData();
            renderCalendar(currentDate);
          } catch (dbErr) {
            console.error('‚ùå Failed to forward student:', dbErr);
            showErrorToast(`‚ùå Failed to forward student: ${dbErr.message}`);
          }
        } catch (err) {
          console.error('‚ùå Error forwarding student:', err);
          showErrorToast('‚ùå Error forwarding student. Please try again.');
        }
      }

      // Send Manual Reminder
      async function sendManualReminder(studentId, studentName) {
        try {
          debugLog(`Preparing to send manual payment reminder to ${studentName}`, { studentId });

          // Show confirmation dialog
          const confirmed = await showConfirmDialog(
            'Send Payment Reminder?',
            `
              <div style="text-align: left; line-height: 1.6;">
                <div style="margin-bottom: 12px;"><strong>Student:</strong> ${studentName}</div>
                <div style="margin-top: 16px; padding: 12px; background: rgba(38,255,230,0.1); border-radius: 8px; font-size: 13px; color: rgba(255,255,255,0.8);">
                  This will send a payment reminder email to the student.
                </div>
              </div>
            `
          );

          if (!confirmed) return;

          // Send payment reminder email
          try {
            await sendPaymentReminderEmail(studentId);
            showSuccessToast(`‚úÖ Payment reminder sent to ${studentName}!`);
            debugLog(`‚úÖ Manual reminder sent to ${studentName}`);
          } catch (emailErr) {
            console.error('‚ùå Failed to send payment reminder email:', emailErr);
            showErrorToast(`‚ùå Failed to send email: ${emailErr.message}`);
          }
        } catch (err) {
          console.error('‚ùå Error sending reminder:', err);
          showErrorToast('‚ùå Error sending reminder. Please try again.');
        }
      }

      // Show Cash Payment Dialog with Amount Selection
      function showCashPaymentDialog(student, dateStr, defaultAmount) {
        debugLog('üîî showCashPaymentDialog called', { student, dateStr, defaultAmount });
        return new Promise((resolve) => {
          const modal = document.getElementById('confirmModal');
          const title = document.getElementById('confirmTitle');
          const message = document.getElementById('confirmMessage');
          const confirmBtn = document.getElementById('confirmBtn');
          const cancelBtn = document.getElementById('cancelBtn');
          
          debugLog('üì¶ Modal elements:', { modal, title, message, confirmBtn, cancelBtn });
          
          if (!modal || !title || !message || !confirmBtn || !cancelBtn) {
            console.error('‚ùå Missing modal elements!');
            resolve({ confirmed: false });
            return;
          }
          
          let selectedAmount = defaultAmount;
          
          title.textContent = 'Cash Payment - Select Amount';
          
          message.innerHTML = `
            <div style="text-align: left; line-height: 1.6;">
              <div style="margin-bottom: 12px;"><strong>Student:</strong> ${student.name}</div>
              <div style="margin-bottom: 12px;"><strong>Class Date:</strong> ${dateStr}</div>
              <div style="margin-bottom: 12px;"><strong>Expected:</strong> ${formatCurrency(defaultAmount)} $ (per class rate)</div>
              
              <div style="margin-top: 20px; margin-bottom: 12px;">
                <strong>Select Payment Amount:</strong>
              </div>
              
              <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin-bottom: 16px;">
                <button class="amount-btn" data-amount="25" style="padding: 12px; background: rgba(255,255,255,0.1); border: 2px solid rgba(255,255,255,0.2); border-radius: 8px; color: white; cursor: pointer; font-size: 16px; font-weight: 600; transition: all 0.2s;">
                  $25
                </button>
                <button class="amount-btn" data-amount="50" style="padding: 12px; background: rgba(255,255,255,0.1); border: 2px solid rgba(255,255,255,0.2); border-radius: 8px; color: white; cursor: pointer; font-size: 16px; font-weight: 600; transition: all 0.2s;">
                  $50
                </button>
                <button class="amount-btn" data-amount="75" style="padding: 12px; background: rgba(255,255,255,0.1); border: 2px solid rgba(255,255,255,0.2); border-radius: 8px; color: white; cursor: pointer; font-size: 16px; font-weight: 600; transition: all 0.2s;">
                  $75
                </button>
                <button class="amount-btn" data-amount="100" style="padding: 12px; background: rgba(255,255,255,0.1); border: 2px solid rgba(255,255,255,0.2); border-radius: 8px; color: white; cursor: pointer; font-size: 16px; font-weight: 600; transition: all 0.2s;">
                  $100
                </button>
                <button class="amount-btn" data-amount="150" style="padding: 12px; background: rgba(255,255,255,0.1); border: 2px solid rgba(255,255,255,0.2); border-radius: 8px; color: white; cursor: pointer; font-size: 16px; font-weight: 600; transition: all 0.2s;">
                  $150
                </button>
                <button class="amount-btn" data-amount="200" style="padding: 12px; background: rgba(255,255,255,0.1); border: 2px solid rgba(255,255,255,0.2); border-radius: 8px; color: white; cursor: pointer; font-size: 16px; font-weight: 600; transition: all 0.2s;">
                  $200
                </button>
              </div>
              
              <div style="margin-bottom: 16px;">
                <label style="display: block; margin-bottom: 8px; color: rgba(255,255,255,0.7); font-size: 14px;">Or enter custom amount:</label>
                <input type="number" id="customAmount" min="0" step="0.01" placeholder="Enter amount" 
                       style="width: 100%; padding: 10px; background: rgba(255,255,255,0.1); border: 2px solid rgba(255,255,255,0.2); border-radius: 8px; color: white; font-size: 16px;"
                       value="${defaultAmount}">
              </div>
              
              <div id="selectedAmountDisplay" style="margin-top: 16px; padding: 12px; background: rgba(5,150,105,0.2); border-radius: 8px; font-size: 14px; color: rgba(255,255,255,0.9);">
                üíµ Selected amount: <strong>${formatCurrency(selectedAmount)} $</strong>
              </div>
            </div>
          `;
          
          // Handle amount button clicks
          const amountBtns = message.querySelectorAll('.amount-btn');
          const customInput = message.querySelector('#customAmount');
          const displayDiv = message.querySelector('#selectedAmountDisplay');
          
          function updateSelection(amount) {
            selectedAmount = parseFloat(amount);
            customInput.value = amount;
            displayDiv.innerHTML = `üíµ Selected amount: <strong>${formatCurrency(selectedAmount)} $</strong>`;
            
            // Update button styles
            amountBtns.forEach(btn => {
              if (parseFloat(btn.dataset.amount) === selectedAmount) {
                btn.style.background = 'rgba(34,197,94,0.3)';
                btn.style.borderColor = 'rgba(34,197,94,0.8)';
                btn.style.transform = 'scale(1.05)';
              } else {
                btn.style.background = 'rgba(255,255,255,0.1)';
                btn.style.borderColor = 'rgba(255,255,255,0.2)';
                btn.style.transform = 'scale(1)';
              }
            });
          }
          
          amountBtns.forEach(btn => {
            btn.addEventListener('click', (e) => {
              e.preventDefault();
              e.stopPropagation();
              updateSelection(btn.dataset.amount);
            });
            
            // Highlight default amount button
            if (parseFloat(btn.dataset.amount) === defaultAmount) {
              btn.style.background = 'rgba(34,197,94,0.3)';
              btn.style.borderColor = 'rgba(34,197,94,0.8)';
            }
          });
          
          customInput.addEventListener('input', (e) => {
            const value = parseFloat(e.target.value) || 0;
            updateSelection(value);
          });
          
          confirmBtn.textContent = 'Confirm Payment';
          
          const handleConfirm = () => {
            cleanup();
            resolve({ confirmed: true, amount: selectedAmount });
          };
          
          const handleCancel = () => {
            cleanup();
            resolve({ confirmed: false });
          };
          
          const cleanup = () => {
            confirmBtn.removeEventListener('click', handleConfirm);
            cancelBtn.removeEventListener('click', handleCancel);
            modal.classList.remove('active');
          };
          
          confirmBtn.addEventListener('click', handleConfirm);
          cancelBtn.addEventListener('click', handleCancel);
          
          debugLog('üé≠ About to show modal, adding active class');
          modal.classList.add('active');
          debugLog('‚úÖ Modal classes:', modal.className);
        });
      }

      // Mark Student as Absent
      async function markAsAbsent(studentId, dateStr) {
        try {
          // Get student info for confirmation
          const students = window.studentsCache || [];
          const student = students.find(s => s.id === studentId);
          
          if (!student) {
            showErrorToast('‚ùå Student not found');
            return;
          }

          // Show confirmation dialog
          const confirmed = await showConfirmDialog(
            'Mark Student as Absent?',
            `
              <div style="text-align: left; line-height: 1.6;">
                <div style="margin-bottom: 12px;"><strong>Student:</strong> ${student.name}</div>
                <div style="margin-bottom: 12px;"><strong>Class Date:</strong> ${dateStr}</div>
                <div style="margin-top: 16px; padding: 12px; background: rgba(100,116,139,0.2); border-radius: 8px; font-size: 13px; color: rgba(255,255,255,0.8);">
                  The student will be marked as absent for this class.
                </div>
              </div>
            `
          );

          if (!confirmed) return;

          // Use AbsentManager for cloud sync
          if (window.AbsentManager) {
            await window.AbsentManager.markAbsent(studentId, dateStr);
            debugLog('‚úÖ Marked absent via AbsentManager:', { studentId, dateStr });
            
            // Show success message
            showSuccessToast('‚ö™ Marked as absent');
            
            // Reload absences data from database to ensure fresh data
            absencesData = await loadAbsences();
            
            // ‚ö° INCREMENTAL: Only invalidate the specific day's cache
            invalidateDayCache(dateStr);
            
            // Re-render calendar (will only update changed day)
            await renderCalendar();
            
            // Refresh the dot modal to show updated status
            await refreshDotModal(studentId, dateStr);
          } else {
            throw new Error('AbsentManager not available');
          }
        } catch (err) {
          console.error('‚ùå Error marking absent:', err);
          showErrorToast('‚ùå Error marking absent. Please try again.');
        }
      }

      // Unmark Student as Absent
      async function unmarkAbsent(studentId, dateStr) {
        try {
          // Get student info for confirmation
          const students = window.studentsCache || [];
          const student = students.find(s => s.id === studentId);
          
          if (!student) {
            showErrorToast('‚ùå Student not found');
            return;
          }

          // Show confirmation dialog
          const confirmed = await showConfirmDialog(
            'Remove Absent Status?',
            `
              <div style="text-align: left; line-height: 1.6;">
                <div style="margin-bottom: 12px;"><strong>Student:</strong> ${student.name}</div>
                <div style="margin-bottom: 12px;"><strong>Class Date:</strong> ${dateStr}</div>
                <div style="margin-top: 16px; padding: 12px; background: rgba(34,197,94,0.2); border-radius: 8px; font-size: 13px; color: rgba(255,255,255,0.8);">
                  The absent status will be removed for this class.
                </div>
              </div>
            `
          );

          if (!confirmed) return;

          // Use AbsentManager for cloud sync
          if (window.AbsentManager) {
            await window.AbsentManager.removeAbsent(studentId, dateStr);
            debugLog('‚úÖ Unmarked absent via AbsentManager:', { studentId, dateStr });
            
            // Show success message
            showSuccessToast('‚Ü©Ô∏è Unmarked as absent');
            
            // Reload absences data from database to ensure fresh data
            absencesData = await loadAbsences();
            
            // ‚ö° INCREMENTAL: Only invalidate the specific day's cache
            invalidateDayCache(dateStr);
            
            // Re-render calendar (will only update changed day)
            await renderCalendar();
            
            // Refresh the dot modal to show updated status
            await refreshDotModal(studentId, dateStr);
          } else {
            throw new Error('AbsentManager not available');
          }
        } catch (err) {
          console.error('‚ùå Error unmarking absent:', err);
          showErrorToast('‚ùå Error unmarking absent. Please try again.');
        }
      }

  // Mark Paid Manually
  // TODO (Payment Revamp): Reconcile this cash-payment path with the credit top-up model.
  // For now we still drop records directly into payments, but long-term this should
  // credit the student's balance and let CreditPaymentManager create the coverage entry.
      async function markPaidManually(studentId, dateStr, pricePerClass, studentName) {
        debugLog('üíµ markPaidManually called', { studentId, dateStr, pricePerClass, studentName });
        try {
          // Get student info for confirmation
          const students = window.studentsCache || [];
          const student = students.find(s => s.id === studentId);
          
          debugLog('üë§ Found student:', student);
          
          if (!student) {
            showErrorToast('‚ùå Student not found');
            return;
          }

          debugLog('üìû Calling showCashPaymentDialog...');
          // Show custom dialog with amount selection
          const result = await showCashPaymentDialog(student, dateStr, pricePerClass);
          
          debugLog('‚úÖ Dialog result:', result);
          
          if (!result || !result.confirmed) {
            debugLog('‚ùå User cancelled or dialog failed');
            return;
          }
          
          const paymentAmount = result.amount;

          // Create a manual payment record with LA timezone date
          const paymentRecord = {
            id: generatePaymentId(),
            student_id: studentId,
            student_name: student.name,
            amount: paymentAmount,
            date: dateStr,
            email_date: dateStr + 'T12:00:00',
            payer_name: student.name
          };

          // Insert into Supabase payments table
          const { error } = await supabaseClient
            .from('payments')
            .insert([paymentRecord]);

          if (error) {
            console.error('‚ùå Error creating manual payment:', error);
            showErrorToast('‚ùå Failed to create payment record');
            return;
          }

          debugLog('‚úÖ Manual cash payment created:', paymentRecord);
          
          // Show success message
          showSuccessToast('üíµ Cash payment recorded');
          
          // Close the modal
          closeDayModal();
          
          // Reload payment data and invalidate specific day
          await loadPayments();
          
          // ‚ö° INCREMENTAL: Only invalidate the specific day's cache
          invalidateDayCache(dateStr);
          
          // Re-render calendar (will only update changed day)
          renderCalendar();
          
        } catch (err) {
          console.error('‚ùå Error marking paid manually:', err);
          showErrorToast('‚ùå Error creating payment. Please try again.');
        }
      }

      // Apply Credit Payment
      async function applyFromCredit(studentId, dateStr, pricePerClass) {
        try {
          const normalizedId = String(studentId);
          const students = Array.isArray(window.studentsCache) ? window.studentsCache : [];
          if (!Array.isArray(window.studentsCache)) {
            window.studentsCache = students;
          }

          const classPrice = Number(pricePerClass) || 0;

          let student = students.find(s => String(s.id) === normalizedId);
          let currentBalance = 0;

          if (!student) {
            const { data, error } = await supabaseClient
              .from('students')
              .select('*')
              .eq('id', studentId)
              .single();

            if (error || !data) {
              showErrorToast('‚ùå Student not found');
              return;
            }

            student = data;
            students.push(student);
            currentBalance = parseFloat(data.balance) || 0;
          } else {
            const { data: latestBalance, error: latestBalanceError } = await supabaseClient
              .from('students')
              .select('balance')
              .eq('id', studentId)
              .single();

            if (latestBalanceError) {
              console.warn('‚ö†Ô∏è Unable to fetch latest balance, using cached value', latestBalanceError);
              currentBalance = parseFloat(student.balance) || 0;
            } else {
              currentBalance = parseFloat(latestBalance?.balance) || 0;
              student.balance = currentBalance;
            }
          }

          // Check if student has enough credit
          if (currentBalance < classPrice) {
            showErrorToast(
              `‚ùå Insufficient credit! Need ${formatCurrency(classPrice - currentBalance)} $ more.`
            );
            return;
          }

          // Show custom confirm dialog
          const newBalance = currentBalance - classPrice;
          const confirmed = await showConfirmDialog(
            'Apply Credit Payment?',
            `
              <div style="text-align: left; line-height: 1.6;">
                <div style="margin-bottom: 12px;"><strong>Student:</strong> ${student.name}</div>
                <div style="margin-bottom: 12px;"><strong>Class Date:</strong> ${dateStr}</div>
                <div style="margin-bottom: 12px;"><strong>Class Price:</strong> ${formatCurrency(classPrice)} $</div>
                <div style="margin-bottom: 12px; padding-top: 12px; border-top: 1px solid rgba(255,255,255,0.1);">
                  <strong>Current Balance:</strong> ${formatCurrency(currentBalance)} $
                </div>
                <div style="color: #22c55e; font-weight: 700;">
                  <strong>New Balance:</strong> ${formatCurrency(newBalance)} $
                </div>
              </div>
            `
          );

          if (!confirmed) {
            return;
          }

          // Deduct from balance
          student.balance = newBalance;

          // 1. Update student balance in Supabase
          const { error: updateError } = await supabaseClient
            .from('students')
            .update({ balance: newBalance })
            .eq('id', studentId);

          if (updateError) {
            console.error('üî¥ Supabase update error:', updateError);
            throw new Error(`Failed to update student balance: ${updateError.message}`);
          }

          debugLog('‚úÖ Balance updated in Supabase');

          // 2. Store credit payment tracking in credit_payments table
          // NOTE: We do NOT create a payment record - credit payments are tracked separately
          // and should NOT appear in Payment Records
          if (window.CreditPaymentManager) {
            await window.CreditPaymentManager.applyCreditPayment(studentId, dateStr, classPrice, newBalance);
            debugLog('‚úÖ Applied credit payment (Supabase):', { studentId, dateStr, amount: classPrice });
          } else {
            console.error('üî¥ CreditPaymentManager not available!');
            throw new Error('CreditPaymentManager not available');
          }

          showSuccessToast(
            `‚úÖ Applied ${formatCurrency(classPrice)} $ from credit ‚Ä¢ New Balance: ${formatCurrency(newBalance)} $`
          );

          // ‚ö° CRITICAL: Clear payment matching cache so new payment is detected
          studentPaymentMatchCache.clear();
          
          // Reload ALL payment data (both payments and credit_payments)
          await loadPayments(); // This loads the main payments table
          creditPaymentsLookup = await loadCreditPayments(); // This loads credit tracking
          await loadStudents(); // Reload students to get updated balance
          
          // ‚ö° CRITICAL: Clear month cache to force full recalculation
          clearMonthCache();
          
          // Re-render calendar (will pick up new payment)
          renderCalendar();
          
          // Refresh the dot modal to show updated status
          await refreshDotModal(studentId, dateStr);
        } catch (error) {
          console.error('‚ùå Failed to apply credit:', error);
          showErrorToast('‚ùå Failed to apply credit: ' + error.message);
        }
      }

      // Jump to Next Unpaid Class (reverse chronological - finds previous unpaid class for same student)
      async function jumpToNextUnpaid(studentId, currentDateStr) {
        try {
          const normalizedStudentId = String(studentId);
          // Find all dots for this student across all visible days
          const allStudentDots = document.querySelectorAll(
            `.indicator-dot[data-student-id="${normalizedStudentId}"]`
          );
          
          if (allStudentDots.length === 0) {
            showErrorToast('‚ÑπÔ∏è No classes found for this student');
            return;
          }
          
          // Build array of {date, status, element} objects
          const classDates = [];
          allStudentDots.forEach(dot => {
            const classDate = dot.getAttribute('data-class-date');
            const studentData = dot.getAttribute('data-student');
            
            if (classDate && studentData) {
              try {
                const studentObj = JSON.parse(studentData);
                classDates.push({
                  date: classDate,
                  status: studentObj.status,
                  element: dot
                });
              } catch (e) {
                console.error('Failed to parse student data:', e);
              }
            }
          });
          
          if (classDates.length === 0) {
            showErrorToast('‚ÑπÔ∏è No classes found for this student');
            return;
          }
          
          // Sort reverse chronological (newest first)
          classDates.sort((a, b) => b.date.localeCompare(a.date));
          
          // Find current date index
          const currentIndex = classDates.findIndex(c => c.date === currentDateStr);
          
          if (currentIndex === -1) {
            showErrorToast('‚ö†Ô∏è Current class date not found');
            return;
          }
          
          // Search for next unpaid class (reverse chronological = previous dates)
          let nextUnpaidClass = null;
          
          for (let i = currentIndex + 1; i < classDates.length; i++) {
            if (classDates[i].status === 'unpaid') {
              nextUnpaidClass = classDates[i];
              break; // Found it!
            }
          }
          
          if (!nextUnpaidClass) {
            showSuccessToast('‚úÖ No unpaid classes found for this student!');
            return;
          }

          const navigateToTarget = (message) => {
            hideCustomTooltip();
            const dayElement = nextUnpaidClass.element.closest('.day');
            if (dayElement) {
              dayElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
            setTimeout(() => {
              nextUnpaidClass.element.click();
              if (message) {
                showSuccessToast(message);
              }
            }, 400);
          };

          const isDecemberMove = currentDateStr?.startsWith('2025-12') && nextUnpaidClass.date?.startsWith('2025-12');
          if (!isDecemberMove) {
            // Outside December allocation window we can only navigate, not reassign
            navigateToTarget(`üî¥ Jumped to unpaid class on ${nextUnpaidClass.date}`);
            showErrorToast('‚ÑπÔ∏è Manual payment moving is only enabled for December 2025.');
            return;
          }

          const students = window.studentsCache || [];
          const studentRecord = students.find(s => String(s.id) === normalizedStudentId);
          const studentName = studentRecord?.name || 'Student';
          const classPrice = Number(studentRecord?.price_per_class || studentRecord?.pricePerClass || 0);
          const fromLabel = formatDateNice(currentDateStr) || currentDateStr;
          const toLabel = formatDateNice(nextUnpaidClass.date) || nextUnpaidClass.date;
          const amountLabel = classPrice > 0 ? `$${formatCurrency(classPrice)} ` : '';

          const confirmed = await showConfirmDialog(
            'Move payment to previous class?',
            `
              <div style="text-align: left; line-height: 1.6;">
                <div style="margin-bottom: 12px;"><strong>Student:</strong> ${studentName}</div>
                <div style="margin-bottom: 12px;"><strong>Current payment:</strong> ${fromLabel}</div>
                <div style="margin-bottom: 12px;"><strong>Move to class:</strong> ${toLabel}</div>
                <div style="margin-bottom: 12px;">
                  <strong>Amount:</strong> ${amountLabel || 'Class price unknown'}
                </div>
                <div style="font-size: 13px; opacity: 0.75;">
                  This will mark ${fromLabel} as unpaid and cover ${toLabel} instead.
                </div>
              </div>
            `
          );

          if (!confirmed) {
            navigateToTarget(`üî¥ Jumped to unpaid class on ${nextUnpaidClass.date}`);
            return;
          }

          await executeManualPaymentMove({
            studentId: normalizedStudentId,
            studentName,
            fromDate: currentDateStr,
            toDate: nextUnpaidClass.date,
            amount: classPrice,
          });
        } catch (error) {
          console.error('‚ùå Failed to move payment to previous class:', error);
          showErrorToast('‚ùå Error: ' + error.message);
        }
      }

      async function executeManualPaymentMove({ studentId, studentName, fromDate, toDate, amount }) {
        try {
          // ‚ö° IMMEDIATE VISUAL FEEDBACK - Update dots before database call
          const sourceDot = document.querySelector(
            `.indicator-dot[data-student-id="${studentId}"][data-class-date="${fromDate}"]`
          );
          const targetDot = document.querySelector(
            `.indicator-dot[data-student-id="${studentId}"][data-class-date="${toDate}"]`
          );

          // Change source dot to gray/unpaid
          if (sourceDot) {
            sourceDot.style.background = 'linear-gradient(135deg, #666666 0%, #444444 100%)';
            sourceDot.style.boxShadow = '0 0 6px rgba(128, 128, 128, 0.4)';
          }

          // Change target dot to green/paid
          if (targetDot) {
            targetDot.style.background = 'linear-gradient(135deg, #00ff00 0%, #00cc00 100%)';
            targetDot.style.boxShadow = '0 0 8px rgba(0, 255, 0, 0.6)';
          }

          await recordManualPaymentMove(studentId, fromDate, toDate, amount);
          const cacheKey = `${studentId}-2025-12`;
          if (studentAllocationCache && typeof studentAllocationCache.delete === 'function') {
            studentAllocationCache.delete(cacheKey);
          }
          await loadManualPaymentMovesFromSupabase(true);
          clearMonthCache();
          // DON'T call renderCalendar() - keep the visual changes visible

          // ‚úÖ CREATE NOTIFICATION
          await createNotification('payment_moved', studentName);

          showSuccessToast(`‚úÖ Moved payment from ${fromDate} ‚Üí ${toDate} for ${studentName}`);
          // DON'T scroll or click - keep the user where they are
          // setTimeout(() => {
          //   const targetDot = document.querySelector(
          //     `.indicator-dot[data-student-id="${studentId}"][data-class-date="${toDate}"]`
          //   );
          //   if (targetDot) {
          //     const targetDay = targetDot.closest('.day');
          //     if (targetDay) {
          //       targetDay.scrollIntoView({ behavior: 'smooth', block: 'center' });
          //     }
          //     targetDot.click();
          //   }
          // }, 600);
        } catch (error) {
          console.error('‚ùå Failed to record manual payment move:', error);
          showErrorToast('‚ùå Failed to move payment: ' + error.message);
        }
      }

      // Move Payment to Previous Unpaid Class (‚Üê arrow button)
      async function movePaymentToPrevious(studentId, currentDateStr) {
        try {
          const normalizedStudentId = String(studentId);
          const allStudentDots = document.querySelectorAll(
            `.indicator-dot[data-student-id="${normalizedStudentId}"]`
          );
          
          if (allStudentDots.length === 0) {
            showErrorToast('‚ÑπÔ∏è No classes found for this student');
            return;
          }
          
          const classDates = [];
          allStudentDots.forEach(dot => {
            const classDate = dot.getAttribute('data-class-date');
            const studentData = dot.getAttribute('data-student');
            
            if (classDate && studentData) {
              try {
                const studentObj = JSON.parse(studentData);
                classDates.push({
                  date: classDate,
                  status: studentObj.status,
                  element: dot
                });
              } catch (e) {
                console.error('Failed to parse student data:', e);
              }
            }
          });
          
          if (classDates.length === 0) {
            showErrorToast('‚ÑπÔ∏è No classes found for this student');
            return;
          }
          
          // Sort reverse chronological (newest first)
          classDates.sort((a, b) => b.date.localeCompare(a.date));
          
          const currentIndex = classDates.findIndex(c => c.date === currentDateStr);
          
          if (currentIndex === -1) {
            showErrorToast('‚ö†Ô∏è Current class date not found');
            return;
          }
          
          // Search for PREVIOUS unpaid class (older dates = higher index)
          let targetClass = null;
          
          for (let i = currentIndex + 1; i < classDates.length; i++) {
            if (classDates[i].status === 'unpaid') {
              targetClass = classDates[i];
              break;
            }
          }
          
          if (!targetClass) {
            showErrorToast('‚ÑπÔ∏è No older unpaid classes found for this student');
            return;
          }

          await confirmAndExecuteMove(normalizedStudentId, currentDateStr, targetClass, '‚Üê');
        } catch (error) {
          console.error('‚ùå Failed to move payment to previous class:', error);
          showErrorToast('‚ùå Error: ' + error.message);
        }
      }

      // Move Payment to Next Unpaid Class (‚Üí arrow button)
      async function movePaymentToNext(studentId, currentDateStr) {
        try {
          const normalizedStudentId = String(studentId);
          const allStudentDots = document.querySelectorAll(
            `.indicator-dot[data-student-id="${normalizedStudentId}"]`
          );
          
          if (allStudentDots.length === 0) {
            showErrorToast('‚ÑπÔ∏è No classes found for this student');
            return;
          }
          
          const classDates = [];
          allStudentDots.forEach(dot => {
            const classDate = dot.getAttribute('data-class-date');
            const studentData = dot.getAttribute('data-student');
            
            if (classDate && studentData) {
              try {
                const studentObj = JSON.parse(studentData);
                classDates.push({
                  date: classDate,
                  status: studentObj.status,
                  element: dot
                });
              } catch (e) {
                console.error('Failed to parse student data:', e);
              }
            }
          });
          
          if (classDates.length === 0) {
            showErrorToast('‚ÑπÔ∏è No classes found for this student');
            return;
          }
          
          // Sort reverse chronological (newest first)
          classDates.sort((a, b) => b.date.localeCompare(a.date));
          
          const currentIndex = classDates.findIndex(c => c.date === currentDateStr);
          
          if (currentIndex === -1) {
            showErrorToast('‚ö†Ô∏è Current class date not found');
            return;
          }
          
          // Search for NEXT unpaid class (newer dates = lower index)
          let targetClass = null;
          
          for (let i = currentIndex - 1; i >= 0; i--) {
            if (classDates[i].status === 'unpaid') {
              targetClass = classDates[i];
              break;
            }
          }
          
          // If no unpaid class found, look for next upcoming (gray) class
          if (!targetClass) {
            for (let i = currentIndex - 1; i >= 0; i--) {
              if (classDates[i].status === 'upcoming') {
                targetClass = classDates[i];
                break;
              }
            }
          }
          
          if (!targetClass) {
            showErrorToast('‚ÑπÔ∏è No newer unpaid or upcoming classes found for this student');
            return;
          }

          await confirmAndExecuteMove(normalizedStudentId, currentDateStr, targetClass, '‚Üí');
        } catch (error) {
          console.error('‚ùå Failed to move payment to next class:', error);
          showErrorToast('‚ùå Error: ' + error.message);
        }
      }

      // Shared confirmation and execution helper for both arrow directions
      async function confirmAndExecuteMove(studentId, fromDate, targetClass, direction) {
        const navigateToTarget = (message) => {
          hideCustomTooltip();
          const dayElement = targetClass.element.closest('.day');
          if (dayElement) {
            dayElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
          }
          setTimeout(() => {
            targetClass.element.click();
            if (message) {
              showSuccessToast(message);
            }
          }, 400);
        };

        const isDecemberMove = fromDate?.startsWith('2025-12') && targetClass.date?.startsWith('2025-12');
        if (!isDecemberMove) {
          navigateToTarget(`üî¥ Jumped to unpaid class on ${targetClass.date}`);
          showErrorToast('‚ÑπÔ∏è Manual payment moving is only enabled for December 2025.');
          return;
        }

        const students = window.studentsCache || [];
        const studentRecord = students.find(s => String(s.id) === studentId);
        const studentName = studentRecord?.name || 'Student';
        const classPrice = Number(studentRecord?.price_per_class || studentRecord?.pricePerClass || 0);
        const fromLabel = formatDateNice(fromDate) || fromDate;
        const toLabel = formatDateNice(targetClass.date) || targetClass.date;
        const amountLabel = classPrice > 0 ? `$${formatCurrency(classPrice)} ` : '';
        const directionLabel = direction === '‚Üê' ? 'previous (older)' : 'next (newer)';
        
        // Determine if target is upcoming (gray) or unpaid (red)
        const isUpcomingTarget = targetClass.status === 'upcoming';
        const statusEmoji = isUpcomingTarget ? '‚è∞' : 'üî¥';
        const statusLabel = isUpcomingTarget ? 'upcoming (gray)' : 'unpaid (red)';

        const confirmed = await showConfirmDialog(
          `Move payment to ${directionLabel} class?`,
          `
            <div style="text-align: left; line-height: 1.6;">
              <div style="margin-bottom: 12px;"><strong>Student:</strong> ${studentName}</div>
              <div style="margin-bottom: 12px;"><strong>Current payment:</strong> ${fromLabel}</div>
              <div style="margin-bottom: 12px;"><strong>Move to class:</strong> ${toLabel} ${direction}</div>
              <div style="margin-bottom: 12px;">
                <strong>Target status:</strong> ${statusEmoji} ${statusLabel}
              </div>
              <div style="margin-bottom: 12px;">
                <strong>Amount:</strong> ${amountLabel || 'Class price unknown'}
              </div>
              <div style="font-size: 13px; opacity: 0.75;">
                This will mark ${fromLabel} as unpaid and cover ${toLabel} instead.
              </div>
            </div>
          `
        );

        if (!confirmed) {
          navigateToTarget(`${statusEmoji} Jumped to ${statusLabel} class on ${targetClass.date}`);
          return;
        }

        await executeManualPaymentMove({
          studentId,
          studentName,
          fromDate,
          toDate: targetClass.date,
          amount: classPrice,
        });
      }

      // Cancel Class
      async function cancelClass(groupName, dateStr) {
        try {
          // Get students in this group
          const groups = window.groupsCache || [];
          const targetCode = canonicalizeGroupCode(groupName);
          const group = groups.find(g => {
            const candidateCode = g.group_code || canonicalizeGroupCode(g.group_name || g.name || '');
            if (targetCode) return candidateCode === targetCode;
            const normalizedLabel = (g.group_name || g.name || '').trim().toLowerCase();
            return !candidateCode && normalizedLabel === (groupName || '').trim().toLowerCase();
          });
          
          if (!group) {
            showErrorToast('‚ùå Group not found');
            return;
          }

          // Get students for this group
          const students = window.studentsCache || [];
          const groupStudents = students.filter(s => {
            const sources = [
              s.group_code,
              s.group_display,
              s.group_name,
              s.group,
              s.groupName,
            ];
            if (Array.isArray(s.groups)) {
              sources.push(...s.groups);
            }

            return sources.some(value => {
              if (!value) return false;
              if (!targetCode) {
                return !canonicalizeGroupCode(value);
              }
              const candidate = canonicalizeGroupCode(value);
              return candidate === targetCode;
            });
          });

          // Show confirmation dialog
          const confirmed = await showConfirmDialog(
            'Cancel Class?',
            `
              <div style="text-align: left; line-height: 1.6;">
                <div style="margin-bottom: 12px;"><strong>Group:</strong> ${groupName}</div>
                <div style="margin-bottom: 12px;"><strong>Date:</strong> ${dateStr}</div>
                <div style="margin-bottom: 12px;"><strong>Students:</strong> ${groupStudents.length}</div>
                <div style="margin-top: 16px; padding: 12px; background: rgba(239,68,68,0.2); border-radius: 8px; font-size: 13px; color: rgba(255,255,255,0.8);">
                  üìß Cancellation emails will be sent to all students in this class
                </div>
              </div>
            `
          );

          if (!confirmed) return;

          // Save to Supabase
          const { error: insertError } = await supabaseClient
            .from('skipped_classes')
            .insert({
              group_name: groupName,
              class_date: dateStr,
              skip_type: 'class-canceled',
              note: 'Class canceled'
            });

          if (insertError) {
            throw new Error(`Failed to cancel class: ${insertError.message}`);
          }

          // Send cancellation emails to all students
          let emailsSent = 0;
          for (const student of groupStudents) {
            if (student.email) {
              try {
                // TODO: Replace with actual email sending function
                debugLog(`üìß Sending cancellation email to ${student.name} (${student.email})`);
                // await sendCancellationEmail(student, groupName, dateStr);
                emailsSent++;
              } catch (emailError) {
                console.error(`‚ö†Ô∏è Failed to send email to ${student.name}:`, emailError);
              }
            }
          }

          showSuccessToast(
            `‚úÖ Class canceled ‚Ä¢ ${emailsSent} email${emailsSent !== 1 ? 's' : ''} sent`
          );

          // Close the modal
          closeDayModal();

          // Reload skipped classes and refresh calendar
          skippedClassesData = await loadSkippedClasses();
          clearMonthCache();
          renderCalendar();
        } catch (error) {
          console.error('‚ùå Failed to cancel class:', error);
          showErrorToast('‚ùå Failed to cancel class: ' + error.message);
        }
      }

      // Uncancel Class
      async function uncancelClass(groupName, dateStr) {
        try {
          // Show confirmation dialog
          const confirmed = await showConfirmDialog(
            'Restore Class?',
            `
              <div style="text-align: left; line-height: 1.6;">
                <div style="margin-bottom: 12px;"><strong>Group:</strong> ${groupName}</div>
                <div style="margin-bottom: 12px;"><strong>Date:</strong> ${dateStr}</div>
                <div style="margin-top: 16px; padding: 12px; background: rgba(34,197,94,0.2); border-radius: 8px; font-size: 13px; color: rgba(255,255,255,0.8);">
                  The class will be restored to the schedule
                </div>
              </div>
            `
          );

          if (!confirmed) return;

          // Delete from Supabase
          const { error: deleteError } = await supabaseClient
            .from('skipped_classes')
            .delete()
            .eq('group_name', groupName)
            .eq('class_date', dateStr);

          if (deleteError) {
            throw new Error(`Failed to restore class: ${deleteError.message}`);
          }

          showSuccessToast('‚úÖ Class restored to schedule');

          // Close the modal
          closeDayModal();

          // Reload skipped classes and refresh calendar
          skippedClassesData = await loadSkippedClasses();
          clearMonthCache();
          renderCalendar();
        } catch (error) {
          console.error('‚ùå Failed to restore class:', error);
          showErrorToast('‚ùå Failed to restore class: ' + error.message);
        }
      }

      // Open Student Details Modal
      function openStudentDetails(student, classDate) {
        const modalBody = document.getElementById('modalBody');
        const modalTitle = document.getElementById('modalDate');
        const modalSubtitle = document.getElementById('modalDayOfWeek');

        // Update modal header
        modalTitle.textContent = student.name;
        modalSubtitle.textContent = student.groupName || 'Student Details';

        // Get full student record from cache to get balance
        const students = window.studentsCache || [];
        const fullStudent = students.find(s => s.id === student.id) || student;
        const studentBalance = parseFloat(fullStudent.balance) || 0;
        const pricePerClass = parseFloat(fullStudent.price_per_class) || parseFloat(fullStudent.pricePerClass) || parseFloat(student.pricePerClass) || 0;
        const classesRemaining = pricePerClass > 0 ? Math.floor(studentBalance / pricePerClass) : 0;
        
        debugLog('üîç Student Details Modal:', {
          name: student.name,
          status: student.status,
          studentBalance,
          pricePerClass,
          hasEnoughCredit: studentBalance >= pricePerClass,
          priceIsValid: pricePerClass > 0,
          shouldShowButton: student.status === 'unpaid' && studentBalance >= pricePerClass && pricePerClass > 0
        });

        // Build action buttons based on status
        let actionButtons = '';
        
        if (student.status === 'absent' || student.absent) {
          actionButtons = `
            <div class="quick-actions-grid">
              <button class="quick-action-btn secondary" onclick="unmarkAbsent(${student.id}, '${classDate}')">
                ‚Ü©Ô∏è Unmark Absent
              </button>
            </div>
          `;
        } else if (student.status === 'unpaid') {
          // ONLY truly unpaid classes get payment reminder actions (not upcoming)
          const safeName = student.name.replace(/'/g, "\\'");
          let buttons = `
            <button class="quick-action-btn pause" 
                    onclick="event.stopPropagation(); pauseStudent(${student.id}, '${safeName}')"
                    title="Pause student">
              ‚è∏
            </button>
            <button class="quick-action-btn forward" 
                    onclick="event.stopPropagation(); forwardStudent(${student.id}, '${safeName}')"
                    title="Forward to next cycle">
              ‚è≠
            </button>
            <button class="quick-action-btn email-reminder" 
                    onclick="event.stopPropagation(); sendManualReminder(${student.id}, '${safeName}')"
                    title="Send payment reminder">
              üí≥
            </button>
            <button class="quick-action-btn tertiary" 
                    onclick="markAsAbsent(${student.id}, '${classDate}')"
                    title="Mark as absent">
              ‚ö™
            </button>
          `;
          
          // Add credit button if student has sufficient balance
          if (studentBalance >= pricePerClass && pricePerClass > 0) {
            buttons += `
              <button class="quick-action-btn secondary" onclick="applyFromCredit(${student.id}, '${classDate}', ${pricePerClass})">
                üí≥ Apply from Credit (${formatCurrency(studentBalance)} $)
              </button>
            `;
          }
          
          actionButtons = `<div class="quick-actions-grid">${buttons}</div>`;
        } else if (student.status === 'upcoming') {
          // Upcoming classes: no payment reminders, just ability to mark absent
          actionButtons = `
            <div class="quick-actions-grid">
              <button class="quick-action-btn tertiary" 
                      onclick="markAsAbsent(${student.id}, '${classDate}')"
                      title="Mark as absent">
                ‚ö™ Mark Absent
              </button>
            </div>
          `;
        } else if (student.status === 'paid' || student.status === 'credit') {
          // Add action button for paid/credit status - can mark as absent
          actionButtons = `
            <div class="quick-actions-grid">
              <button class="quick-action-btn tertiary" onclick="markAsAbsent(${student.id}, '${classDate}')">
                ‚ö™ Mark Absent
              </button>
            </div>
          `;
        }

        // Build student details content
        const content = `
          <div class="student-detail-section">
            <div class="section-label">Class Date</div>
            <div class="section-content">${classDate}</div>
          </div>

          <div class="student-detail-section">
            <div class="section-label">Status</div>
            <div class="section-content">
              ${student.statusLabel || student.status || 'Active'}
            </div>
          </div>

          <div class="student-detail-section">
            <div class="section-label">Price Per Class</div>
            <div class="section-content">${formatCurrency(pricePerClass)} $</div>
          </div>

          <div class="student-detail-section">
            <div class="section-label">Balance</div>
            <div class="section-content balance">
              ${formatCurrency(studentBalance)} $
              ${studentBalance > 0 ? `<div class="balance-note">‚âà ${classesRemaining} class${classesRemaining !== 1 ? 'es' : ''} remaining</div>` : ''}
            </div>
          </div>

          ${actionButtons ? `
          <div class="student-detail-section">
            <div class="section-label">Quick Actions</div>
            ${actionButtons}
          </div>
          ` : ''}
        `;

        modalBody.innerHTML = content;
        
        // Show the modal
        const modal = document.getElementById('dayModal');
        modal.classList.add('active');
        document.body.style.overflow = 'hidden';
      }

      // Quick Action Handlers
      function addPayment(studentName) {
        debugLog(`Adding payment for ${studentName}`);

        const amount = prompt(`Enter payment amount for ${studentName}:`, '50');
        if (amount && !isNaN(amount) && parseFloat(amount) > 0) {
          debugLog(`Payment of $${amount} recorded for ${studentName}`);
          showSuccessToast(`‚úÖ Payment of $${amount} added for ${studentName}`);

          // In production: await PaymentStore.add({ student_id, amount, date, ... });
          // Then refresh calendar and close modal
        } else if (amount !== null) {
          showErrorToast('‚ùå Invalid amount entered');
        }
      }

      function applyCredit(studentName) {
        debugLog(`Applying credit for ${studentName}`);

        const amount = prompt(`Enter credit amount to apply for ${studentName}:`, '50');
        if (amount && !isNaN(amount) && parseFloat(amount) > 0) {
          const confirmed = confirm(`Apply $${amount} credit to ${studentName}'s balance?`);
          if (confirmed) {
            debugLog(`Credit of $${amount} applied for ${studentName}`);
            showSuccessToast(`‚úÖ Credit of $${amount} applied for ${studentName}`);

            // In production: await CreditPaymentManager.add({ student_id, amount, class_date, ... });
            // Then refresh calendar and update student balance
          }
        } else if (amount !== null) {
          showErrorToast('‚ùå Invalid amount entered');
        }
      }

      function markAbsent(studentName, classDate) {
        debugLog(`Marking ${studentName} as absent for ${classDate}`);

        const confirmed = confirm(`Mark ${studentName} as absent for ${classDate}?`);
        if (confirmed) {
          debugLog(`${studentName} marked as absent for ${classDate}`);
          showSuccessToast(`‚úÖ ${studentName} marked as absent for ${classDate}`);

          // In production: await AbsentManager.markAbsent(student_id, class_date);
          // Then refresh calendar to show gray dot
          // And dispatch absence:updated event
        }
      }

      // Toast Notifications
      function showSuccessToast(message) {
        showToast(message, '#22c55e');
      }

      function showErrorToast(message) {
        showToast(message, '#ef4444');
      }

      function showToast(message, color) {
        // Create toast element
        const toast = document.createElement('div');
        toast.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          background: ${color};
          color: white;
          padding: 16px 24px;
          border-radius: 12px;
          font-weight: 600;
          font-size: 0.9rem;
          box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
          z-index: 100000;
          animation: slideIn 0.3s ease-out;
          max-width: 400px;
        `;
        toast.textContent = message;

        // Add animation keyframes if not exists
        if (!document.getElementById('toast-animations')) {
          const style = document.createElement('style');
          style.id = 'toast-animations';
          style.textContent = `
            @keyframes slideIn {
              from { transform: translateX(400px); opacity: 0; }
              to { transform: translateX(0); opacity: 1; }
            }
            @keyframes slideOut {
              from { transform: translateX(0); opacity: 1; }
              to { transform: translateX(400px); opacity: 0; }
            }
          `;
          document.head.appendChild(style);
        }

        document.body.appendChild(toast);

        // Remove after 3 seconds
        setTimeout(() => {
          toast.style.animation = 'slideOut 0.3s ease-out';
          setTimeout(() => toast.remove(), 300);
        }, 3000);
      }

      // Custom Confirm Dialog
      // Custom Alert Dialog
      function customAlert(title, message) {
        return new Promise((resolve) => {
          // Create overlay
          const overlay = document.createElement('div');
          overlay.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 999999; /* ‚ö° Match dot modal z-index */
            backdrop-filter: blur(var(--list-blur));
            display: flex;
            align-items: center;
            justify-content: center;
          `;

          // Create dialog
          const dialog = document.createElement('div');
          dialog.style.cssText = `
            background: linear-gradient(135deg, rgba(30,30,46,0.98) 0%, rgba(42,42,62,0.98) 100%);
            border: 2px solid rgba(138,180,255,0.3);
            border-radius: 16px;
            padding: 24px;
            min-width: 400px;
            max-width: 500px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.7);
            pointer-events: auto;
          `;

          dialog.innerHTML = `
            <h3 style="margin: 0 0 16px 0; font-size: 20px; font-weight: 900; color: white;">${title}</h3>
            <div style="margin-bottom: 24px; color: rgba(255,255,255,0.9); font-size: 14px; white-space: pre-wrap;">
              ${message}
            </div>
            <div style="display: flex; gap: 12px; justify-content: flex-end;">
              <button id="alertOk" style="
                padding: 10px 20px;
                background: #22c55e;
                border: 1px solid #22c55e;
                border-radius: 8px;
                color: white;
                font-size: 14px;
                font-weight: 600;
                cursor: pointer;
                transition: all 0.2s;
                pointer-events: auto;
              ">OK</button>
            </div>
          `;

          overlay.appendChild(dialog);
          document.body.appendChild(overlay);

          // Add hover effects
          const okBtn = dialog.querySelector('#alertOk');
          okBtn.addEventListener('mouseover', () => {
            okBtn.style.background = '#16a34a';
          });
          okBtn.addEventListener('mouseout', () => {
            okBtn.style.background = '#22c55e';
          });

          // Handle responses
          const cleanup = () => {
            overlay.remove();
            resolve(true);
          };

          okBtn.addEventListener('click', cleanup);
          overlay.addEventListener('click', (e) => {
            if (e.target === overlay) cleanup();
          });
        });
      }

      // Custom Prompt Dialog
      function customPrompt(title, message, defaultValue = '') {
        return new Promise((resolve) => {
          // Create overlay
          const overlay = document.createElement('div');
          overlay.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 9999999;
            backdrop-filter: blur(var(--list-blur));
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
          `;

          // Create dialog
          const dialog = document.createElement('div');
          dialog.style.cssText = `
            background: linear-gradient(135deg, rgba(30,30,46,0.98) 0%, rgba(42,42,62,0.98) 100%);
            border: 2px solid rgba(138,180,255,0.3);
            border-radius: 16px;
            padding: 24px;
            min-width: 400px;
            max-width: 500px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.7);
            pointer-events: auto;
          `;

          dialog.innerHTML = `
            <h3 style="margin: 0 0 16px 0; font-size: 20px; font-weight: 900; color: white;">${title}</h3>
            <div style="margin-bottom: 16px; color: rgba(255,255,255,0.9); font-size: 14px; white-space: pre-wrap;">
              ${message}
            </div>
            <input type="text" id="promptInput" value="${defaultValue}" style="
              width: 100%;
              padding: 12px;
              margin-bottom: 24px;
              background: rgba(255,255,255,0.05);
              border: 1px solid rgba(138,180,255,0.3);
              border-radius: 8px;
              color: white;
              font-size: 14px;
              font-family: inherit;
              box-sizing: border-box;
            " />
            <div style="display: flex; gap: 12px; justify-content: flex-end;">
              <button id="promptCancel" style="
                padding: 10px 20px;
                background: rgba(255,255,255,0.05);
                border: 1px solid rgba(255,255,255,0.2);
                border-radius: 8px;
                color: white;
                font-size: 14px;
                font-weight: 600;
                cursor: pointer;
                transition: all 0.2s;
              ">Cancel</button>
              <button id="promptOk" style="
                padding: 10px 20px;
                background: #22c55e;
                border: 1px solid #22c55e;
                border-radius: 8px;
                color: white;
                font-size: 14px;
                font-weight: 600;
                cursor: pointer;
                transition: all 0.2s;
              ">OK</button>
            </div>
          `;

          overlay.appendChild(dialog);
          document.body.appendChild(overlay);

          const input = dialog.querySelector('#promptInput');
          const cancelBtn = dialog.querySelector('#promptCancel');
          const okBtn = dialog.querySelector('#promptOk');

          // Focus and select input
          setTimeout(() => {
            input.focus();
            input.select();
          }, 100);

          // Add hover effects
          cancelBtn.addEventListener('mouseover', () => {
            cancelBtn.style.background = 'rgba(255,255,255,0.1)';
          });
          cancelBtn.addEventListener('mouseout', () => {
            cancelBtn.style.background = 'rgba(255,255,255,0.05)';
          });
          
          okBtn.addEventListener('mouseover', () => {
            okBtn.style.background = '#16a34a';
          });
          okBtn.addEventListener('mouseout', () => {
            okBtn.style.background = '#22c55e';
          });

          // Handle responses
          const cleanup = (result) => {
            overlay.remove();
            resolve(result);
          };

          cancelBtn.addEventListener('click', () => cleanup(null));
          okBtn.addEventListener('click', () => cleanup(input.value));
          
          // Enter key submits
          input.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') cleanup(input.value);
          });
          
          overlay.addEventListener('click', (e) => {
            if (e.target === overlay) cleanup(null);
          });
        });
      }

      function showConfirmDialog(title, message) {
        return new Promise((resolve) => {
          // Create overlay
          const overlay = document.createElement('div');
          overlay.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 9999999;
            backdrop-filter: blur(var(--list-blur));
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
          `;

          // Create dialog
          const dialog = document.createElement('div');
          dialog.style.cssText = `
            background: linear-gradient(135deg, rgba(30,30,46,0.98) 0%, rgba(42,42,62,0.98) 100%);
            border: 2px solid rgba(138,180,255,0.3);
            border-radius: 16px;
            padding: 24px;
            min-width: 400px;
            max-width: 500px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.7);
            pointer-events: auto;
          `;

          dialog.innerHTML = `
            <h3 style="margin: 0 0 16px 0; font-size: 20px; font-weight: 900; color: white;">${title}</h3>
            <div style="margin-bottom: 24px; color: rgba(255,255,255,0.9); font-size: 14px;">
              ${message}
            </div>
            <div style="display: flex; gap: 12px; justify-content: flex-end;">
              <button id="confirmCancel" style="
                padding: 10px 20px;
                background: rgba(255,255,255,0.05);
                border: 1px solid rgba(255,255,255,0.2);
                border-radius: 8px;
                color: white;
                font-size: 14px;
                font-weight: 600;
                cursor: pointer;
                transition: all 0.2s;
              ">Cancel</button>
              <button id="confirmOk" style="
                padding: 10px 20px;
                background: #22c55e;
                border: 1px solid #22c55e;
                border-radius: 8px;
                color: white;
                font-size: 14px;
                font-weight: 600;
                cursor: pointer;
                transition: all 0.2s;
              ">Confirm</button>
            </div>
          `;

          overlay.appendChild(dialog);
          document.body.appendChild(overlay);

          // Add hover effects
          const cancelBtn = dialog.querySelector('#confirmCancel');
          const okBtn = dialog.querySelector('#confirmOk');
          
          cancelBtn.addEventListener('mouseover', () => {
            cancelBtn.style.background = 'rgba(255,255,255,0.1)';
          });
          cancelBtn.addEventListener('mouseout', () => {
            cancelBtn.style.background = 'rgba(255,255,255,0.05)';
          });
          
          okBtn.addEventListener('mouseover', () => {
            okBtn.style.background = '#16a34a';
          });
          okBtn.addEventListener('mouseout', () => {
            okBtn.style.background = '#22c55e';
          });

          // Handle responses
          const cleanup = (result) => {
            overlay.remove();
            resolve(result);
          };

          cancelBtn.addEventListener('click', () => cleanup(false));
          okBtn.addEventListener('click', () => cleanup(true));
          overlay.addEventListener('click', (e) => {
            if (e.target === overlay) cleanup(false);
          });
        });
      }

      // Initialize on load
      document.addEventListener('DOMContentLoaded', initCalendar);

      // Close module popup on overlay click
      document.addEventListener('DOMContentLoaded', () => {
        const overlay = document.getElementById('modulePopupOverlay');
        if (overlay) {
          overlay.addEventListener('click', (e) => {
            if (e.target === overlay) {
              closeModulePopup();
            }
          });
        }
      });
    </script>

    <!-- ============================================================
         MODULE POPUP OVERLAY SYSTEM
         ============================================================ -->
    <div id="modulePopupOverlay" class="module-popup-overlay">
      <div class="module-popup-container">
        <button class="module-popup-close" onclick="closeModulePopup()" aria-label="Close module" title="Close">
          <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round">
            <line x1="18" y1="6" x2="6" y2="18"></line>
            <line x1="6" y1="6" x2="18" y2="18"></line>
          </svg>
        </button>
        <iframe id="modulePopupIframe" class="module-popup-iframe" src="about:blank" title="Module Content"></iframe>
      </div>
    </div>
  </body>
</html>
