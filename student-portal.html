<!DOCTYPE html>
<html lang="en">
<head>
  <!-- ============================================================================
       STUDENT PORTAL - ARNOMA NURSING ACADEMY
       ============================================================================
       Purpose: Main student dashboard with schedule, payments, notes, and progress
       Auth: Supports both regular student login and admin impersonation mode
       Data: Direct Supabase integration (self-contained, no bundler)
       VERSION: 2024-12-24-v7 - BALANCE SIGN FIX: POSITIVE=CREDIT, NEGATIVE=DEBT
       ============================================================================ -->
  
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
  <title>Student Portal - ARNOMA v2024-12-24-v7</title>
  <link rel="icon" type="image/png" href="/richyfesta-logo.png">
  <link rel="apple-touch-icon" href="/richyfesta-logo.png">
  
  <!-- Cache Control - FORCE REFRESH -->
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate, max-age=0">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="0">
  
  <!-- Supabase SDK -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  
  <!-- GSAP for Christmas Tree Animation -->
  <script src="https://unpkg.com/gsap@3/dist/gsap.min.js"></script>
  
  <!-- Google API -->
  <script src="https://apis.google.com/js/api.js"></script>
  <script src="https://accounts.google.com/gsi/client" async defer></script>
  
  <!-- Google Fonts - Dancing Script for Christmas -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Dancing+Script:wght@400;500;600;700&display=swap" rel="stylesheet">
  
  <!-- Google Fonts - Great Vibes for Snow Effect -->
  <link href="https://fonts.googleapis.com/css2?family=Great+Vibes&display=swap" rel="stylesheet">
  
  <style>
    /* ==========================================================================
       CSS VARIABLES - CHRISTMAS ICY THEME ❄️
       ========================================================================== */
    :root {
      /* Icy Christmas Palette */
      --bg-base: #0a1628;
      --bg-gradient-start: #0f1f3d;
      --bg-gradient-end: #1a2942;
      --panel-light: rgba(79, 134, 180, 0.25);
      --panel-dark: rgba(21, 40, 66, 0.85);
      --glass-border: rgba(156, 220, 254, 0.45);
      
      /* Icy Accents */
      --accent-primary: #9cdcfe;
      --accent-secondary: #b8e6ff;
      --accent-tertiary: #d4f1ff;
      --glow-blue: rgba(156, 220, 254, 0.5);
      --glow-purple: rgba(184, 230, 255, 0.4);
      
      /* Christmas Reds (for accents) */
      --christmas-red: #ff6b6b;
      --christmas-red-glow: rgba(255, 107, 107, 0.3);
      
      /* Text */
      --text-strong: #ffffff;
      --text-muted: rgba(255, 255, 255, 0.75);
      
      /* Effects */
      --card-shadow: 0 30px 120px rgba(10, 22, 40, 0.7);
      --panel-blur: 8px;
      --modal-blur: 14px;
      --list-blur: 0px;
    }

    html {
      -webkit-text-size-adjust: 100%;
    }

    /* ==========================================================================
       PERFORMANCE: DISABLE INFINITE ANIMATIONS ONLY
       ========================================================================== */
    /* Disable infinite animations and heavy effects that kill performance */
    *, *::before, *::after {
      animation: none !important;
      animation-duration: 0s !important;
      animation-delay: 0s !important;
    }
    
    /* SELECTIVELY RE-ENABLE smooth transitions for interactive elements */
    button,
    .card,
    .system-card,
    .game-card,
    .stat-card,
    .classroom-item,
    .announcement-item,
    .carousel-nav,
    a,
    input,
    textarea,
    select,
    .note-card,
    .forum-message,
    .modal {
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1) !important;
    }
    
    /* Faster transitions for small elements */
    .system-icon,
    .game-icon,
    .stat-icon,
    .notification-badge {
      transition: transform 0.2s ease, opacity 0.2s ease !important;
    }

    /* ==========================================================================
       ANIMATIONS - Keyframe Definitions (ONLY ESSENTIAL ANIMATIONS)
       ========================================================================== */
    
    /* Keep only essential animations that are actually used */

    /* ==========================================================================
       GLOBAL RESET & BASE STYLES
       ========================================================================== */
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      background: linear-gradient(145deg, var(--bg-gradient-start), var(--bg-gradient-end));
      min-height: 100vh;
      min-height: 100dvh;
      padding: 0;
      position: relative;
      overflow-x: hidden;
    }
    
    /* ❄️ CHRISTMAS THEME - Icy Snowflake Background ❄️ */
    /* Hidden by default, shown when .christmas-theme class is on body */
    body::before,
    body::after {
      display: none;
    }
    
    body.christmas-theme::before {
      content: '❄ ❄ ❄ ❄ ❄ ❄ ❄ ❄ ❄ ❄';
      position: fixed;
      top: -50px;
      left: 0;
      right: 0;
      font-size: 30px;
      color: rgba(156, 220, 254, 0.08);
      text-align: center;
      letter-spacing: 40px;
      pointer-events: none;
      z-index: 0;
      opacity: 0.6;
      display: block;
    }
    
    body.christmas-theme::after {
      content: '❄ ❄ ❄ ❄ ❄ ❄ ❄ ❄ ❄ ❄';
      position: fixed;
      bottom: -50px;
      left: 0;
      right: 0;
      font-size: 30px;
      color: rgba(156, 220, 254, 0.08);
      text-align: center;
      letter-spacing: 40px;
      pointer-events: none;
      z-index: 0;
      opacity: 0.6;
      display: block;
    }
    
    /* Background overlay removed for performance */
    
    /* ==========================================================================
       LAYOUT COMPONENTS
       ========================================================================== */
    
    .container {
      max-width: 1200px;
      margin: 0 auto;
      position: relative;
      z-index: 1;
      padding: calc(20px + env(safe-area-inset-top, 0px))
               calc(20px + env(safe-area-inset-right, 0px))
               calc(20px + env(safe-area-inset-bottom, 0px))
               calc(20px + env(safe-area-inset-left, 0px));
    }

    .section-tabs {
      display: flex;
      gap: 12px;
      margin-bottom: 28px;
      flex-wrap: wrap;
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
      padding-bottom: 6px;
      scroll-snap-type: x proximity;
      scrollbar-width: none;
    }

    .section-tab {
      padding: 10px 18px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(15, 23, 42, 0.55);
      color: #fff;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
      backdrop-filter: blur(var(--panel-blur));
      -webkit-backdrop-filter: blur(var(--panel-blur));
    }

    .section-tab.active {
      background: linear-gradient(120deg, rgba(125,211,252,0.2), rgba(192,132,252,0.2));
      border-color: rgba(125,211,252,0.5);
      box-shadow: 0 8px 24px rgba(15, 23, 42, 0.35);
    }

    .section-panel {
      display: none;
      opacity: 0;
      transform: translateY(10px);
      transition: opacity 0.2s ease, transform 0.2s ease;
    }

    .section-panel.active {
      display: block;
      animation: fastFadeIn 0.2s ease forwards;
    }

    @keyframes fastFadeIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    /* Loading skeleton for instant feedback */
    .loading-skeleton {
      background: linear-gradient(90deg, 
        rgba(255,255,255,0.03) 0%, 
        rgba(255,255,255,0.08) 50%, 
        rgba(255,255,255,0.03) 100%);
      background-size: 200% 100%;
      /* Disabled infinite animation for performance */
      /* animation: skeletonPulse 1.5s ease-in-out infinite; */
      border-radius: 12px;
      height: 100px;
      margin-bottom: 16px;
    }

    @keyframes skeletonPulse {
      0% { background-position: 200% 0; }
      100% { background-position: -200% 0; }
    }
    
    .header {
      background: linear-gradient(145deg, rgba(15, 23, 42, 0.98), rgba(30, 41, 80, 0.95));
      backdrop-filter: blur(var(--panel-blur));
      -webkit-backdrop-filter: blur(var(--panel-blur));
      border: 1px solid rgba(255,255,255,0.12);
      padding: 32px 40px;
      border-radius: 24px;
      box-shadow: 0 25px 60px rgba(13, 16, 35, 0.7), 
                  inset 0 1px 0 rgba(255,255,255,0.05);
      margin-bottom: 32px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: 24px;
      animation: slideInLeft 0.6s ease-out;
      position: relative;
      overflow: visible;
      z-index: 999999999;
    }
    
    /* Shimmer effect removed for performance */
    
    .header-left {
      display: flex;
      align-items: center;
      gap: 24px;
    }
    
    .logo {
      width: 150px;
      height: 150px;
      filter: brightness(2.2) contrast(1.1) drop-shadow(0 0 30px rgba(102,126,234,0.8)) drop-shadow(0 0 50px rgba(150,170,255,0.6));
      border-radius: 30px;
      /* Float animation removed for performance */
      transition: transform 0.3s ease, filter 0.3s ease;
      position: relative;
      will-change: transform;
    }
    
    /* Logo overlay removed for performance */
    
    .logo:hover {
      filter: brightness(2.3) contrast(1.12) drop-shadow(0 0 32px rgba(102,126,234,0.85)) drop-shadow(0 0 55px rgba(150,170,255,0.7));
      transform: scale(1.03);
    }
    
    .header-title h1 {
      font-size: 42px;
      font-weight: 700;
      color: #ffffff;
      margin: 0;
      line-height: 1.3;
      text-shadow: 0 2px 20px rgba(0,0,0,0.2);
      display: flex !important;
      flex-direction: column !important;
      gap: 8px;
      align-items: flex-start;
    }
    
    .header-title h1 .title-line {
      font-size: 28px !important;
      font-weight: 600;
      display: block;
    }
    
    .header-title h1 .name-line {
      font-size: 42px !important;
      font-weight: 700;
      display: block;
    }
    
    /* ❄️ CHRISTMAS THEME - Dancing Script Font ❄️ */
    /* Only applies when .christmas-theme class is on body */
    body.christmas-theme #welcomeMessage {
      font-family: 'Dancing Script', cursive !important;
      font-weight: 600;
      color: var(--accent-primary);
      text-shadow: 0 0 20px var(--glow-blue), 0 2px 10px rgba(0,0,0,0.3);
      letter-spacing: 0.5px;
    }
    
    body.christmas-theme .card-title {
      font-family: 'Dancing Script', cursive !important;
      font-weight: 600;
      color: var(--accent-primary);
      text-shadow: 0 0 15px var(--glow-blue);
    }
    
    .logout-btn {
      padding: 12px 24px;
      background: linear-gradient(135deg, #ef4444, #dc2626);
      color: white;
      border: none;
      border-radius: 12px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      font-size: 14px;
      position: relative;
      overflow: hidden;
      box-shadow: 0 4px 15px rgba(239,68,68,0.2);
      display: none;
    }
    
    .logout-btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
      transition: left 0.5s;
    }
    
    .logout-btn:hover::before {
      left: 100%;
    }
    
    .logout-btn:hover {
      transform: translateY(-3px) scale(1.05);
      box-shadow: 0 6px 20px rgba(239,68,68,0.4);
    }
    
    .logout-btn:active {
      transform: translateY(-1px) scale(0.95);
    }
    
    /* Account Dropdown */
    .account-dropdown {
      position: relative;
      z-index: 999999999 !important;
    }
    
    .account-btn {
      padding: 12px 24px;
      background: linear-gradient(135deg, rgba(102,126,234,0.18), rgba(118,75,162,0.18));
      color: white;
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 12px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
      font-size: 14px;
      display: flex;
      align-items: center;
      gap: 10px;
      backdrop-filter: blur(var(--panel-blur));
      -webkit-backdrop-filter: blur(var(--panel-blur));
      box-shadow: 0 4px 15px rgba(0,0,0,0.2);
    }
    
    .account-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(102,126,234,0.25);
      background: linear-gradient(135deg, rgba(102,126,234,0.25), rgba(118,75,162,0.25));
      border-color: rgba(102,126,234,0.3);
    }
    
    .dropdown-arrow {
      font-size: 10px;
      transition: transform 0.3s ease;
    }
    
    .account-dropdown.open .dropdown-arrow {
      transform: rotate(180deg);
    }
    
    .account-menu {
      position: absolute;
      top: calc(100% + 8px);
      right: 0;
      background: linear-gradient(145deg, rgba(15, 23, 42, 0.98), rgba(30, 41, 80, 0.95));
      backdrop-filter: blur(var(--panel-blur));
      -webkit-backdrop-filter: blur(var(--panel-blur));
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 12px;
      box-shadow: 0 25px 60px rgba(13, 16, 35, 0.7), inset 0 1px 0 rgba(255,255,255,0.05);
      min-width: 180px;
      opacity: 0;
      visibility: hidden;
      transform: translateY(-10px);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      z-index: 999999999 !important;
    }
    
    .account-dropdown.open .account-menu {
      opacity: 1;
      visibility: visible;
      transform: translateY(0);
    }
    
    .account-menu-item {
      width: 100%;
      padding: 14px 18px;
      background: transparent;
      border: none;
      color: white;
      font-weight: 500;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      gap: 12px;
      text-align: left;
    }
    
    .account-menu-item:first-child {
      border-radius: 12px 12px 0 0;
    }
    
    .account-menu-item:last-child {
      border-radius: 0 0 12px 12px;
    }
    
    .account-menu-item:hover {
      background: rgba(239,68,68,0.15);
      padding-left: 22px;
    }
    
    /* Account Profile Section in Dropdown */
    .account-profile-section {
      padding: 16px;
      border-bottom: 1px solid rgba(255,255,255,0.08);
    }
    
    .account-profile-header {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 12px;
      padding-bottom: 10px;
      border-bottom: 1px solid rgba(255,255,255,0.06);
    }
    
    .profile-icon {
      font-size: 24px;
    }
    
    .profile-name {
      font-size: 15px;
      font-weight: 600;
      color: white;
    }
    
    .account-profile-details {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    
    .account-info-row {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 12px;
      font-size: 13px;
    }
    
    .account-info-label {
      color: rgba(255,255,255,0.6);
      font-weight: 500;
      min-width: 65px;
    }
    
    .account-info-value {
      color: rgba(255,255,255,0.95);
      font-weight: 500;
      text-align: right;
      flex: 1;
      word-break: break-word;
    }
    
    /* Header Actions Container */
    .header-actions {
      display: flex;
      align-items: center;
      gap: 16px;
    }
    
    /* Forum Button */
    .forum-btn {
      padding: 12px 24px;
      background: linear-gradient(135deg, rgba(59,130,246,0.18), rgba(37,99,235,0.18));
      color: white;
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 12px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
      font-size: 14px;
      display: flex;
      align-items: center;
      gap: 10px;
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      box-shadow: 0 4px 15px rgba(0,0,0,0.2);
      position: relative;
    }
    
    .forum-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(59,130,246,0.3);
      background: linear-gradient(135deg, rgba(59,130,246,0.25), rgba(37,99,235,0.25));
      border-color: rgba(59,130,246,0.3);
    }
    
    .forum-badge {
      position: absolute;
      top: -6px;
      right: -6px;
      background: linear-gradient(135deg, #ef4444, #dc2626);
      color: white;
      font-size: 10px;
      font-weight: 700;
      padding: 3px 7px;
      border-radius: 10px;
      box-shadow: 0 2px 8px rgba(239,68,68,0.4);
      /* Pulse animation removed for performance */
    }
    
    /* Pulse animation removed for performance */
    
    /* Forum Modal */
    .forum-modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.8);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 10000;
      padding: 20px;
      animation: fadeIn 0.3s ease;
    }
    
    .forum-modal.active {
      display: flex;
    }
    
    .forum-container {
      background: linear-gradient(145deg, #0f172a 0%, #1e293b 100%);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border: 1px solid rgba(148, 163, 184, 0.1);
      border-radius: 20px;
      box-shadow: 
        0 20px 60px rgba(0, 0, 0, 0.5),
        0 0 0 1px rgba(255, 255, 255, 0.05) inset;
      width: 100%;
      max-width: 1000px;
      max-height: 88vh;
      display: flex;
      flex-direction: column;
      animation: slideUp 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      overflow: hidden;
    }
    
    @keyframes slideUp {
      from {
        opacity: 0;
        transform: translateY(30px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    
    .forum-header {
      padding: 20px 28px;
      border-bottom: 1px solid rgba(148, 163, 184, 0.12);
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: linear-gradient(135deg, rgba(99, 102, 241, 0.08), rgba(139, 92, 246, 0.05));
      position: relative;
    }
    
    .forum-header::before {
      content: '';
      position: absolute;
      bottom: 0;
      left: 28px;
      right: 28px;
      height: 2px;
      background: linear-gradient(90deg, 
        transparent, 
        rgba(99, 102, 241, 0.6) 20%, 
        rgba(99, 102, 241, 0.6) 80%, 
        transparent);
    }
    
    .forum-header h2 {
      color: #f1f5f9;
      font-size: 20px;
      font-weight: 700;
      display: flex;
      align-items: center;
      gap: 10px;
      margin: 0;
      letter-spacing: -0.02em;
    }
    
    .close-forum-btn {
      background: rgba(239, 68, 68, 0.1);
      border: 1px solid rgba(239, 68, 68, 0.2);
      color: #f87171;
      width: 32px;
      height: 32px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 18px;
      transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 300;
    }
    
    .close-forum-btn:hover {
      background: rgba(239, 68, 68, 0.2);
      border-color: rgba(239, 68, 68, 0.4);
      transform: rotate(90deg) scale(1.1);
      box-shadow: 0 4px 12px rgba(239, 68, 68, 0.25);
    }
    
    /* ==========================================================================
       MODAL COMPONENTS
       ========================================================================== */
    
    /* Game Modal */
    
    /* Profile Modal */
    .profile-modal {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      margin: 0;
      padding: 0;
      max-width: 650px;
      width: 92vw;
      background: transparent;
      border: none;
      z-index: 999999999;
      animation: fadeIn 0.3s ease;
    }
    
    .profile-modal::backdrop {
      background: rgba(10, 15, 30, 0.85);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
    }
    
    .profile-modal[open] {
      display: block;
    }
    
    .profile-modal-container {
      background: linear-gradient(145deg, rgba(15, 23, 42, 0.95), rgba(30, 41, 80, 0.92));
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border: 1px solid rgba(156, 220, 254, 0.25);
      border-radius: 28px;
      box-shadow: 
        0 30px 90px rgba(0, 0, 0, 0.5),
        0 0 80px rgba(102, 126, 234, 0.15),
        inset 0 1px 0 rgba(255, 255, 255, 0.1);
      display: flex;
      flex-direction: column;
      animation: profileSlideUp 0.4s cubic-bezier(0.16, 1, 0.3, 1);
      overflow: hidden;
      position: relative;
    }
    
    @keyframes profileSlideUp {
      from {
        opacity: 0;
        transform: translateY(40px) scale(0.95);
      }
      to {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }
    
    .profile-modal-header {
      padding: 32px 36px 28px 36px;
      border-bottom: 1px solid rgba(156, 220, 254, 0.15);
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: linear-gradient(135deg, rgba(102,126,234,0.12), rgba(118,75,162,0.08));
      position: relative;
    }
    
    .profile-modal-header::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 1px;
      background: linear-gradient(90deg, 
        transparent, 
        rgba(156, 220, 254, 0.4), 
        transparent);
    }
    
    .profile-modal-header h2 {
      color: white;
      font-size: 26px;
      font-weight: 700;
      display: flex;
      align-items: center;
      gap: 14px;
      margin: 0;
      letter-spacing: -0.3px;
    }
    
    .close-profile-btn {
      background: rgba(239,68,68,0.12);
      border: 1px solid rgba(239,68,68,0.25);
      color: rgba(255, 255, 255, 0.9);
      width: 42px;
      height: 42px;
      border-radius: 12px;
      cursor: pointer;
      font-size: 26px;
      transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 300;
    }
    
    .close-profile-btn:hover {
      background: rgba(239,68,68,0.22);
      border-color: rgba(239,68,68,0.4);
      transform: rotate(90deg) scale(1.08);
      box-shadow: 0 4px 16px rgba(239,68,68,0.25);
    }
    
    .close-profile-btn:active {
      transform: rotate(90deg) scale(0.95);
    }
    
    .profile-modal-content {
      padding: 36px;
      overflow-y: auto;
      max-height: 65vh;
    }
    
    .profile-modal-content::-webkit-scrollbar {
      width: 8px;
    }
    
    .profile-modal-content::-webkit-scrollbar-track {
      background: rgba(0, 0, 0, 0.2);
      border-radius: 10px;
      margin: 8px 0;
    }
    
    .profile-modal-content::-webkit-scrollbar-thumb {
      background: linear-gradient(180deg, rgba(102,126,234,0.5), rgba(118,75,162,0.5));
      border-radius: 10px;
      border: 2px solid transparent;
      background-clip: padding-box;
    }
    
    .profile-modal-content::-webkit-scrollbar-thumb:hover {
      background: linear-gradient(180deg, rgba(102,126,234,0.7), rgba(118,75,162,0.7));
      background-clip: padding-box;
    }
    
    .profile-modal-section {
      display: flex;
      flex-direction: column;
      gap: 14px;
    }
    
    .profile-modal-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 24px;
      padding: 20px 24px;
      background: linear-gradient(135deg, rgba(255,255,255,0.04), rgba(255,255,255,0.02));
      border-radius: 16px;
      border: 1px solid rgba(156, 220, 254, 0.1);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      position: relative;
      overflow: hidden;
    }
    
    .profile-modal-row::before {
      content: '';
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 3px;
      background: linear-gradient(180deg, rgba(102,126,234,0.6), rgba(118,75,162,0.6));
      opacity: 0;
      transition: opacity 0.3s ease;
    }
    
    .profile-modal-row:hover {
      background: linear-gradient(135deg, rgba(102,126,234,0.08), rgba(118,75,162,0.05));
      border-color: rgba(156, 220, 254, 0.25);
      transform: translateX(4px);
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
    }
    
    .profile-modal-row:hover::before {
      opacity: 1;
    }
    
    .profile-modal-label {
      color: rgba(156, 220, 254, 0.8);
      font-weight: 600;
      font-size: 13px;
      text-transform: uppercase;
      letter-spacing: 0.8px;
      min-width: 150px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .profile-modal-value {
      color: rgba(255, 255, 255, 0.95);
      font-weight: 500;
      font-size: 16px;
      text-align: right;
      flex: 1;
      word-break: break-word;
      line-height: 1.5;
    }
    
    .game-modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.9);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 10001;
      padding: 20px;
      animation: fadeIn 0.3s ease;
    }
    
    .game-modal.active {
      display: flex;
    }
    
    .game-modal-container {
      background: linear-gradient(145deg, rgba(15, 23, 42, 0.98), rgba(30, 41, 80, 0.95));
      backdrop-filter: blur(var(--modal-blur));
      -webkit-backdrop-filter: blur(var(--modal-blur));
      border: 1px solid rgba(147,51,234,0.3);
      border-radius: 24px;
      box-shadow: 0 25px 80px rgba(13, 16, 35, 0.9),
                  0 0 60px rgba(147,51,234,0.3);
      width: 95vw;
      height: 90vh;
      height: 90dvh;
      max-width: 1400px;
      max-height: 90vh;
      max-height: 90dvh;
      display: flex;
      flex-direction: column;
      animation: slideUp 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      overflow: hidden;
    }
    
    .game-modal-header {
      padding: 20px 30px;
      border-bottom: 1px solid rgba(147,51,234,0.2);
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: linear-gradient(135deg, rgba(147,51,234,0.1), rgba(168,85,247,0.05));
    }
    
    .game-modal-header h2 {
      color: white;
      font-size: 24px;
      font-weight: 700;
      display: flex;
      align-items: center;
      gap: 12px;
      margin: 0;
    }
    
    .close-game-btn {
      background: rgba(239,68,68,0.15);
      border: 1px solid rgba(239,68,68,0.3);
      color: white;
      width: 40px;
      height: 40px;
      border-radius: 10px;
      cursor: pointer;
      font-size: 24px;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .close-game-btn:hover {
      background: rgba(239,68,68,0.25);
      transform: rotate(90deg) scale(1.1);
    }
    
    .game-modal-content {
      flex: 1;
      position: relative;
      overflow: hidden;
    }
    
    .game-modal-content iframe {
      width: 100%;
      height: 100%;
      border: none;
      background: white;
    }
    
    .forum-messages {
      flex: 1;
      overflow-y: auto;
      padding: 24px 28px 16px 28px;
      display: flex;
      flex-direction: column;
      gap: 16px;
      background: linear-gradient(180deg, rgba(15, 23, 42, 0.3) 0%, rgba(15, 23, 42, 0) 20%);
    }
    
    .forum-messages::-webkit-scrollbar {
      width: 8px;
    }
    
    .forum-messages::-webkit-scrollbar-track {
      background: rgba(15, 23, 42, 0.3);
      border-radius: 10px;
      margin: 8px 0;
    }
    
    .forum-messages::-webkit-scrollbar-thumb {
      background: linear-gradient(180deg, rgba(99, 102, 241, 0.5), rgba(139, 92, 246, 0.5));
      border-radius: 10px;
      border: 2px solid rgba(15, 23, 42, 0.3);
    }
    
    .forum-messages::-webkit-scrollbar-thumb:hover {
      background: linear-gradient(180deg, rgba(99, 102, 241, 0.7), rgba(139, 92, 246, 0.7));
    }
    
    .forum-message {
      background: linear-gradient(135deg, rgba(30, 41, 59, 0.6), rgba(15, 23, 42, 0.8));
      border: 1px solid rgba(148, 163, 184, 0.1);
      border-radius: 12px;
      padding: 18px 20px;
      animation: slideInLeft 0.3s ease backwards;
      position: relative;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    .forum-message:hover {
      border-color: rgba(148, 163, 184, 0.2);
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
      transform: translateY(-1px);
    }

    /* New message highlighting */
    .forum-message.new-message {
      background: linear-gradient(135deg, rgba(99, 102, 241, 0.12), rgba(139, 92, 246, 0.08));
      border: 1px solid rgba(99, 102, 241, 0.3);
      box-shadow: 0 0 0 1px rgba(99, 102, 241, 0.2) inset, 0 8px 24px rgba(99, 102, 241, 0.15);
      animation: newMessagePulse 2s ease-in-out 3;
    }

    @keyframes newMessagePulse {
      0%, 100% {
        box-shadow: 0 0 0 1px rgba(99, 102, 241, 0.2) inset, 0 8px 24px rgba(99, 102, 241, 0.15);
        border-color: rgba(99, 102, 241, 0.3);
      }
      50% {
        box-shadow: 0 0 0 1px rgba(99, 102, 241, 0.4) inset, 0 8px 32px rgba(99, 102, 241, 0.25);
        border-color: rgba(99, 102, 241, 0.5);
      }
    }

    /* New message tag/badge */
    .new-message-tag {
      position: absolute;
      top: 14px;
      right: 16px;
      background: linear-gradient(135deg, #6366f1, #8b5cf6);
      color: #ffffff;
      padding: 4px 10px;
      border-radius: 6px;
      font-size: 10px;
      font-weight: 700;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      box-shadow: 0 2px 8px rgba(99, 102, 241, 0.4);
      animation: tagPulse 2s ease-in-out 5;
      flex: 0 0 auto;
      scroll-snap-align: start;
      touch-action: manipulation;
      z-index: 10;

    .section-tabs::-webkit-scrollbar {
      display: none;
    }

    @media (max-width: 768px) {
      .section-tabs {
        flex-wrap: nowrap;
      }
      .section-tab {
        white-space: nowrap;
      }
    }
    }

    @keyframes tagPulse {
      0%, 100% {
        transform: scale(1);
        opacity: 1;
      }
      50% {
        transform: scale(1.05);
        opacity: 0.9;
      }
    }
    
    .message-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
      gap: 12px;
    }
    
    .message-author {
      color: #60a5fa;
      font-weight: 600;
      font-size: 14px;
      letter-spacing: -0.01em;
    }
    
    .message-time {
      color: rgba(203, 213, 225, 0.6);
      font-size: 11px;
      font-weight: 500;
      white-space: nowrap;
    }
    
    .message-text {
      color: rgba(241, 245, 249, 0.95);
      line-height: 1.6;
      font-size: 14px;
      margin-bottom: 12px;
      word-wrap: break-word;
    }
    
    .message-replies {
      margin-top: 14px;
      padding-left: 18px;
      border-left: 2px solid rgba(99, 102, 241, 0.3);
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    
    .message-reply {
      background: rgba(30, 41, 59, 0.4);
      border: 1px solid rgba(148, 163, 184, 0.08);
      border-radius: 10px;
      padding: 12px 14px;
      transition: all 0.2s ease;
    }
    
    .message-reply:hover {
      background: rgba(30, 41, 59, 0.6);
      border-color: rgba(148, 163, 184, 0.15);
    }
    
    .reply-btn {
      background: rgba(99, 102, 241, 0.08);
      border: 1px solid rgba(99, 102, 241, 0.25);
      color: #818cf8;
      padding: 6px 14px;
      border-radius: 6px;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    .reply-btn:hover {
      background: rgba(99, 102, 241, 0.15);
      border-color: rgba(99, 102, 241, 0.4);
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(99, 102, 241, 0.2);
    }
    
    .delete-message-btn {
      background: rgba(239, 68, 68, 0.08);
      border: 1px solid rgba(239, 68, 68, 0.25);
      color: #f87171;
      padding: 4px 10px;
      border-radius: 6px;
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      line-height: 1;
    }
    
    .delete-message-btn:hover {
      background: rgba(239, 68, 68, 0.15);
      border-color: rgba(239, 68, 68, 0.4);
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(239, 68, 68, 0.2);
    }
    
    .reply-input-container {
      display: none;
      margin-top: 12px;
      gap: 8px;
    }
    
    .reply-input-container.active {
      display: flex;
    }
    
    .reply-input {
      flex: 1;
      background: rgba(30, 41, 59, 0.5);
      border: 1px solid rgba(148, 163, 184, 0.15);
      color: #f1f5f9;
      padding: 10px 14px;
      border-radius: 8px;
      font-size: 13px;
      transition: all 0.2s ease;
      font-family: inherit;
    }
    
    .reply-input:focus {
      outline: none;
      background: rgba(30, 41, 59, 0.7);
      border-color: rgba(99, 102, 241, 0.5);
      box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
    }
    
    .reply-input::placeholder {
      color: rgba(203, 213, 225, 0.4);
    }
    
    .send-reply-btn {
      background: linear-gradient(135deg, #6366f1, #8b5cf6);
      border: none;
      color: white;
      padding: 10px 16px;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 600;
      font-size: 13px;
      transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 0 4px 12px rgba(99, 102, 241, 0.25);
    }
    
    .send-reply-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 16px rgba(99, 102, 241, 0.35);
    }
    
    .send-reply-btn:active {
      transform: translateY(0);
    }
    
    .forum-input-area {
      padding: 18px 24px 22px 24px;
      border-top: 1px solid rgba(148, 163, 184, 0.12);
      background: linear-gradient(180deg, rgba(15, 23, 42, 0.5), rgba(30, 41, 59, 0.3));
      display: flex;
      gap: 10px;
      align-items: flex-end;
    }
    
    .forum-input {
      flex: 1;
      background: rgba(30, 41, 59, 0.6);
      border: 1px solid rgba(148, 163, 184, 0.15);
      color: #f1f5f9;
      padding: 12px 16px;
      border-radius: 10px;
      font-size: 14px;
      line-height: 1.5;
      transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      resize: none;
      font-family: inherit;
      min-height: 44px;
      max-height: 120px;
    }
    
    .forum-input:focus {
      outline: none;
      background: rgba(30, 41, 59, 0.8);
      border-color: rgba(99, 102, 241, 0.5);
      box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1), 0 4px 12px rgba(0, 0, 0, 0.15);
    }
    
    .forum-input::placeholder {
      color: rgba(203, 213, 225, 0.4);
    }
    
    .attach-file-btn {
      background: rgba(99, 102, 241, 0.08);
      border: 1px solid rgba(99, 102, 241, 0.2);
      color: #818cf8;
      padding: 12px;
      border-radius: 10px;
      cursor: pointer;
      font-size: 18px;
      transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      display: flex;
      align-items: center;
      justify-content: center;
      min-width: 44px;
      height: 44px;
    }
    
    .attach-file-btn:hover {
      background: rgba(99, 102, 241, 0.15);
      border-color: rgba(99, 102, 241, 0.4);
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(99, 102, 241, 0.25);
    }
    
    .attach-file-btn:active {
      transform: translateY(0);
    }
    
    .send-message-btn {
      background: linear-gradient(135deg, #6366f1, #8b5cf6);
      border: none;
      color: white;
      padding: 12px 24px;
      border-radius: 10px;
      cursor: pointer;
      font-weight: 600;
      font-size: 14px;
      height: 44px;
      transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 0 4px 12px rgba(99, 102, 241, 0.3);
      display: flex;
      align-items: center;
      gap: 6px;
    }
    
    .send-message-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 18px rgba(99, 102, 241, 0.4);
      background: linear-gradient(135deg, #7c3aed, #a855f7);
    }
    
    .send-message-btn:active {
      transform: translateY(0);
    }
    
    .content {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 24px;
      margin-bottom: 24px;
    }
    
    .full-width-card {
      grid-column: 1 / -1;
    }
    
    .classroom-item {
      padding: 32px 36px;
      background: linear-gradient(135deg, 
        rgba(17, 24, 39, 0.95) 0%, 
        rgba(31, 41, 55, 0.9) 50%,
        rgba(17, 24, 39, 0.95) 100%);
      backdrop-filter: blur(24px) saturate(180%);
      -webkit-backdrop-filter: blur(24px) saturate(180%);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 24px;
      transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      margin-bottom: 20px;
      animation: slideInLeft 0.5s ease-out backwards;
      position: relative;
      overflow: hidden;
      will-change: transform;
      display: flex;
      flex-direction: column;
      min-height: 220px;
      box-shadow: 
        0 10px 40px rgba(0, 0, 0, 0.4),
        0 4px 12px rgba(0, 0, 0, 0.2),
        inset 0 1px 0 rgba(255, 255, 255, 0.08),
        inset 0 -1px 0 rgba(0, 0, 0, 0.2);
      z-index: 1;
    }
    
    /* Futuristic neon accent bar with glow effect */
    .classroom-item::before {
      content: '';
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 5px;
      background: linear-gradient(180deg, 
        rgba(99, 102, 241, 1) 0%, 
        rgba(139, 92, 246, 0.9) 50%,
        rgba(167, 139, 250, 0.8) 100%);
      box-shadow: 
        0 0 20px rgba(99, 102, 241, 0.6),
        0 0 40px rgba(139, 92, 246, 0.3);
      transition: all 0.3s ease;
      border-radius: 0 4px 4px 0;
    }
    
    /* Remove the circle hover effect */
    .classroom-item::after {
      display: none;
    }
    
    .classroom-item:hover {
      background: linear-gradient(135deg, 
        rgba(17, 24, 39, 1) 0%, 
        rgba(31, 41, 55, 0.95) 50%,
        rgba(17, 24, 39, 1) 100%);
      transform: translateY(-6px) scale(1.02);
      box-shadow: 
        0 20px 60px rgba(0, 0, 0, 0.5),
        0 8px 20px rgba(139, 92, 246, 0.25),
        inset 0 1px 0 rgba(255, 255, 255, 0.12),
        inset 0 -1px 0 rgba(0, 0, 0, 0.3),
        0 0 0 1px rgba(139, 92, 246, 0.2);
      border-color: rgba(139, 92, 246, 0.3);
      z-index: 99999999;
    }
    
    .classroom-item:hover::before {
      width: 7px;
      box-shadow: 
        0 0 30px rgba(99, 102, 241, 0.8),
        0 0 60px rgba(139, 92, 246, 0.5),
        0 0 90px rgba(167, 139, 250, 0.3);
    }
    
    /* Fixed content area with scrolling if needed */
    .note-content-area {
      flex: 1;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }
    
    /* Fixed footer area - always at bottom */
    .note-footer-area {
      margin-top: auto;
      padding-top: 4px;
    }
    
    /* Fixed badge position - centered */
    .note-badge-container {
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 8px;
    }
    
    /* Collapsed state - fixed height */
    .classroom-item.note-collapsed {
      min-height: 220px;
      max-height: 220px;
    }
    
    /* Expanded state - allow growth */
    .classroom-item.note-expanded {
      min-height: 220px;
      max-height: none;
    }
    
    /* Expand indicator animation */
    .note-expand-indicator {
      transition: all 0.3s ease;
      cursor: pointer;
      user-select: none;
    }
    
    .classroom-item:hover .note-expand-indicator {
      color: rgba(102,126,234,0.8);
    }
    
    /* Announcement type - golden neon accent with glow */
    .classroom-item.announcement::before {
      background: linear-gradient(180deg, 
        rgba(251, 191, 36, 1) 0%, 
        rgba(245, 158, 11, 0.9) 50%,
        rgba(217, 119, 6, 0.8) 100%);
      box-shadow: 
        0 0 20px rgba(251, 191, 36, 0.6),
        0 0 40px rgba(245, 158, 11, 0.3);
    }
    
    .classroom-item.announcement:hover::before {
      box-shadow: 
        0 0 30px rgba(251, 191, 36, 0.8),
        0 0 60px rgba(245, 158, 11, 0.5),
        0 0 90px rgba(217, 119, 6, 0.3);
    }

    .classroom-item.announcement:hover {
      border-color: rgba(251, 191, 36, 0.3);
      box-shadow: 
        0 20px 60px rgba(0, 0, 0, 0.5),
        0 8px 20px rgba(251, 191, 36, 0.25),
        inset 0 1px 0 rgba(255, 255, 255, 0.12),
        inset 0 -1px 0 rgba(0, 0, 0, 0.3),
        0 0 0 1px rgba(251, 191, 36, 0.2);
      z-index: 99999999;
    }
    
    /* Material type - green neon accent with glow */
    .classroom-item.material::before {
      background: linear-gradient(180deg, 
        rgba(34, 197, 94, 1) 0%, 
        rgba(22, 163, 74, 0.9) 50%,
        rgba(21, 128, 61, 0.8) 100%);
      box-shadow: 
        0 0 20px rgba(34, 197, 94, 0.6),
        0 0 40px rgba(22, 163, 74, 0.3);
    }
    
    .classroom-item.material:hover::before {
      box-shadow: 
        0 0 30px rgba(34, 197, 94, 0.8),
        0 0 60px rgba(22, 163, 74, 0.5),
        0 0 90px rgba(21, 128, 61, 0.3);
    }

    .classroom-item.material:hover {
      border-color: rgba(34, 197, 94, 0.3);
      box-shadow: 
        0 20px 60px rgba(0, 0, 0, 0.5),
        0 8px 20px rgba(34, 197, 94, 0.25),
        inset 0 1px 0 rgba(255, 255, 255, 0.12),
        inset 0 -1px 0 rgba(0, 0, 0, 0.3),
        0 0 0 1px rgba(34, 197, 94, 0.2);
      z-index: 99999999;
    }
    
    /* Locked notes - futuristic muted style with subtle glow */
    .classroom-item.locked {
      border: 1px solid rgba(148, 163, 184, 0.2);
      background: linear-gradient(135deg, 
        rgba(30, 41, 59, 0.85) 0%, 
        rgba(51, 65, 85, 0.75) 50%,
        rgba(30, 41, 59, 0.85) 100%);
      position: relative;
    }
    
    .classroom-item.locked::before {
      background: linear-gradient(180deg, 
        rgba(148, 163, 184, 0.7) 0%, 
        rgba(100, 116, 139, 0.6) 50%,
        rgba(71, 85, 105, 0.5) 100%);
      box-shadow: 
        0 0 15px rgba(148, 163, 184, 0.3),
        0 0 30px rgba(100, 116, 139, 0.2);
    }

    /* Modern lock icon centered for locked notes */
    .classroom-item.locked::after {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 120px;
      height: 120px;
      opacity: 0.6;
      pointer-events: none;
      z-index: 999999;
      background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="rgba(255,255,255,1)" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="11" width="18" height="11" rx="3" ry="3"/><path d="M7 11V7a5 5 0 0 1 10 0v4"/></svg>');
      background-size: contain;
      background-repeat: no-repeat;
      background-position: center;
      filter: drop-shadow(0 4px 24px rgba(255, 255, 255, 0.4));
      transition: all 0.3s ease;
    }

    .classroom-item.locked:hover::after {
      opacity: 0.75;
      transform: translate(-50%, -50%) scale(1.1);
      filter: drop-shadow(0 6px 32px rgba(255, 255, 255, 0.6));
    }

    /* Blur ONLY the badge on locked notes - keep title and date visible */
    .classroom-item.locked .classroom-badge {
      filter: blur(8px);
    }
    
    .classroom-item.locked .note-content-area {
      /* Keep content area unblurred so title/date stay sharp */
      filter: none;
    }
    
    /* Don't blur the lock icon overlay */
    .classroom-item.locked::after {
      filter: drop-shadow(0 4px 24px rgba(255, 255, 255, 0.4)) !important;
    }
    
    .classroom-item.locked:hover {
      border-color: rgba(148, 163, 184, 0.3);
      transform: translateY(-3px) scale(1.01);
      box-shadow: 
        0 12px 36px rgba(0, 0, 0, 0.4),
        0 4px 12px rgba(148, 163, 184, 0.15),
        inset 0 1px 0 rgba(255, 255, 255, 0.08);
      z-index: 99999999;
    }

    .classroom-item.locked:hover::before {
      box-shadow: 
        0 0 20px rgba(148, 163, 184, 0.4),
        0 0 40px rgba(100, 116, 139, 0.3);
    }

    .locked-attachment-card {
      position: relative;
      cursor: not-allowed;
      transition: transform 0.25s ease, box-shadow 0.25s ease, border-color 0.25s ease, background 0.25s ease;
      isolation: isolate;
      overflow: visible !important;
    }

    .locked-attachment-card::after {
      content: 'Please make your payment to see the notes';
      position: absolute;
      left: 50%;
      bottom: -56px;
      transform: translate(-50%, 10px);
      background: rgba(239,68,68,0.95);
      color: white;
      padding: 10px 14px;
      border-radius: 999px;
      font-size: 12px;
      font-weight: 600;
      letter-spacing: 0.02em;
      box-shadow: 0 12px 30px rgba(239,68,68,0.4);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s ease, transform 0.2s ease;
      max-width: 240px;
      text-align: center;
      white-space: normal;
      line-height: 1.3;
      z-index: 5;
    }

    .locked-attachment-card:hover {
      background: linear-gradient(145deg, rgba(239,68,68,0.25), rgba(239,68,68,0.08)) !important;
      border-color: rgba(239,68,68,0.6) !important;
      box-shadow: 0 12px 28px rgba(239,68,68,0.45);
      transform: translateY(-4px);
    }

    .locked-attachment-card:hover::after {
      opacity: 1;
      transform: translate(-50%, -6px);
    }
    
    .classroom-text.blurred {
      filter: blur(12px);
      user-select: none;
      pointer-events: none;
      opacity: 0.4;
    }
    
    .classroom-badge.locked {
      background: rgba(148,163,184,0.2);
      color: #94a3b8;
    }
    
    .classroom-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 10px;
      gap: 12px;
      width: 100%;
    }
    
    .classroom-title {
      font-weight: 700;
      color: #ffffff;
      font-size: 18px;
      margin-bottom: 6px;
      letter-spacing: -0.02em;
      text-shadow: 0 2px 8px rgba(0,0,0,0.3);
      line-height: 1.3;
      word-wrap: break-word;
      overflow-wrap: break-word;
      white-space: normal;
      max-width: 100%;
      flex: 1;
      min-width: 0;
    }
    
    .classroom-course {
      font-size: 11px;
      color: rgba(255,255,255,0.75);
      font-weight: 600;
      letter-spacing: 0.01em;
      text-transform: uppercase;
    }
    
    .classroom-date {
      font-size: 12px;
      color: rgba(255,255,255,0.7);
      white-space: nowrap;
      font-weight: 600;
      letter-spacing: 0.02em;
      flex-shrink: 0;
      margin-left: 12px;
    }
    
    .classroom-text {
      color: rgba(255,255,255,0.85);
      font-size: 14px;
      line-height: 1.6;
      margin-top: 12px;
      font-weight: 400;
    }
    
    .classroom-badge {
      display: inline-block;
      padding: 6px 14px;
      border-radius: 16px;
      font-size: 11px;
      font-weight: 700;
      margin-top: 12px;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
    }
    
    .classroom-badge.announcement {
      background: linear-gradient(135deg, rgba(251,191,36,0.25) 0%, rgba(245,158,11,0.2) 100%);
      color: #fbbf24;
      border: 1px solid rgba(251,191,36,0.3);
      box-shadow: 0 0 15px rgba(251,191,36,0.2);
    }
    
    .classroom-badge.material {
      background: linear-gradient(135deg, rgba(34,197,94,0.25) 0%, rgba(22,163,74,0.2) 100%);
      color: #34a853;
      border: 1px solid rgba(34,197,94,0.3);
      box-shadow: 0 0 15px rgba(34,197,94,0.2);
    }
    
    .classroom-badge.free-access {
      background: linear-gradient(135deg, rgba(34,197,94,0.3) 0%, rgba(16,185,129,0.25) 100%);
      color: #10b981;
      border: 1px solid rgba(16,185,129,0.4);
      box-shadow: 0 0 18px rgba(16,185,129,0.3);
    }
    
    .classroom-list {
      max-height: 560px;
      overflow-y: auto;
      padding: 4px;
      -webkit-overflow-scrolling: touch;
    }
    
    /* Notes Grid System */
    .notes-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 20px;
      padding: 0 4px;
    }
    
    .notes-system-container {
      margin-bottom: 32px;
      animation: fadeIn 0.4s ease;
    }
    
    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    
    /* Responsive: 2 columns on tablets */
    @media (max-width: 1200px) {
      .notes-grid {
        grid-template-columns: repeat(2, 1fr);
      }
    }
    
    /* Responsive: 1 column on mobile */
    @media (max-width: 768px) {
      .notes-grid {
        grid-template-columns: 1fr;
      }
    }
    
    .classroom-list::-webkit-scrollbar {
      width: 8px;
    }
    
    .classroom-list::-webkit-scrollbar-track {
      background: rgba(255,255,255,0.05);
      border-radius: 4px;
    }
    
    .classroom-list::-webkit-scrollbar-thumb {
      background: rgba(255,255,255,0.2);
      border-radius: 4px;
    }
    
    .classroom-list::-webkit-scrollbar-thumb:hover {
      background: rgba(255,255,255,0.3);
    }
    
    /* Systems Progress Carousel */
    .systems-carousel-container {
      position: relative;
      padding: 24px 56px;
      margin: 24px 0;
      /* FIX: Establish stacking context for z-index */
      z-index: 1;
      isolation: isolate;
    }
    
    .systems-carousel {
      display: flex;
      gap: 20px;
      overflow-x: auto;
      scroll-behavior: smooth;
      padding: 40px 8px; /* Increased padding for glow visibility */
      scrollbar-width: none;
      -ms-overflow-style: none;
      /* FIX: Allow cards to lift above carousel */
      transform-style: preserve-3d;
      /* Start visible to show loading spinner, will be controlled by data-ready */
      opacity: 1;
      visibility: visible;
      transition: opacity 0.3s ease-in-out, visibility 0s 0s;
      -webkit-overflow-scrolling: touch;
      scroll-snap-type: x proximity;
    }
    
    /* Hide carousel content (not spinner) when not ready */
    .systems-carousel[data-ready="false"] .system-card {
      opacity: 0;
      visibility: hidden;
    }
    
    .systems-carousel[data-ready="true"] {
      opacity: 1;
      visibility: visible;
      transition: opacity 0.3s ease-in-out, visibility 0s 0s;
    }
    
    /* Remove old loading classes - not needed anymore */
    .systems-carousel.carousel-loading {
      /* No longer used */
    }
    
    .systems-carousel.loaded {
      /* No longer used */
    }
    
    .systems-carousel::-webkit-scrollbar {
      display: none;
    }
    
    .system-card {
      --glass-bg: rgba(15, 23, 42, 0.7);
      width: 220px; /* Fixed width instead of min-width */
      height: 280px;
      scroll-snap-align: start;
      background: linear-gradient(145deg, rgba(15, 23, 42, 0.85), rgba(30, 41, 80, 0.75));
      border-radius: 24px;
      padding: 28px 24px;
      position: relative;
      overflow: hidden;
      cursor: pointer;
      border: 1.5px solid rgba(255,255,255,0.15);
      flex-shrink: 0;
      will-change: transform;
      box-shadow: 0 12px 48px rgba(15, 27, 71, 0.3),
                  inset 0 1px 0 rgba(255,255,255,0.08);
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      z-index: 1;
    }
    
    .system-card::before {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(135deg, rgba(255,255,255,0.15) 0%, transparent 60%);
      opacity: 0.5;
      pointer-events: none;
      border-radius: 24px;
    }
    
    .system-card::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 6px;
      background: linear-gradient(90deg, var(--status-color), transparent 70%);
      opacity: 0.9;
      border-radius: 24px 24px 0 0;
    }
    
    .system-card:hover {
      transform: translateY(-6px) scale(1.02);
      box-shadow: 0 24px 64px rgba(15, 27, 71, 0.4),
                  inset 0 1px 0 rgba(255,255,255,0.12);
      border-color: rgba(255,255,255,0.3);
      /* FIX: Ensure hover card is above others */
      z-index: 5;
    }
    
    .system-card:active {
      transform: translateY(-2px) scale(1.01);
      box-shadow: 0 12px 32px rgba(15, 27, 71, 0.3);
      z-index: 5;
    }
    
    .system-card.completed {
      --status-color: #34a853;
      background: linear-gradient(135deg, rgba(52,168,83,0.15), rgba(52,168,83,0.05));
      border-color: rgba(52,168,83,0.4);
    }
    
    .system-card.current {
      --status-color: #fbbc04;
      background: linear-gradient(135deg, rgba(251,188,4,0.28), rgba(251,188,4,0.12));
      border-color: rgba(251,188,4,0.6);
      border-width: 2px;
      /* Bigger than other cards */
      width: 260px;
      height: 320px;
      transform: scale(1.05);
      z-index: 9999999 !important;
      position: relative;
      /* Smooth even glow all around - no hard edges */
      box-shadow: 
                  0 0 30px 12px rgba(251,188,4,0.30),
                  0 0 50px 20px rgba(251,188,4,0.15),
                  0 8px 40px rgba(251,188,4,0.25),
                  inset 0 2px 0 rgba(255,255,255,0.3),
                  inset 0 -1px 0 rgba(0,0,0,0.1);
      will-change: transform, box-shadow;
    }
    
    .system-card.current::before {
      opacity: 1;
      background: linear-gradient(135deg, rgba(255,255,255,0.25) 0%, transparent 65%);
    }
    
    .system-card.current .system-icon {
      width: 70px; /* Slightly larger than base (64px) */
      height: 70px;
      font-size: 38px; /* Slightly larger than base (36px) */
      background: rgba(251,188,4,0.25);
      border-color: rgba(251,188,4,0.5);
      box-shadow: 0 8px 24px rgba(251,188,4,0.3);
    }
    
    .system-card.current .system-name {
      font-size: 17px; /* Slightly larger than base (15px) */
      font-weight: 700;
      letter-spacing: 0.3px;
    }
    
    .system-card.current .system-progress {
      font-size: 15px; /* Slightly larger than base (13px) */
      font-weight: 700;
    }
    
    .system-card.current:hover {
      transform: scale(1.08) translateY(-8px);
      /* Enhanced smooth glow on hover - still even all around */
      box-shadow: 
                  0 0 40px 15px rgba(251,188,4,0.35),
                  0 0 65px 25px rgba(251,188,4,0.20),
                  0 12px 50px rgba(251,188,4,0.30),
                  inset 0 2px 0 rgba(255,255,255,0.35),
                  inset 0 -1px 0 rgba(0,0,0,0.12);
      z-index: 99999999 !important;
    }
    
    .system-card.current:active {
      transform: scale(1.03) translateY(-4px);
      /* Smooth glow on click - consistent radial pattern */
      box-shadow: 
                  0 0 35px 12px rgba(251,188,4,0.32),
                  0 0 55px 20px rgba(251,188,4,0.18),
                  0 10px 45px rgba(251,188,4,0.28),
                  inset 0 2px 0 rgba(255,255,255,0.32),
                  inset 0 -1px 0 rgba(0,0,0,0.1);
      z-index: 150 !important;
    }
    
    .system-card.in-progress {
      --status-color: #3b82f6;
      background: linear-gradient(135deg, rgba(59,130,246,0.22), rgba(59,130,246,0.08));
      border-color: rgba(59,130,246,0.5);
    }
    
    .system-card.not-started {
      --status-color: #ea4335;
      background: linear-gradient(135deg, rgba(234,67,53,0.18), rgba(234,67,53,0.06));
      border-color: rgba(234,67,53,0.45);
      opacity: 0.75;
    }
    
    .system-card.selected {
      border-color: rgba(255,255,255,0.6);
      box-shadow: 0 8px 32px rgba(102,126,234,0.3),
                  0 0 0 2px rgba(102,126,234,0.2);
      /* FIX: Selected cards above normal cards */
      z-index: 8;
    }

    .system-card.selected:not(.current) {
      transform: scale(1.05);
      z-index: 8;
    }

    .system-card.current.selected {
      transform: scale(1.08);
      /* FIX: Selected current card is highest */
      z-index: 18;
    }
    
    /* Futuristic Notification Badge - Moves with progress */
    .system-notification {
      position: absolute;
      top: 12px;
      /* Position dynamically via inline style based on progress % */
      width: 32px;
      height: 32px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
      animation: scaleIn 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
      transition: left 0.8s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    .system-notification.unlocked {
      background: linear-gradient(135deg, #34a853, #0f9d58);
      box-shadow: 0 4px 20px rgba(52,168,83,0.6),
                  0 0 0 3px rgba(52,168,83,0.3),
                  inset 0 1px 0 rgba(255,255,255,0.4);
    }
    
    .system-notification.locked {
      background: linear-gradient(135deg, #ea4335, #c5221f);
      box-shadow: 0 4px 20px rgba(234,67,53,0.6),
                  0 0 0 3px rgba(234,67,53,0.3),
                  inset 0 1px 0 rgba(255,255,255,0.4);
    }
    
    .notification-count {
      font-size: 13px;
      font-weight: 800;
      color: white;
      text-shadow: 0 1px 3px rgba(0,0,0,0.3);
      position: relative;
      z-index: 2;
    }
    
    .notification-lock {
      font-size: 12px;
      position: absolute;
      bottom: -4px;
      right: -4px;
      background: rgba(0,0,0,0.4);
      border-radius: 50%;
      width: 18px;
      height: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
      border: 2px solid rgba(255,255,255,0.3);
    }
    
    .notification-pulse {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      border-radius: 50%;
      background: inherit;
      /* Pulse animation removed for performance */
      opacity: 0.7;
    }
    
    /* Notification pulse animation removed for performance */
    
    .system-icon {
      width: 68px;
      height: 68px;
      border-radius: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 36px;
      margin-bottom: 18px;
      background: linear-gradient(135deg, rgba(255,255,255,0.15), rgba(255,255,255,0.08));
      border: 2px solid rgba(255,255,255,0.25);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 0 4px 16px rgba(0,0,0,0.15),
                  inset 0 1px 0 rgba(255,255,255,0.2);
    }
    
    .system-card:hover .system-icon {
      transform: rotate(12deg) scale(1.15);
      background: linear-gradient(135deg, rgba(255,255,255,0.25), rgba(255,255,255,0.12));
      box-shadow: 0 6px 24px rgba(0,0,0,0.2),
                  inset 0 1px 0 rgba(255,255,255,0.3);
    }
    
    .system-name {
      font-size: 15px;
      font-weight: 700;
      color: white;
      margin-bottom: 10px;
      line-height: 1.3;
      text-shadow: 0 2px 6px rgba(0,0,0,0.3);
      letter-spacing: 0.2px;
      /* Wrap long text */
      word-wrap: break-word;
      overflow-wrap: break-word;
      hyphens: auto;
      max-height: 60px; /* ~3 lines max */
      overflow: hidden;
      display: -webkit-box;
      -webkit-line-clamp: 3;
      -webkit-box-orient: vertical;
    }
    
    .system-progress {
      font-size: 14px;
      font-weight: 600;
      color: rgba(255,255,255,0.85);
      margin-bottom: 16px;
      text-shadow: 0 1px 3px rgba(0,0,0,0.2);
    }
    
    .system-bar {
      width: 100%;
      height: 8px;
      background: rgba(0,0,0,0.25);
      border-radius: 12px;
      overflow: hidden;
      position: relative;
      box-shadow: inset 0 2px 4px rgba(0,0,0,0.2);
      margin-top: 16px;
    }
    
    .system-bar::before {
      content: '';
      position: absolute;
      top: -17px;
      left: 0;
      right: 0;
      height: 1px;
      background: radial-gradient(ellipse at center, 
        rgba(255,255,255,0.15) 0%, 
        rgba(255,255,255,0.12) 40%, 
        rgba(255,255,255,0.05) 70%,
        transparent 100%);
      opacity: 0.6;
    }
    
    .system-bar-fill {
      height: 100%;
      width: 0%; /* Default to 0%, will be overridden by inline style */
      background: linear-gradient(90deg, var(--status-color), var(--status-color-light, var(--status-color)));
      border-radius: 12px;
      transition: width 0.8s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 0 0 12px var(--status-color),
                  inset 0 1px 0 rgba(255,255,255,0.3);
      min-width: 0;
    }
    
    .system-status {
      position: absolute;
      bottom: 20px;
      /* Position dynamically via inline style based on progress % */
      padding: 6px 12px;
      border-radius: 8px;
      font-size: 11px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      background: rgba(0,0,0,0.3);
      border: 1px solid var(--status-color);
      color: var(--status-color);
      backdrop-filter: blur(10px);
      box-shadow: 0 2px 8px rgba(0,0,0,0.2),
                  0 0 20px var(--status-color, transparent);
      transition: left 0.8s cubic-bezier(0.4, 0, 0.2, 1);
      transform: translateX(-50%); /* Center on progress point */
    }
    
    .system-card.current .system-status {
      /* Glow animation removed for performance */
      background: rgba(251,188,4,0.2);
    }
    
    .carousel-nav {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      width: 45px;
      height: 45px;
      border-radius: 50%;
      background: rgba(255,255,255,0.15);
      backdrop-filter: blur(10px);
      border: 2px solid rgba(255,255,255,0.3);
      color: white;
      font-size: 28px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s;
      z-index: 10;
      display: flex;
      align-items: center;
      justify-content: center;
      line-height: 1;
    }
    
    .carousel-nav:hover {
      background: rgba(102,126,234,0.3);
      transform: translateY(-50%) scale(1.1);
      box-shadow: 0 4px 20px rgba(102,126,234,0.4);
    }
    
    .carousel-nav.prev {
      left: 0;
    }
    
    .carousel-nav.next {
      right: 0;
    }
    
    /* Carousel Loading Spinner */
    .carousel-loading-spinner {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 320px;
      width: 100%;
      gap: 20px;
    }
    
    .carousel-loading-spinner .spinner {
      font-size: 64px;
      animation: spin 2s ease-in-out infinite;
      filter: drop-shadow(0 0 20px rgba(103,126,234,0.6));
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .carousel-loading-spinner p {
      color: rgba(255,255,255,0.7);
      font-size: 15px;
      font-weight: 500;
      letter-spacing: 0.5px;
    }
    
    @keyframes spin {
      0%, 100% { 
        transform: rotate(0deg) scale(1);
        filter: drop-shadow(0 0 20px rgba(103,126,234,0.6));
      }
      50% { 
        transform: rotate(180deg) scale(1.1);
        filter: drop-shadow(0 0 30px rgba(118,75,162,0.8));
      }
    }
    
    .progress-legend {
      display: flex;
      justify-content: center;
      gap: 32px;
      margin-top: 24px;
      flex-wrap: wrap;
    }
    
    .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 13px;
      color: rgba(255,255,255,0.8);
    }
    
    .legend-dot {
      width: 14px;
      height: 14px;
      border-radius: 50%;
      box-shadow: 0 0 10px currentColor;
    }
    
    .legend-dot.completed {
      background: #34a853;
    }
    
    .legend-dot.current {
      background: #fbbc04;
      /* Pulse animation removed for performance */
    }
    
    .legend-dot.in-progress {
      background: #3b82f6;
    }
    
    .legend-dot.not-started {
      background: #ef4444;
    }
    
    .games-card {
      padding: 24px 28px;
    }

    .games-card .card-title {
      margin-bottom: 16px;
    }

    .games-container {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(380px, 1fr));
      gap: 20px;
    }

    .game-card {
      background: linear-gradient(145deg, rgba(15, 23, 42, 0.85), rgba(30, 41, 80, 0.75));
      border: 1.5px solid rgba(255,255,255,0.15);
      border-radius: 24px;
      padding: 26px 30px;
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      position: relative;
      overflow: hidden;
      display: flex;
      flex-direction: row;
      align-items: center;
      gap: 24px;
      min-height: 0;
      backdrop-filter: blur(var(--panel-blur));
      -webkit-backdrop-filter: blur(var(--panel-blur));
      box-shadow: 0 12px 48px rgba(15, 27, 71, 0.3),
                  inset 0 1px 0 rgba(255,255,255,0.08);
      appearance: none;
      -webkit-appearance: none;
      text-align: left;
      width: 100%;
      color: inherit;
    }
    
    .game-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(135deg, rgba(147,51,234,0.15) 0%, rgba(102,126,234,0.12) 100%);
      opacity: 0;
      transition: opacity 0.4s ease;
      border-radius: 24px;
    }
    
    .game-card:hover::before {
      opacity: 1;
    }
    
    .pharmaquest-card {
      border-color: rgba(147,51,234,0.4);
      background: linear-gradient(145deg, rgba(15, 23, 42, 0.9), rgba(45, 20, 80, 0.7));
    }
    
    .pharmaquest-card::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 6px;
      background: linear-gradient(90deg, rgba(147,51,234,0.8), transparent 70%);
      border-radius: 24px 24px 0 0;
    }
    
    .game-card:hover {
      transform: translateY(-8px) scale(1.02);
      box-shadow: 0 28px 70px rgba(147,51,234,0.35), 
                  0 0 80px rgba(147,51,234,0.25),
                  inset 0 2px 0 rgba(255,255,255,0.15);
      border-color: rgba(147,51,234,0.6);
    }
    
    .coming-soon-card {
      opacity: 0.65;
      cursor: not-allowed;
      border-color: rgba(255,255,255,0.1);
      flex-direction: column;
      align-items: flex-start;
      gap: 16px;
    }
    
    .coming-soon-card:hover {
      transform: none;
      box-shadow: 0 12px 48px rgba(15, 27, 71, 0.3);
      border-color: rgba(255,255,255,0.1);
    }
    
    .game-icon {
      font-size: 56px;
      line-height: 1;
      filter: drop-shadow(0 6px 20px rgba(147,51,234,0.5));
      /* Float animation removed for performance */
      transition: all 0.3s ease;
      flex-shrink: 0;
    }
    
    .game-card:hover .game-icon {
      transform: scale(1.1) rotate(5deg);
      filter: drop-shadow(0 8px 28px rgba(147,51,234,0.7));
    }
    
    /* Float animation removed for performance */
    
    .game-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 10px;
      position: relative;
      z-index: 2;
    }
    
    .game-title {
      color: #ffffff;
      font-size: 22px;
      font-weight: 700;
      margin: 0;
      background: linear-gradient(135deg, #ffffff, #e0e7ff);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      letter-spacing: 0.3px;
      filter: drop-shadow(0 2px 6px rgba(0,0,0,0.3));
    }
    
    .game-description {
      color: rgba(255,255,255,0.8);
      font-size: 15px;
      line-height: 1.4;
      margin: 0;
      font-weight: 400;
    }
    
    .game-stats {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-top: 2px;
    }
    
    .game-stat {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 13px;
      font-weight: 600;
      color: rgba(255,255,255,0.9);
      background: rgba(147,51,234,0.2);
      padding: 6px 12px;
      border-radius: 10px;
      border: 1.5px solid rgba(147,51,234,0.3);
      backdrop-filter: blur(10px);
      transition: all 0.2s ease;
    }
    
    .game-stat:hover {
      background: rgba(147,51,234,0.3);
      border-color: rgba(147,51,234,0.5);
      transform: translateY(-2px);
    }
    
    .stat-icon {
      font-size: 16px;
    }
    
    .game-play-btn {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 12px;
      background: linear-gradient(135deg, #9333ea, #7c3aed);
      color: white;
      padding: 14px 20px;
      border-radius: 14px;
      font-weight: 700;
      font-size: 16px;
      box-shadow: 0 6px 24px rgba(147,51,234,0.4),
                  inset 0 1px 0 rgba(255,255,255,0.2);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      margin-top: 0;
      position: relative;
      overflow: hidden;
      min-width: 160px;
      flex-shrink: 0;
    }
    
    .game-play-btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
      transition: left 0.5s;
    }
    
    .game-card:hover .game-play-btn {
      background: linear-gradient(135deg, #a855f7, #9333ea);
      box-shadow: 0 10px 32px rgba(147,51,234,0.6),
                  inset 0 1px 0 rgba(255,255,255,0.3);
      transform: translateY(-2px);
    }
    
    .game-card:hover .game-play-btn::before {
      left: 100%;
    }
    
    .play-arrow {
      font-size: 20px;
      transition: transform 0.3s ease;
    }
    
    .game-card:hover .play-arrow {
      transform: translateX(6px);
    }
    
    .coming-soon-badge {
      display: inline-flex;
      align-items: center;
      gap: 10px;
      background: rgba(251,191,36,0.2);
      border: 1.5px solid rgba(251,191,36,0.4);
      color: #fbbf24;
      padding: 10px 18px;
      border-radius: 12px;
      font-size: 14px;
      font-weight: 700;
      margin-top: 12px;
      width: fit-content;
      backdrop-filter: blur(10px);
      box-shadow: 0 4px 12px rgba(251,191,36,0.2);
    }
    
    .connect-google-btn {
      width: 100%;
      padding: 16px;
      background: linear-gradient(135deg, #4285f4, #34a853);
      color: white;
      border: none;
      border-radius: 12px;
      font-weight: 600;
      font-size: 16px;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
    }
    
    .connect-google-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 20px rgba(66,133,244,0.3);
    }
    
    /* ==========================================================================
       CARD COMPONENTS
       ========================================================================== */
    
    .card {
      position: relative;
      background: linear-gradient(145deg, rgba(15, 23, 42, 0.98), rgba(30, 41, 80, 0.95));
      backdrop-filter: blur(var(--panel-blur));
      -webkit-backdrop-filter: blur(var(--panel-blur));
      border: 1px solid rgba(255,255,255,0.12);
      padding: 32px;
      border-radius: 16px;
      box-shadow: 0 25px 60px rgba(13, 16, 35, 0.7), inset 0 1px 0 rgba(255,255,255,0.05);
      animation: scaleIn 0.5s ease-out;
      transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      overflow: visible;
      will-change: transform;
    }
    
    /* White overlay removed for performance */
    
    .card:hover {
      transform: translateY(-6px);
      box-shadow: 0 30px 70px rgba(13, 16, 35, 0.8), inset 0 1px 0 rgba(255,255,255,0.08);
      border-color: rgba(102,126,234,0.3);
    }
    
    /* Hover effect removed */
    
    .card-title {
      font-size: 22px;
      color: #ffffff;
      font-weight: 700;
      margin: 0 0 24px 0;
      padding: 0 0 20px 0;
      border-bottom: 1px solid rgba(255,255,255,0.15);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 16px;
      text-shadow: 0 2px 10px rgba(0,0,0,0.1);
      letter-spacing: 0.3px;
    }
    
    .card-title-left {
      display: flex;
      align-items: center;
      gap: 12px;
      font-size: 22px;
    }
    
    .card-title-left span {
      font-size: 24px;
      line-height: 1;
    }
    
    .show-all-notes-btn {
      margin-left: auto;
      padding: 12px 24px;
      background: linear-gradient(135deg, rgba(102, 126, 234, 0.15), rgba(118, 75, 162, 0.15));
      border: 1.5px solid rgba(102, 126, 234, 0.4);
      border-radius: 12px;
      color: #ffffff;
      font-size: 14px;
      font-weight: 600;
      letter-spacing: 0.3px;
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      display: flex;
      align-items: center;
      gap: 8px;
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      box-shadow: 0 4px 12px rgba(102, 126, 234, 0.2);
    }

    .show-all-notes-btn:hover {
      background: linear-gradient(135deg, rgba(102, 126, 234, 0.25), rgba(118, 75, 162, 0.25));
      border-color: rgba(102, 126, 234, 0.6);
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(102, 126, 234, 0.35);
    }

    .show-all-notes-btn:active {
      transform: translateY(0px);
      box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
    }
    
    .profile-info {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    
    .info-row {
      display: grid;
      grid-template-columns: 140px 1fr;
      align-items: center;
      gap: 20px;
      padding: 18px 22px;
      background: linear-gradient(140deg, rgba(255,255,255,0.14), rgba(255,255,255,0.04));
      border: 1px solid rgba(255,255,255,0.18);
      border-radius: 14px;
      transition: all 0.35s cubic-bezier(0.4, 0, 0.2, 1);
      animation: slideInRight 0.5s ease-out backwards;
      min-height: 62px;
      backdrop-filter: blur(18px);
      -webkit-backdrop-filter: blur(18px);
      box-shadow: 0 8px 24px rgba(15, 27, 71, 0.18);
      position: relative;
      overflow: hidden;
    }

    .info-row::after {
      content: '';
      position: absolute;
      top: 0;
      right: 0;
      width: 40%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.18));
      opacity: 0;
      transition: opacity 0.35s ease;
      pointer-events: none;
    }
    
    .info-row:nth-child(1) { animation-delay: 0.1s; }
    .info-row:nth-child(2) { animation-delay: 0.2s; }
    .info-row:nth-child(3) { animation-delay: 0.3s; }
    .info-row:nth-child(4) { animation-delay: 0.4s; }
    .info-row:nth-child(5) { animation-delay: 0.5s; }
    
    .info-row:hover {
      transform: translateX(6px);
      box-shadow: 0 14px 34px rgba(102,126,234,0.28);
      border-color: rgba(255,255,255,0.32);
    }

    .info-row:hover::after {
      opacity: 0.35;
    }
    
    .info-label {
      font-weight: 600;
      color: rgba(255,255,255,0.75);
      font-size: 13px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .info-value {
      font-weight: 700;
      color: #ffffff;
      font-size: 16px;
      text-shadow: 0 2px 4px rgba(0,0,0,0.1);
      text-align: right;
      word-break: break-word;
      overflow-wrap: break-word;
    }
    
    .payment-list {
      display: grid;
      grid-template-columns: repeat(2, minmax(120px, 0.85fr));
      grid-auto-flow: row;
      gap: 10px;
      max-height: 184px;
      overflow-y: auto;
      padding: 4px;
      margin-top: 16px;
    }
    
    .payment-list::-webkit-scrollbar {
      width: 6px;
    }
    
    .payment-list::-webkit-scrollbar-track {
      background: transparent;
    }
    
    .payment-list::-webkit-scrollbar-thumb {
      background: transparent;
      border-radius: 10px;
    }
    
    .payment-list:hover::-webkit-scrollbar-thumb {
      background: rgba(255,255,255,0.3);
    }
    
    .payment-list::-webkit-scrollbar-thumb:hover {
      background: rgba(255,255,255,0.5);
    }
    
    .payment-item {
      display: flex;
      flex-direction: column;
      gap: 8px;
      padding: 14px 16px;
      background: linear-gradient(145deg, rgba(255,255,255,0.14), rgba(255,255,255,0.04));
      border: 1px solid rgba(255,255,255,0.18);
      border-radius: 16px;
      border-left: 3px solid rgba(255,255,255,0.38);
      transition: all 0.35s cubic-bezier(0.4, 0, 0.2, 1);
      animation: slideInRight 0.4s ease-out backwards;
      position: relative;
      overflow: hidden;
      min-height: 80px;
      backdrop-filter: blur(var(--list-blur));
      -webkit-backdrop-filter: blur(var(--list-blur));
      box-shadow: 0 12px 32px rgba(12, 22, 54, 0.22);
    }
    
    .payment-item::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.16), transparent);
      transition: left 0.5s;
    }
    
    .payment-item:hover::before {
      left: 100%;
    }
    
    .payment-item:hover {
      transform: translateY(-2px);
      box-shadow: 0 18px 44px rgba(0,0,0,0.22);
      border-color: rgba(255,255,255,0.32);
    }
    
    .payment-item.paid {
      border-left-color: #22c55e;
    }
    
    .payment-item.credit {
      border-left-color: #fb923c;
    }
    
    .payment-item.unpaid {
      border-left-color: #ef4444;
    }
    
    .payment-item.absent {
      border-left-color: #f59e0b;
    }
    
    .payment-date {
      font-weight: 600;
      color: #ffffff;
      font-size: 13px;
      margin-bottom: 4px;
      text-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    .payment-status {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      font-size: 14px;
      color: rgba(255,255,255,0.9);
    }
    
    .status-badge {
      padding: 4px 12px;
      border-radius: 20px;
      font-weight: 600;
      font-size: 12px;
    }
    
    .status-badge.paid {
      background: rgba(34,197,94,0.15);
      color: #22c55e;
    }
    
    .status-badge.credit {
      background: rgba(251,146,60,0.15);
      color: #fb923c;
    }
    
    .status-badge.unpaid {
      background: rgba(239,68,68,0.15);
      color: #ef4444;
    }
    
    .status-badge.absent {
      background: rgba(245,158,11,0.15);
      color: #f59e0b;
    }
    
    .payment-amount {
      font-weight: 700;
      font-size: 16px;
      color: #667eea;
    }
    
    .payment-breakdown-note {
      margin-top: 8px;
      padding: 8px 12px;
      background: rgba(102,126,234,0.1);
      border-left: 2px solid rgba(102,126,234,0.4);
      border-radius: 6px;
      font-size: 11px;
      color: rgba(255,255,255,0.75);
      line-height: 1.4;
    }
    
    .summary-stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 12px;
      margin-bottom: 16px;
    }
    
    .stat-card {
      padding: 18px 16px;
      background: linear-gradient(150deg, rgba(255,255,255,0.16), rgba(255,255,255,0.05));
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,0.2);
      text-align: center;
      animation: scaleIn 0.5s ease-out backwards;
      transition: all 0.35s cubic-bezier(0.4, 0, 0.2, 1);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      min-height: 90px;
      backdrop-filter: blur(18px);
      -webkit-backdrop-filter: blur(18px);
      position: relative;
      overflow: hidden;
      box-shadow: 0 10px 36px rgba(12, 22, 54, 0.2);
    }

    .stat-card::after {
      content: '';
      position: absolute;
      inset: 0;
      background: radial-gradient(circle at top, rgba(255,255,255,0.25), transparent 60%);
      opacity: 0;
      transition: opacity 0.35s ease;
      pointer-events: none;
    }
    
    .stat-card:nth-child(1) { animation-delay: 0.1s; }
    .stat-card:nth-child(2) { animation-delay: 0.2s; }
    .stat-card:nth-child(3) { animation-delay: 0.3s; }
    
    .stat-card:hover {
      transform: translateY(-6px);
      box-shadow: 0 18px 48px rgba(102,126,234,0.28);
      border-color: rgba(255,255,255,0.3);
    }

    .stat-card:hover::after {
      opacity: 0.6;
    }
    
    .stat-label {
      font-size: 11px;
      color: rgba(255,255,255,0.7);
      margin-bottom: 6px;
      text-transform: uppercase;
      letter-spacing: 1px;
      font-weight: 600;
    }
    
    .stat-value {
      font-size: 26px;
      font-weight: 700;
      color: #ffffff;
      text-shadow: 0 2px 10px rgba(0,0,0,0.2);
      line-height: 1;
    }
    
    .stat-date {
      font-size: 10px;
      color: rgba(255,255,255,0.55);
      margin-top: 6px;
      font-weight: 500;
      letter-spacing: 0.3px;
    }
    
    /* Unpaid stat card - clean style matching Last Paid box */
    .stat-card.has-unpaid {

    .stat-card.credit-card {
      border-color: #f59e0b !important;
    }

    .stat-card.credit-card .stat-value {
      color: #f59e0b;
    }

    .stat-card.credit-card .stat-date {
      color: rgba(245, 158, 11, 0.8);
      font-weight: 500;
    }
      /* No special effects - looks exactly like green box but red */
    }
    
    .login-screen {
      max-width: 450px;
      margin: 80px auto;
      background: linear-gradient(145deg, rgba(15, 23, 42, 0.98), rgba(30, 41, 80, 0.95));
      backdrop-filter: blur(var(--panel-blur));
      -webkit-backdrop-filter: blur(var(--panel-blur));
      padding: 40px;
      border-radius: 24px;
      box-shadow: 0 25px 60px rgba(13, 16, 35, 0.7), inset 0 1px 0 rgba(255,255,255,0.05);
      animation: scaleIn 0.5s ease-out; /* Glow animation removed for performance */
      border: 1px solid rgba(102,126,234,0.3);
    }
    
    .step-indicator {
      display: flex;
      justify-content: center;
      gap: 10px;
      margin-bottom: 30px;
    }
    
    .step-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: #e2e8f0;
      transition: all 0.3s;
    }
    
    .step-dot.active {
      background: #667eea;
      width: 30px;
      border-radius: 5px;
    }
    
    .auth-step {
      display: none;
    }
    
    .auth-step.active {
      display: block;
      animation: fadeIn 0.3s;
    }
    
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }
    
    /* Futuristic Animations */
    @keyframes shimmer {
      0% { background-position: -1000px 0; }
      100% { background-position: 1000px 0; }
    }
    
    @keyframes glow {
      0%, 100% { box-shadow: 0 0 20px rgba(102,126,234,0.3), 0 0 40px rgba(102,126,234,0.2); }
      50% { box-shadow: 0 0 30px rgba(102,126,234,0.5), 0 0 60px rgba(102,126,234,0.3); }
    }
    
    @keyframes float {
      0%, 100% { transform: translateY(0px); }
      50% { transform: translateY(-10px); }
    }
    
    @keyframes slideInRight {
      from { opacity: 0; transform: translateX(30px); }
      to { opacity: 1; transform: translateX(0); }
    }
    
    @keyframes slideInLeft {
      from { opacity: 0; transform: translateX(-30px); }
      to { opacity: 1; transform: translateX(0); }
    }
    
    @keyframes scaleIn {
      from { opacity: 0; transform: scale(0.9); }
      to { opacity: 1; transform: scale(1); }
    }
    
    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }
    
    @keyframes borderGlow {
      0%, 100% { border-color: rgba(255,255,255,0.3); }
      50% { border-color: rgba(102,126,234,0.8); }
    }
    
    @keyframes unlock {
      0% { transform: scale(1) rotate(0deg); }
      25% { transform: scale(1.2) rotate(-10deg); }
      75% { transform: scale(1.2) rotate(10deg); }
      100% { transform: scale(1) rotate(0deg); opacity: 0; }
    }
    
    @keyframes urgentBlink {
      0%, 49% { 
        opacity: 1;
        text-shadow: 0 0 10px rgba(239, 68, 68, 0.8), 0 0 20px rgba(239, 68, 68, 0.5);
      }
      50%, 100% { 
        opacity: 0.4;
        text-shadow: 0 0 5px rgba(239, 68, 68, 0.4), 0 0 10px rgba(239, 68, 68, 0.2);
      }
    }
    
    @keyframes unpaidGlow {
      0%, 100% { 
        box-shadow: 0 10px 36px rgba(239, 68, 68, 0.3), 0 0 20px rgba(239, 68, 68, 0.4);
        border-color: rgba(239, 68, 68, 0.6);
      }
      50% { 
        box-shadow: 0 10px 36px rgba(239, 68, 68, 0.5), 0 0 30px rgba(239, 68, 68, 0.6);
        border-color: rgba(239, 68, 68, 0.9);
      }
    }
    
    .login-header {
      text-align: center;
      margin-bottom: 30px;
    }
    
    .login-logo {
      width: 180px;
      height: 180px;
      margin-bottom: 40px;
      filter: drop-shadow(0 0 15px rgba(102,126,234,0.8));
    }
    
    .login-title {
      font-size: 28px;
      color: #667eea;
      margin-bottom: 10px;
    }
    
    .login-subtitle {
      color: rgba(255,255,255,0.7);
      font-size: 14px;
    }
    
    .input-group {
      margin-bottom: 20px;
    }
    
    .input-label {
      display: block;
      font-weight: 600;
      color: #ffffff;
      margin-bottom: 8px;
      font-size: 14px;
    }
    
    .input-field {
      width: 100%;
      padding: 12px 16px;
      border: 1px solid rgba(255,255,255,0.12);
      background: linear-gradient(145deg, rgba(15, 23, 42, 0.6), rgba(30, 41, 80, 0.5));
      border-radius: 10px;
      font-size: 16px;
      color: #ffffff;
      transition: all 0.2s;
    }
    
    .input-field:focus {
      outline: none;
      border-color: #667eea;
      box-shadow: 0 0 0 3px rgba(102,126,234,0.2);
    }
    
    .login-btn {
      width: 100%;
      padding: 14px;
      background: linear-gradient(135deg, #667eea, #764ba2);
      color: white;
      border: none;
      border-radius: 12px;
      font-weight: 600;
      font-size: 16px;
      cursor: pointer;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
    }
    
    .login-btn::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 0;
      height: 0;
      border-radius: 50%;
      background: rgba(255,255,255,0.2);
      transform: translate(-50%, -50%);
      transition: width 0.6s, height 0.6s;
    }
    
    .login-btn:hover::before {
      width: 400px;
      height: 400px;
    }
    
    .login-btn:hover {
      transform: translateY(-3px) scale(1.02);
      box-shadow: 0 10px 30px rgba(102,126,234,0.4);
    }
    
    .login-btn:active {
      transform: translateY(-1px) scale(0.98);
    }
    
    .error-message {
      background: rgba(239,68,68,0.15);
      color: #ef4444;
      padding: 12px;
      border-radius: 10px;
      margin-bottom: 20px;
      font-size: 14px;
      text-align: center;
    }
    
    .loading {
      text-align: center;
      padding: 50px;
      color: white;
      font-size: 18px;
      /* Pulse animation removed for performance */
    }
    
    .loading::after {
      content: '';
      display: block;
      width: 50px;
      height: 50px;
      margin: 20px auto;
      border: 4px solid rgba(255,255,255,0.3);
      border-top-color: white;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    @media (max-width: 768px) {
      .content {
        grid-template-columns: 1fr;
      }
      
      .summary-stats {
        grid-template-columns: 1fr;
      }
      
      .group-schedule {
        grid-template-columns: 1fr;
      }
      
      .games-container {
        grid-template-columns: 1fr;
        gap: 16px;
      }
      
      .game-card {
        padding: 24px;
        flex-direction: column;
        align-items: flex-start;
        gap: 16px;
      }

      .game-play-btn {
        width: 100%;
        min-width: 0;
      }
      
      .game-icon {
        font-size: 48px;
      }
      
      .game-title {
        font-size: 20px;
      }
      
      .game-modal-container {
        width: 100vw;
        height: 100vh;
        height: 100dvh;
        border-radius: 0;
        max-width: none;
        max-height: 100vh;
        max-height: 100dvh;
      }
      
      .game-modal-header {
        padding: 16px 20px;
      }
      
      .game-modal-header h2 {
        font-size: 20px;
      }
      
      .header {
        text-align: center;
      }
      
      .header-left {
        flex-direction: column;
      }
    }

    @media (max-width: 600px) {
      .header {
        padding: 20px;
        border-radius: 20px;
        gap: 16px;
      }
      .logo {
        width: 110px;
        height: 110px;
      }
      .header-title h1 {
        font-size: 32px;
      }
      .header-title h1 .name-line {
        font-size: 34px !important;
      }
      .logout-btn {
        width: 100%;
        justify-content: center;
        text-align: center;
      }
    }
    
    /* Impersonation Banner */
    .impersonation-circle {
      position: fixed;
      top: calc(20px + env(safe-area-inset-top, 0px));
      right: calc(20px + env(safe-area-inset-right, 0px));
      width: 50px;
      height: 50px;
      background: linear-gradient(135deg, #ef4444, #dc2626);
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10000;
      border-radius: 50%;
      box-shadow: 0 4px 20px rgba(239, 68, 68, 0.4);
      cursor: pointer;
      transition: all 0.3s ease;
      animation: pulseGlow 2s infinite;
    }
    
    .impersonation-circle:hover {
      transform: scale(1.1);
      box-shadow: 0 6px 30px rgba(239, 68, 68, 0.6);
    }
    
    @keyframes pulseGlow {
      0%, 100% {
        box-shadow: 0 4px 20px rgba(239, 68, 68, 0.4);
      }
      50% {
        box-shadow: 0 4px 30px rgba(239, 68, 68, 0.7);
      }
    }
    
    .impersonation-icon {
      font-size: 24px;
    }
    
    /* Remove body padding adjustment - no longer needed */
    
    /* Schedule Card Styles */
    .schedule-updated-badge {
      display: inline-block;
      background: rgba(251,188,4,0.2);
      color: #fbbc04;
      padding: 4px 12px;
      border-radius: 12px;
      font-size: 11px;
      font-weight: 700;
      margin-left: 12px;
      /* Pulse animation removed for performance */
    }
    
    /* Pulse animation removed for performance */
    
    .next-class-card {
      padding: 22px 26px;
      border-radius: 26px;
      background: rgba(255, 255, 255, 0.04);
      border: 1px solid rgba(255, 255, 255, 0.12);
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
      margin-bottom: 25px;
      position: relative;
      overflow: visible;
    }
    
    /* Snow on next-class-card - asymmetric */
    body.christmas-theme .next-class-card::before {
      content: '';
      position: absolute;
      top: -9px;
      left: 0;
      right: 0;
      height: 14px;
      background: linear-gradient(180deg, 
        rgba(255, 255, 255, 0.98) 0%, 
        rgba(245, 252, 255, 0.92) 30%, 
        rgba(240, 248, 255, 0.85) 50%,
        rgba(255, 255, 255, 0.65) 70%,
        transparent 100%);
      border-radius: 26px 26px 0 0;
      pointer-events: none;
      z-index: 10;
      -webkit-mask-image: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1000 25"><path d="M0,16 Q10,6 22,11 Q35,16 49,10 Q64,5 79,12 Q93,17 108,11 Q123,6 137,14 Q152,19 167,12 Q182,7 197,15 Q212,20 227,13 Q242,8 257,14 Q272,19 287,11 Q302,5 317,13 Q332,18 347,10 Q362,4 377,12 Q392,17 407,9 Q422,3 437,11 Q452,16 467,8 Q482,2 497,10 Q512,15 527,7 Q542,1 557,9 Q572,14 587,6 Q602,0 617,8 Q632,13 647,5 Q662,0 677,9 Q692,14 707,7 Q722,2 737,11 Q752,16 767,9 Q782,4 797,13 Q812,18 827,11 Q842,6 857,14 Q872,19 887,12 Q902,7 917,13 Q932,18 947,10 Q962,4 977,12 Q987,17 1000,11 L1000,25 L0,25 Z" fill="white"/></svg>');
      mask-image: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1000 25"><path d="M0,16 Q10,6 22,11 Q35,16 49,10 Q64,5 79,12 Q93,17 108,11 Q123,6 137,14 Q152,19 167,12 Q182,7 197,15 Q212,20 227,13 Q242,8 257,14 Q272,19 287,11 Q302,5 317,13 Q332,18 347,10 Q362,4 377,12 Q392,17 407,9 Q422,3 437,11 Q452,16 467,8 Q482,2 497,10 Q512,15 527,7 Q542,1 557,9 Q572,14 587,6 Q602,0 617,8 Q632,13 647,5 Q662,0 677,9 Q692,14 707,7 Q722,2 737,11 Q752,16 767,9 Q782,4 797,13 Q812,18 827,11 Q842,6 857,14 Q872,19 887,12 Q902,7 917,13 Q932,18 947,10 Q962,4 977,12 Q987,17 1000,11 L1000,25 L0,25 Z" fill="white"/></svg>');
      -webkit-mask-size: 100% 100%;
      mask-size: 100% 100%;
      -webkit-mask-repeat: no-repeat;
      mask-repeat: no-repeat;
      box-shadow: 
        0 2px 4px rgba(156, 220, 254, 0.5),
        0 3px 6px rgba(255, 255, 255, 0.4),
        inset 0 -2px 4px rgba(184, 230, 255, 0.6),
        inset 2px 1px 3px rgba(255, 255, 255, 0.7);
      filter: drop-shadow(0 2px 3px rgba(156, 220, 254, 0.4)) drop-shadow(-1px 1px 2px rgba(200, 235, 255, 0.3));
    }
    
    body.christmas-theme .next-class-card::after {
      content: '';
      position: absolute;
      top: -9px;
      left: 7%;
      width: 3px;
      height: 16px;
      background: linear-gradient(180deg, 
        rgba(255, 255, 255, 0.95) 0%, 
        rgba(245, 252, 255, 0.8) 40%, 
        rgba(240, 248, 255, 0.6) 70%, 
        transparent 100%);
      border-radius: 0 0 50% 50%;
      pointer-events: none;
      z-index: 9;
      box-shadow: 
        9% 0 0 0 rgba(255, 255, 255, 0.9),
        18% 2px 0 0 rgba(255, 255, 255, 0.84),
        27% -1px 0 0 rgba(255, 255, 255, 0.92),
        36% 1px 0 0 rgba(255, 255, 255, 0.77),
        45% 0 0 0 rgba(255, 255, 255, 0.86),
        54% 2px 0 0 rgba(255, 255, 255, 0.79),
        63% 0 0 0 rgba(255, 255, 255, 0.88),
        72% -1px 0 0 rgba(255, 255, 255, 0.81),
        81% 1px 0 0 rgba(255, 255, 255, 0.85),
        90% 0 0 0 rgba(255, 255, 255, 0.78);
      filter: drop-shadow(0 1px 2px rgba(156, 220, 254, 0.25));
    }

    .next-class-label {
      font-size: 14px;
      font-weight: 600;
      letter-spacing: 1px;
      color: rgba(255, 255, 255, 0.55);
      margin-bottom: 6px;
      text-transform: uppercase;
    }

    .next-class-date {
      font-size: 20px;
      font-weight: 700;
      color: white;
      margin-bottom: 18px;
    }

    .next-class-timer {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 12px 18px;
      border-radius: 16px;
      background: rgba(255, 255, 255, 0.06);
      border: 1px solid rgba(255, 255, 255, 0.10);
      backdrop-filter: blur(10px);
    }

    .timer-icon {
      font-size: 20px;
    }

    .timer-text {
      font-size: 16px;
      color: rgba(255, 255, 255, 0.75);
    }

    .timer-value {
      font-size: 20px;
      font-weight: 700;
      margin-left: 4px;
      background: linear-gradient(90deg, #8ab4ff, #b499ff);
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
    }
    
    .next-class-timer .timer-value {
      font-family: 'Courier New', monospace;
      font-size: 26px;
      font-weight: 700;
      color: #8b9eff;
      letter-spacing: 2px;
      text-shadow: 0 0 20px rgba(102,126,234,0.5),
                   0 2px 4px rgba(0,0,0,0.3);
    }
    
    .group-schedule {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 16px;
      margin-top: 16px;
    }
    
    .schedule-card {
      padding: 14px 18px;
      background: rgba(255, 255, 255, 0.06);
      border-radius: 18px;
      border: 1px solid rgba(255, 255, 255, 0.12);
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      position: relative;
      overflow: visible;
    }
    
    /* Snow on schedule cards - asymmetric */
    body.christmas-theme .schedule-card::before {
      content: '';
      position: absolute;
      top: -8px;
      left: 0;
      right: 0;
      height: 12px;
      background: linear-gradient(180deg, 
        rgba(255, 255, 255, 0.98) 0%, 
        rgba(245, 252, 255, 0.92) 30%, 
        rgba(240, 248, 255, 0.85) 50%,
        rgba(255, 255, 255, 0.65) 70%,
        transparent 100%);
      border-radius: 18px 18px 0 0;
      pointer-events: none;
      z-index: 10;
      -webkit-mask-image: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1000 25"><path d="M0,14 Q12,5 25,10 Q38,15 52,9 Q67,4 82,11 Q96,16 111,10 Q126,5 140,13 Q155,18 170,11 Q185,6 200,14 Q215,19 230,12 Q245,7 260,13 Q275,18 290,10 Q305,4 320,12 Q335,17 350,9 Q365,3 380,11 Q395,16 410,8 Q425,2 440,10 Q455,15 470,7 Q485,1 500,9 Q515,14 530,6 Q545,0 560,8 Q575,13 590,5 Q605,0 620,9 Q635,14 650,7 Q665,2 680,11 Q695,16 710,9 Q725,4 740,13 Q755,18 770,11 Q785,6 800,14 Q815,19 830,12 Q845,7 860,13 Q875,18 890,10 Q905,4 920,12 Q935,17 950,9 Q965,3 980,11 Q990,16 1000,10 L1000,25 L0,25 Z" fill="white"/></svg>');
      mask-image: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1000 25"><path d="M0,14 Q12,5 25,10 Q38,15 52,9 Q67,4 82,11 Q96,16 111,10 Q126,5 140,13 Q155,18 170,11 Q185,6 200,14 Q215,19 230,12 Q245,7 260,13 Q275,18 290,10 Q305,4 320,12 Q335,17 350,9 Q365,3 380,11 Q395,16 410,8 Q425,2 440,10 Q455,15 470,7 Q485,1 500,9 Q515,14 530,6 Q545,0 560,8 Q575,13 590,5 Q605,0 620,9 Q635,14 650,7 Q665,2 680,11 Q695,16 710,9 Q725,4 740,13 Q755,18 770,11 Q785,6 800,14 Q815,19 830,12 Q845,7 860,13 Q875,18 890,10 Q905,4 920,12 Q935,17 950,9 Q965,3 980,11 Q990,16 1000,10 L1000,25 L0,25 Z" fill="white"/></svg>');
      -webkit-mask-size: 100% 100%;
      mask-size: 100% 100%;
      -webkit-mask-repeat: no-repeat;
      mask-repeat: no-repeat;
      box-shadow: 
        0 2px 4px rgba(156, 220, 254, 0.5),
        0 3px 6px rgba(255, 255, 255, 0.4),
        inset 0 -2px 4px rgba(184, 230, 255, 0.6),
        inset 2px 1px 3px rgba(255, 255, 255, 0.7);
      filter: drop-shadow(0 2px 3px rgba(156, 220, 254, 0.4)) drop-shadow(-1px 1px 2px rgba(200, 235, 255, 0.3));
    }
    
    body.christmas-theme .schedule-card::after {
      content: '';
      position: absolute;
      top: -8px;
      left: 6%;
      width: 3px;
      height: 14px;
      background: linear-gradient(180deg, 
        rgba(255, 255, 255, 0.95) 0%, 
        rgba(245, 252, 255, 0.8) 40%, 
        rgba(240, 248, 255, 0.6) 70%, 
        transparent 100%);
      border-radius: 0 0 50% 50%;
      pointer-events: none;
      z-index: 9;
      box-shadow: 
        8% 1px 0 0 rgba(255, 255, 255, 0.88),
        16% 0 0 0 rgba(255, 255, 255, 0.82),
        25% 2px 0 0 rgba(255, 255, 255, 0.9),
        34% 0 0 0 rgba(255, 255, 255, 0.75),
        43% 1px 0 0 rgba(255, 255, 255, 0.85),
        52% 0 0 0 rgba(255, 255, 255, 0.78),
        61% -1px 0 0 rgba(255, 255, 255, 0.87),
        70% 1px 0 0 rgba(255, 255, 255, 0.8),
        79% 0 0 0 rgba(255, 255, 255, 0.83),
        88% 2px 0 0 rgba(255, 255, 255, 0.76);
      filter: drop-shadow(0 1px 2px rgba(156, 220, 254, 0.25));
    }
    
    .schedule-card:hover {
      background: rgba(255, 255, 255, 0.08);
      border-color: rgba(102,126,234,0.3);
      transform: translateY(-2px);
    }
    
    .schedule-card.one-time {
      background: linear-gradient(145deg, rgba(251,188,4,0.15), rgba(251,188,4,0.1));
      border-color: rgba(251,188,4,0.5);
    }
    
    .time-row {
      display: flex;
      align-items: center;
      justify-content: flex-start;
      gap: 8px;
      padding: 2px 0;
    }
    
    .flag {
      font-size: 12px;
      width: 20px;
      flex-shrink: 0;
    }
    
    .day-name {
      font-size: 12px;
      font-weight: 600;
      width: 75px;
      color: #ffffff;
      flex-shrink: 0;
    }
    
    .time-value {
      font-size: 12px;
      font-weight: 600;
      margin-left: auto;
      white-space: nowrap;
    }
    
    .la-time {
      color: #a3c8ff;
    }
    
    .miami-time {
      color: #f5c042;
    }
    
    .yerevan-time {
      color: #d5a6ff;
    }
    
    .time-divider {
      border-bottom: 1px solid rgba(255, 255, 255, 0.08);
      margin: 6px 0;
    }
    
    .one-time-date {
      display: block;
      font-size: 11px;
      color: #fbbc04;
      margin-top: 10px;
      font-weight: 700;
      text-shadow: 0 0 15px rgba(251,188,4,0.6);
      letter-spacing: 0.5px;
    }
    
    .schedule-empty {
      color: rgba(255,255,255,0.6);
      font-size: 13px;
      text-align: center;
      padding: 16px;
      font-style: italic;
    }
    
    /* Announcements Feed Styles */
    .announcements-feed {
      max-height: 400px;
      overflow-y: auto;
      padding: 4px;
    }
    
    .announcements-feed::-webkit-scrollbar {
      width: 8px;
    }
    
    .announcements-feed::-webkit-scrollbar-track {
      background: rgba(255,255,255,0.05);
      border-radius: 4px;
    }
    
    .announcements-feed::-webkit-scrollbar-thumb {
      background: rgba(255,255,255,0.2);
      border-radius: 4px;
    }
    
    .announcements-feed::-webkit-scrollbar-thumb:hover {
      background: rgba(255,255,255,0.3);
    }
    
    .announcement-item {
      background: linear-gradient(145deg, rgba(15, 23, 42, 0.7), rgba(30, 41, 80, 0.6));
      backdrop-filter: blur(var(--list-blur));
      border: 1px solid rgba(255,255,255,0.12);
      border-left-width: 3px;
      border-radius: 10px;
      padding: 12px 14px;
      margin-bottom: 10px;
      transition: all 0.2s;
    }
    
    .announcement-item:hover {
      transform: translateX(4px);
      border-color: rgba(255,255,255,0.2);
      box-shadow: 0 4px 16px rgba(0,0,0,0.15);
    }
    
    .announcement-item.cancelation {
      border-left-color: #ef4444;
      background: linear-gradient(145deg, rgba(239,68,68,0.1), rgba(239,68,68,0.05));
    }
    
    .announcement-item.reschedule {
      border-left-color: #3b82f6;
      background: linear-gradient(145deg, rgba(59,130,246,0.1), rgba(59,130,246,0.05));
    }
    
    .announcement-item.new-class {
      border-left-color: #10b981;
      background: linear-gradient(145deg, rgba(16,185,129,0.1), rgba(16,185,129,0.05));
    }
    
    .announcement-item.permanent-change {
      border-left-color: #f59e0b;
      background: linear-gradient(145deg, rgba(245,158,11,0.1), rgba(245,158,11,0.05));
    }
    
    .announcement-icon {
      font-size: 18px;
      margin-right: 8px;
    }
    
    .announcement-text {
      color: rgba(255,255,255,0.9);
      font-size: 13px;
      line-height: 1.5;
    }
    
    .announcement-date {
      font-size: 11px;
      color: rgba(255,255,255,0.5);
      margin-top: 6px;
      font-style: italic;
    }
    
    .announcement-empty {
      color: rgba(255,255,255,0.6);
      font-size: 13px;
      text-align: center;
      padding: 16px;
      font-style: italic;
    }
    
    /* ==========================================================================
       CHRISTMAS TREE - Fixed Right Side Full Height
       ========================================================================== */
    #christmas-tree-container {
      position: fixed;
      right: 0;
      top: 50%;
      transform: translateY(-50%);
      width: 128.25vh;
      height: 128.25vh;
      pointer-events: none;
      z-index: 1;
      opacity: 1;
      display: none; /* Hidden by default */
    }
    
    body.christmas-theme #christmas-tree-container {
      display: block; /* Show when Christmas theme enabled */
    }
    
    #christmas-tree-canvas {
      position: absolute;
      top: 50%;
      right: -64.125vh;
      transform: translateY(-50%);
      width: auto;
      height: 100%;
      aspect-ratio: 1;
      pointer-events: auto;
    }
    
    @media (max-aspect-ratio: 1) {
      #christmas-tree-canvas {
        width: 100%;
        height: auto;
      }
    }
    
    @media (max-width: 1024px) {
      #christmas-tree-container {
        display: none !important; /* Always hide on mobile */
      }
    }
    
    /* ==========================================================================
       SNOW EFFECT - Full Screen Overlay (GSAP-based falling snow)
       ========================================================================== */
    #fixed-bg {
      position: fixed;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: 100vw;
      height: 100vh;
      height: 100dvh;
      pointer-events: none;
      z-index: 9999;
      display: none; /* Hidden by default */
    }
    
    body.christmas-theme #fixed-bg {
      display: block; /* Show when Christmas theme enabled */
    }
    
    #snowCanvas {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      aspect-ratio: 1;
      width: 100%;
      height: auto;
    }
    
    @media (max-aspect-ratio: 1) {
      #snowCanvas {
        width: auto;
        height: 100%;
      }
    }
  </style>
</head>
<body>
  <!-- Christmas Tree - Fixed Right Side -->
  <div id="christmas-tree-container">
    <canvas id="christmas-tree-canvas"></canvas>
  </div>
  
  <!-- Snow Effect - Full Screen -->
  <div id="fixed-bg">
    <canvas id="snowCanvas"></canvas>
  </div>
  
  <!-- Background animations removed for performance -->
  
  <!-- ==========================================================================
       ADMIN IMPERSONATION INDICATOR
       ========================================================================== -->
  <!-- Impersonation Circle Indicator (hidden by default) -->
  <div id="impersonationBanner" class="impersonation-circle" style="display: none;" onclick="exitImpersonation()" title="Exit Impersonation Mode">
    <span class="impersonation-icon">👁️</span>
  </div>
  
  <!-- Main Portal Content -->
  <div id="portalContent" style="display: block;">
    <div class="container">
      <div class="header">
        <div class="header-left">
          <img src="richyfesta-logo.png" alt="ARNOMA" class="logo">
          <div class="header-title">
            <h1 id="welcomeMessage" style="opacity: 0; transition: opacity 0.3s ease;">
              <span class="title-line">Welcome,</span>
              <span class="name-line">Loading...</span>
            </h1>
          </div>
        </div>
        <div class="header-actions">
          <button class="forum-btn" id="portalAdminBtn" onclick="window.location.href='Student-Portal-Admin.html'" style="display: none;">
            <span>🎛️</span>
            <span>Portal</span>
          </button>
          <button class="forum-btn" onclick="toggleForum()">
            <span>💬</span>
            <span>Nurses</span>
            <span class="forum-badge" id="forumBadge" style="display: none;">0</span>
          </button>
          <div class="account-dropdown">
            <button class="account-btn" onclick="toggleAccountDropdown()">
              <span>👤 My Account</span>
              <span class="dropdown-arrow">▼</span>
            </button>
            <div class="account-menu" id="accountMenu">
              <button class="account-menu-item" onclick="openProfileModal()">
                <span>👤</span>
                <span>My Profile</span>
              </button>
              <button class="account-menu-item" onclick="logout()">
                <span>🚪</span>
                <span>Sign Out</span>
              </button>
            </div>
          </div>
        </div>
      </div>
      
      <!-- All sections in one page - Custom Order -->
      <div class="content">
        
        <!-- 1. GROUP SCHEDULE -->
        <div class="card">
          <h2 class="card-title">
            <div class="card-title-left">
              Your Schedule<span id="scheduleGroupName" style="color: rgba(255,255,255,0.6); font-weight: 400;"></span>
              <span id="scheduleUpdatedBadge" class="schedule-updated-badge" style="display: none;">Updated</span>
            </div>
          </h2>
          
          <!-- Next Class Countdown Timer -->
          <div class="next-class-card">
            <div class="next-class-label">NEXT CLASS:</div>

            <div class="next-class-date" id="nextClassDate">
              Friday, Dec 5 — 8:00 AM
            </div>

            <div class="next-class-timer" id="nextClassTimer">
              <span class="timer-icon">⏳</span>
              <span class="timer-text">Starts in:</span>
              <span class="timer-value" id="countdownValue">1 day</span>
            </div>
          </div>
          
          <!-- Schedule Display -->
          <div class="group-schedule" id="groupScheduleDisplay">
            <div class="schedule-empty">Loading schedule...</div>
          </div>
        </div>

        <!-- 2. PAYMENT HISTORY -->
        <div class="card">
          <h2 class="card-title">
            <div class="card-title-left">
              Payment History
            </div>
          </h2>
          
          <div class="summary-stats">
            <div class="stat-card" style="border-color: #ef4444;">
              <div class="stat-label">Unpaid</div>
              <div class="stat-value" style="color: #ef4444;" id="totalUnpaid">$0</div>
              <div class="stat-date" id="unpaidSourceNote" style="display: none;">-</div>
            </div>
            <div class="stat-card" style="border-color: #22c55e;">
          <div class="stat-label">Last Paid</div>
          <div class="stat-value" style="color: #22c55e;" id="lastPaid">$0</div>
              <div class="stat-date" id="lastPaidDate">-</div>
            </div>
            <div class="stat-card credit-card" id="creditCard" style="border-color: #f59e0b; display: none;">
              <div class="stat-label">Credit</div>
              <div class="stat-value" style="color: #f59e0b;" id="creditBalance">$0</div>
              <div class="stat-date" id="creditNote">Extra payment available</div>
            </div>
            <div class="stat-card" id="absencesCard" style="border-color: #94a3b8; display: none;">
              <div class="stat-label">Absences</div>
              <div class="stat-value" style="color: #94a3b8;" id="absencesCount">0</div>
              <div class="stat-date" id="absencesNote">Missed classes</div>
            </div>
          </div>
          
          <div class="payment-list" id="paymentList" style="margin-top: 15px;">
            <div class="announcement-empty" id="paymentLazyMessage">Loading payment history...</div>
          </div>
        </div>

        <!-- 3. ANNOUNCEMENTS -->
        <div class="card">
          <h2 class="card-title">
            <div class="card-title-left">
              Announcements & Changes
            </div>
          </h2>
          
          <div class="announcements-feed" id="announcementsFeed">
            <div class="announcement-empty">Loading announcements...</div>
          </div>
        </div>

        <!-- 4. GAME CENTER -->
        <div class="card full-width-card games-card">
          <h2 class="card-title">
            <div class="card-title-left">
              <span>🎮</span>
              Study Games
            </div>
          </h2>
          
          <div class="games-container">
            <button type="button" class="game-card pharmaquest-card" onclick="openGameModal('PharmaQuest.html')">
              <div class="game-icon">💊</div>
              <div class="game-content">
                <h3 class="game-title">PharmaQuest</h3>
                <p class="game-description">Master NCLEX medications through interactive gameplay</p>
                <div class="game-stats">
                  <span class="game-stat">
                    <span class="stat-icon">📚</span>
                    <span>3 Difficulty Levels</span>
                  </span>
                  <span class="game-stat">
                    <span class="stat-icon">⚡</span>
                    <span>Quick Study Sessions</span>
                  </span>
                </div>
              </div>
              <div class="game-play-btn">
                <span>Play Now</span>
                <span class="play-arrow">→</span>
              </div>
            </button>
            
            <!-- Practice Test -->
            <button type="button" class="game-card" style="background: linear-gradient(135deg, rgba(139, 92, 246, 0.15), rgba(59, 130, 246, 0.15));" onclick="openGameModal('Tests-Library.html')">
              <div class="game-icon">📝</div>
              <div class="game-content">
                <h3 class="game-title">Practice Tests</h3>
                <p class="game-description">Choose from various tests on different topics</p>
                <div class="game-stats">
                  <span class="game-stat">
                    <span class="stat-icon">📚</span>
                    <span>Multiple Tests</span>
                  </span>
                  <span class="game-stat">
                    <span class="stat-icon">💬</span>
                    <span>Instant Feedback</span>
                  </span>
                </div>
              </div>
              <div class="game-play-btn">
                <span>View Tests</span>
                <span class="play-arrow">→</span>
              </div>
            </button>
            
            <!-- Placeholder for future games -->
            <div class="game-card coming-soon-card">
              <div class="game-icon">🧪</div>
              <div class="game-content">
                <h3 class="game-title">Lab Values Quest</h3>
                <p class="game-description">Coming Soon</p>
                <div class="coming-soon-badge">
                  <span>🚀</span>
                  <span>In Development</span>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- 5. CAROUSEL (NCLEX Systems Progress) -->
        <div class="card full-width-card" style="overflow: visible;">
          <h2 class="card-title">
            <div class="card-title-left">
              <span>🎯</span>
              NCLEX Systems Progress
            </div>
          </h2>
          
          <div class="systems-carousel-container">
            <button class="carousel-nav prev" onclick="scrollCarousel(-1)">‹</button>
            <div class="systems-carousel" id="systemsCarousel" data-ready="false">
              <!-- Loading spinner (will be replaced when data loads) -->
              <div class="carousel-loading-spinner">
                <div class="spinner">🩺</div>
                <p>Loading systems...</p>
              </div>
            </div>
            <button class="carousel-nav next" onclick="scrollCarousel(1)">›</button>
          </div>
          
          <div class="progress-legend">
            <div class="legend-item">
              <span class="legend-dot completed"></span>
              <span>Completed</span>
            </div>
            <div class="legend-item">
              <span class="legend-dot current"></span>
              <span>Ongoing</span>
            </div>
            <div class="legend-item">
              <span class="legend-dot in-progress"></span>
              <span>In Progress</span>
            </div>
            <div class="legend-item">
              <span class="legend-dot not-started"></span>
              <span>Not Started</span>
            </div>
          </div>
        </div>

        <!-- 6. NOTES -->
        <div class="card full-width-card">
          <h2 class="card-title" id="notesCardTitle">
            <div class="card-title-left">
              <span>📚</span>
              Class Materials & Notes
            </div>
            <button 
              id="backToAllNotesBtn" 
              class="show-all-notes-btn" 
              onclick="showAllNotes()" 
              style="display: none;"
              type="button"
            >
              <span style="font-size: 16px;">←</span> Back to All Notes
            </button>
          </h2>
          
          <!-- Search Bar & Filter Toggle -->
          <div style="padding: 0 24px 16px 24px; display: flex; gap: 12px; align-items: center;">
            <div style="flex: 1; position: relative; display: flex; align-items: center;">
              <input 
                type="text" 
                id="notesSearchInput" 
                placeholder="🔍 Search notes by title, date, or system..."
                style="
                  width: 100%;
                  padding: 14px 44px 14px 18px;
                  border-radius: 12px;
                  background: rgba(255, 255, 255, 0.05);
                  border: 1px solid rgba(255, 255, 255, 0.1);
                  color: rgba(255, 255, 255, 0.9);
                  font-size: 15px;
                  font-family: inherit;
                  transition: all 0.3s ease;
                "
                oninput="handleNotesSearchInput(this.value)"
                onfocus="this.style.background='rgba(255,255,255,0.08)'; this.style.borderColor='rgba(102,126,234,0.5)'"
                onblur="this.style.background='rgba(255,255,255,0.05)'; this.style.borderColor='rgba(255,255,255,0.1)'"
              />
              <button
                id="notesSearchClear"
                class="search-clear-btn"
                onclick="clearNotesSearch()"
                title="Clear search"
                style="
                  position: absolute;
                  right: 12px;
                  background: none;
                  border: none;
                  color: rgba(255, 255, 255, 0.5);
                  cursor: pointer;
                  padding: 4px 8px;
                  display: none;
                  font-size: 18px;
                  line-height: 1;
                  transition: all 0.2s ease;
                  border-radius: 4px;
                "
                onmouseover="this.style.color='rgba(255,255,255,0.9)'; this.style.background='rgba(255,255,255,0.1)'"
                onmouseout="this.style.color='rgba(255,255,255,0.5)'; this.style.background='none'"
              >✕</button>
            </div>
            <button
              id="lockedFilterToggle"
              onclick="toggleLockedFilter()"
              style="
                padding: 14px 20px;
                border-radius: 12px;
                background: rgba(255, 255, 255, 0.05);
                border: 1px solid rgba(255, 255, 255, 0.1);
                color: rgba(255, 255, 255, 0.7);
                font-size: 14px;
                font-weight: 600;
                font-family: inherit;
                cursor: pointer;
                transition: all 0.3s ease;
                white-space: nowrap;
                display: flex;
                align-items: center;
                gap: 8px;
              "
              onmouseover="if (!this.classList.contains('active')) { this.style.background='rgba(255,255,255,0.08)'; this.style.borderColor='rgba(255,255,255,0.2)'; }"
              onmouseout="if (!this.classList.contains('active')) { this.style.background='rgba(255,255,255,0.05)'; this.style.borderColor='rgba(255,255,255,0.1)'; }"
            >
              <span style="font-size: 18px;">🔒</span>
              <span>Locked Only</span>
            </button>
          </div>
          
          <div id="classroomContent">
            <div id="classroomList" class="classroom-list">
              <div class="announcement-empty" id="notesLazyMessage">Loading materials...</div>
            </div>
          </div>
        </div>
        
      </div> <!-- End content -->

    </div> <!-- End main -->

    <!-- Forum Sidebar (unchanged) -->
    <div class="forum-sidebar" id="forumSidebar">
          </div>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Alert Modal -->
  <div id="alertModal" onclick="closeCurrentAlert()" style="display: none; position: fixed; inset: 0; background: rgba(0, 0, 0, 0.9); backdrop-filter: blur(12px); z-index: 10001; align-items: center; justify-content: center; padding: 20px;">
    <div onclick="event.stopPropagation()" style="background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%); border-radius: 24px; padding: 0; max-width: 900px; width: 95%; max-height: 90vh; display: flex; flex-direction: column; box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5); border: 1px solid rgba(255, 255, 255, 0.1); position: relative; overflow: hidden;">
      <button onclick="closeCurrentAlert()" style="position: absolute; top: 16px; right: 16px; background: rgba(255, 255, 255, 0.1); border: none; color: white; font-size: 28px; cursor: pointer; width: 40px; height: 40px; border-radius: 10px; display: flex; align-items: center; justify-content: center; transition: all 0.2s; z-index: 10;" onmouseover="this.style.background='rgba(255,255,255,0.2)'" onmouseout="this.style.background='rgba(255,255,255,0.1)'">×</button>
      
      <div id="alertContent" style="padding: 32px; overflow-y: auto; flex: 1;">
        <!-- Alert content will be inserted here -->
      </div>
    </div>
  </div>
  
  <!-- Forum Modal -->
  <div class="forum-modal" id="forumModal">
    <div class="forum-container">
      <div class="forum-header">
        <h2>💬 Nurses</h2>
        <button class="close-forum-btn" onclick="toggleForum()">×</button>
      </div>
      
      <div class="forum-messages" id="forumMessages">
        <!-- Messages will be loaded here -->
      </div>
      
      <div class="forum-input-area">
        <div style="flex: 1; display: flex; flex-direction: column; gap: 8px;">
          <textarea 
            class="forum-input" 
            id="forumInput" 
            placeholder="Ask a question or share something with your classmates..." 
            rows="2"
            onkeypress="if(event.key==='Enter' && !event.shiftKey) { event.preventDefault(); sendForumMessage(); }"></textarea>
          
          <!-- File attachment preview -->
          <div id="fileAttachmentPreview" style="display: none; padding: 8px 12px; background: rgba(96, 165, 250, 0.1); border: 1px solid rgba(96, 165, 250, 0.3); border-radius: 8px; font-size: 13px; color: rgba(255,255,255,0.9); align-items: center; gap: 8px;">
            <span style="font-size: 20px;">�</span>
            <span style="flex: 1; font-size: 12px; color: rgba(255,255,255,0.7);">File attached</span>
            <button onclick="clearFileAttachment()" style="background: linear-gradient(135deg, #3b82f6, #2563eb); border: none; color: white; cursor: pointer; padding: 4px 10px; font-size: 11px; border-radius: 6px; font-weight: 500;" title="Remove file">Remove</button>
          </div>
          
          <!-- Private message indicator -->
          <div id="privateMessageIndicator" style="display: none; padding: 6px 12px; background: linear-gradient(135deg, rgba(139, 92, 246, 0.15), rgba(109, 40, 217, 0.15)); border-left: 3px solid rgba(139, 92, 246, 0.5); border-radius: 6px; align-items: center; gap: 8px;">
            <span style="font-size: 14px;">🔒</span>
            <span style="font-size: 11px; color: rgba(196, 181, 253, 0.9); font-weight: 500;">Private message to Administrator</span>
            <button onclick="togglePrivateMode(false)" style="margin-left: auto; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); color: white; cursor: pointer; padding: 3px 8px; font-size: 10px; border-radius: 4px; font-weight: 500;">Cancel</button>
          </div>
        </div>
        
        <!-- Hidden file input -->
        <input type="file" id="forumFileInput" style="display: none;" accept=".pdf,.doc,.docx,.jpg,.jpeg,.png,.gif,.txt" onchange="handleFileSelection()" />
        
        <button class="attach-file-btn" onclick="document.getElementById('forumFileInput').click()" title="Attach document">
          📎
        </button>
        <button class="private-message-btn" id="privateMessageBtn" onclick="togglePrivateMode(true)" title="Send private message to Administrator" style="background: linear-gradient(135deg, rgba(139, 92, 246, 0.3), rgba(109, 40, 217, 0.3)); border: 2px solid rgba(139, 92, 246, 0.5); color: rgba(196, 181, 253, 1); padding: 12px 16px; border-radius: 12px; font-size: 18px; font-weight: 600; cursor: pointer; transition: all 0.2s; display: flex; align-items: center; justify-content: center; box-shadow: 0 4px 12px rgba(139, 92, 246, 0.2);" onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 16px rgba(139, 92, 246, 0.3)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 12px rgba(139, 92, 246, 0.2)'">
          🔒
        </button>
        <button class="send-message-btn" onclick="sendForumMessage()">
          Send 💬
        </button>
      </div>
    </div>
  </div>
  
  <!-- Game Modal -->
  
  <!-- Profile Modal -->
  <dialog class="profile-modal" id="profileModal" aria-modal="true" tabindex="-1">
    <div class="profile-modal-container">
      <div class="profile-modal-header">
        <h2>👤 My Profile</h2>
        <button class="close-profile-btn" onclick="closeProfileModal()">×</button>
      </div>
      <div class="profile-modal-content">
        <div class="profile-modal-section">
          <div class="profile-modal-row">
            <span class="profile-modal-label">📛 Full Name</span>
            <span class="profile-modal-value" id="modalStudentName">-</span>
          </div>
          <div class="profile-modal-row">
            <span class="profile-modal-label">✉️ Email Address</span>
            <span class="profile-modal-value" id="modalStudentEmail">-</span>
          </div>
          <div class="profile-modal-row">
            <span class="profile-modal-label">👥 Group</span>
            <span class="profile-modal-value" id="modalStudentGroup">-</span>
          </div>
          <div class="profile-modal-row">
            <span class="profile-modal-label">📅 Schedule</span>
            <span class="profile-modal-value" id="modalStudentSchedule">-</span>
          </div>
          <div class="profile-modal-row">
            <span class="profile-modal-label">💵 Class Fee</span>
            <span class="profile-modal-value" id="modalStudentFee">-</span>
          </div>
          <div class="profile-modal-row">
            <span class="profile-modal-label">💳 Unpaid Balance</span>
            <span class="profile-modal-value" id="modalStudentBalance">-</span>
          </div>
          <div class="profile-modal-row">
            <span class="profile-modal-label">🏷️ Aliases</span>
            <span class="profile-modal-value" id="modalStudentAliases" style="font-size: 0.9em; opacity: 0.85;">-</span>
          </div>
        </div>
      </div>
    </div>
  </dialog>

  <dialog class="game-modal" id="gameModal" aria-modal="true" tabindex="-1">
    <div class="game-modal-container">
      <div class="game-modal-header">
        <h2>🎮 PharmaQuest</h2>
        <button class="close-game-btn" onclick="closeGameModal()">×</button>
      </div>
      <div class="game-modal-content">
        <iframe id="gameIframe" src="about:blank" title="PharmaQuest Game" style="border: none;" allowfullscreen></iframe>
      </div>
    </div>
  </dialog>
  
  <script>
    /* ==========================================================================
       STUDENT PORTAL - JAVASCRIPT
       ==========================================================================
       Architecture: Self-contained vanilla JS with direct Supabase integration
       Patterns: DOM caching, data caching with TTL, event-driven updates
       Auth: Supports student login + admin impersonation mode
       VERSION: 2024-12-24-v7 - BALANCE SIGN FIX: POSITIVE=CREDIT, NEGATIVE=DEBT
       ========================================================================== */
    
    // 🔥 VERSION CHECK - Verify this code is loading
    console.log('🚀 STUDENT PORTAL VERSION: 2024-12-24-v7 (Balance Sign Fix: Positive=Credit, Negative=Debt)');
    console.log('📅 Loaded at:', new Date().toLocaleString());
    
    // ==========================================================================
    // PERFORMANCE UTILITIES
    // ==========================================================================
    
    /**
     * Debounce function - delays execution until after wait period of inactivity
     * Prevents expensive operations from running on every keystroke/scroll/resize
     */
    function debounce(func, wait) {
      let timeout;
      return function executedFunction(...args) {
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(this, args), wait);
      };
    }
    
    // ==========================================================================
    // CONFIGURATION
    // ==========================================================================
    const SUPABASE_URL = 'https://zlvnxvrzotamhpezqedr.supabase.co';
    const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Inpsdm54dnJ6b3RhbWhwZXpxZWRyIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjI4MTEzMTcsImV4cCI6MjA3ODM4NzMxN30.-IoSqKhDrA9NuG4j3GufIbfmodWqCoppEklE1nTmw38';
    
    // Initialize Supabase (use supabaseClient to avoid shadowing window.supabase)
    const supabaseClient = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
    
    // ==========================================================================
    // GLOBAL STATE
    // ==========================================================================
    
    /**
     * Checks authentication status and handles both normal student login and admin impersonation mode.
     * 
     * @async
     * @returns {Promise<Object|null>} Student data object if authenticated, null if auth fails
     * 
     * @description
     * This function handles two authentication flows:
     * 1. **Impersonation Mode**: When URL contains ?impersonate=<student_id>
     *    - Validates impersonation token from sessionStorage
     *    - Checks token expiration (10 min default)
     *    - Verifies student ID matches token
     *    - Loads student data from Supabase
     * 
     * 2. **Normal Authentication**: Standard student login via Supabase Auth
     *    - Retrieves active session
     *    - Matches session.user.id to students.auth_user_id
     *    - Redirects to login if no valid session
     * 
     * @example
     * // Called on portal initialization
     * const student = await checkAuthentication();
     * if (student) {
     *   await loadPortal(student);
     * }
     */
    async function checkAuthentication() {
      // ---------- Check for Admin Chat Mode ----------
      const adminChatTokenStr = localStorage.getItem('admin_chat_token') || sessionStorage.getItem('admin_chat_token');
      debugLog('🔍 Checking for admin chat token:', adminChatTokenStr ? 'FOUND' : 'NOT FOUND');
      
      if (adminChatTokenStr) {
        try {
          const adminToken = JSON.parse(adminChatTokenStr);
          debugLog('📋 Admin token parsed:', adminToken);
          
          // Check if token is expired
          if (Date.now() > adminToken.expiresAt) {
            debugLog('🔒 Admin chat token expired');
            localStorage.removeItem('admin_chat_token');
            sessionStorage.removeItem('admin_chat_token');
          } else {
            debugLog('✅ Admin chat mode activated for:', adminToken.adminEmail);
            debugLog('🎯 Returning admin object - SKIPPING student authentication');
            isAdmin = true;
            
            // Return a pseudo student object for admin
            const adminObj = {
              id: 0,
              name: 'Administrator',
              email: adminToken.adminEmail,
              role: 'admin',
              isAdminChatMode: true
            };
            debugLog('👤 Admin object:', adminObj);
            return adminObj;
          }
        } catch (e) {
          console.error('❌ Error parsing admin chat token:', e);
          localStorage.removeItem('admin_chat_token');
          sessionStorage.removeItem('admin_chat_token');
        }
      }
      
      // Check for MASTER ACCESS token (from login page)
      const masterTokenStr = sessionStorage.getItem('impersonation_token') || localStorage.getItem('impersonation_token');
      console.log('🔍 Checking for master token:', masterTokenStr ? 'FOUND' : 'NOT FOUND');
      if (masterTokenStr) {
        try {
          const masterToken = JSON.parse(masterTokenStr);
          console.log('📋 Master token parsed:', masterToken);
          console.log('🔍 Is master access?', masterToken.isMasterAccess);
          // 🔥 REMOVED TIMEOUT CHECK - impersonation never expires
          // console.log('🔍 Is expired?', masterToken.expiresAt < Date.now());
          
          if (masterToken.isMasterAccess) {
            console.log('🔓 MASTER ACCESS detected (no timeout):', masterToken.studentName);
            
            // Load student data
            const { data: student, error } = await supabaseClient
              .from('students')
              .select('*')
              .eq('id', masterToken.studentId)
              .single();
            
            console.log('Student data:', student);
            console.log('Error:', error);
            
            if (student) {
              console.log('✅ Master access granted for:', student.name);
              console.log('📊 Setting currentStudent and loading portal data...');
              currentStudent = student; // SET GLOBAL BEFORE LOADING
              window.currentStudent = student; // Also set window property
              await loadPortalData();
              await ensurePaymentsData();
              console.log('✅ Portal data loaded! paymentHistory:', window.paymentHistory);
              return student;
            } else {
              console.log('❌ Student not found for ID:', masterToken.studentId);
            }
          } else {
            console.log('❌ Master token invalid or expired');
          }
        } catch (e) {
          console.log('❌ Error parsing master token:', e);
        }
      }
      
      // Check for impersonation mode first
      const urlParams = new URLSearchParams(window.location.search);
      const impersonateId = urlParams.get('impersonate');
      
      // ---------- Impersonation Authentication ----------
      if (impersonateId) {
        debugLog('🎭 Impersonation mode detected for student ID:', impersonateId);
        debugLog('📍 Running in iframe:', window.self !== window.top);
        
        // Try both sessionStorage and localStorage
        let tokenData = sessionStorage.getItem('impersonation_token') || localStorage.getItem('impersonation_token');
        debugLog('🔍 Token data found:', tokenData ? 'YES' : 'NO');
        
        if (tokenData) {
          const impersonationToken = JSON.parse(tokenData);
          debugLog('📋 Token parsed:', impersonationToken);
          
          // 🔥 REMOVED TIMEOUT CHECK - impersonation never expires
          // Admin can stay in impersonation mode indefinitely
          // if (impersonationToken.expiresAt < Date.now()) {
          //   console.error('⏰ Token expired');
          //   alert('Impersonation session has expired.');
          //   sessionStorage.removeItem('impersonation_token');
          //   localStorage.removeItem('impersonation_token');
          //   
          //   // If in iframe, tell parent to close modal
          //   if (window.self !== window.top) {
          //     window.parent.postMessage({ action: 'closeImpersonation', reason: 'expired' }, '*');
          //   } else {
          //     window.location.href = 'Student-Portal-Admin.html';
          //   }
          //   return null;
          // }
          
          // Validate student ID matches (convert both to string for comparison)
          if (String(impersonationToken.studentId) !== String(impersonateId)) {
            console.error('❌ Student ID mismatch!', impersonationToken.studentId, 'vs', impersonateId);
            alert('Invalid impersonation token.');
            sessionStorage.removeItem('impersonation_token');
            localStorage.removeItem('impersonation_token');
            
            // If in iframe, tell parent to close modal
            if (window.self !== window.top) {
              window.parent.postMessage({ action: 'closeImpersonation', reason: 'mismatch' }, '*');
            } else {
              window.location.href = 'Student-Portal-Admin.html';
            }
            return null;
          }
          
          // Load the impersonated student's data
          debugLog('📥 Loading student data for ID:', impersonateId);
          const { data: student, error } = await supabaseClient
            .from('students')
            .select('*')
            .eq('id', impersonateId)
            .single();
          
          if (error || !student) {
            console.error('❌ Impersonated student not found:', error);
            console.error('Query details - ID:', impersonateId, 'Type:', typeof impersonateId);
            alert('Student not found. Please contact administrator.');
            sessionStorage.removeItem('impersonation_token');
            localStorage.removeItem('impersonation_token');
            
            // If in iframe, tell parent to close modal
            if (window.self !== window.top) {
              window.parent.postMessage({ action: 'closeImpersonation', reason: 'not_found' }, '*');
            } else {
              window.location.href = 'Student-Portal-Admin.html';
            }
            return null;
          }
          
          debugLog('✅ Impersonation authenticated for:', student.name);
          return student;
        } else {
          console.error('❌ No impersonation token found in sessionStorage or localStorage');
          console.error('SessionStorage keys:', Object.keys(sessionStorage));
          console.error('LocalStorage keys:', Object.keys(localStorage));
          alert('Invalid impersonation session.');
          
          // If in iframe, tell parent to close modal
          if (window.self !== window.top) {
            window.parent.postMessage({ action: 'closeImpersonation', reason: 'no_token' }, '*');
          } else {
            window.location.href = 'Student-Portal-Admin.html';
          }
          return null;
        }
      }
      
      // ---------- Normal Student Authentication ----------
      const { data: { session } } = await supabaseClient.auth.getSession();
      
      if (!session) {
        // Check if we're in admin chat mode - if so, it's okay to have no session
        const adminChatCheck = localStorage.getItem('admin_chat_token') || sessionStorage.getItem('admin_chat_token');
        if (!adminChatCheck) {
          // No session and no admin token - redirect to login
          window.location.href = 'index.html';
          return null;
        }
        // Admin chat mode is active, continue without student session
        return null;
      }
      
      
      // Get student data with detailed error logging
      debugLog('🔍 Looking up student with auth_user_id:', session.user.id);
      const { data: studentData, error } = await supabaseClient
        .from('students')
        .select('*')
        .eq('auth_user_id', session.user.id)
        .single();
      
      if (error || !studentData) {
        console.error('❌ Student lookup failed:', {
          error,
          errorCode: error?.code,
          errorMessage: error?.message,
          errorDetails: error?.details,
          authUserId: session.user.id,
          userEmail: session.user.email
        });
        
        // Check if admin chat mode before showing error
        const adminChatCheck = localStorage.getItem('admin_chat_token') || sessionStorage.getItem('admin_chat_token');
        if (!adminChatCheck) {
          // Show more detailed error message
          const errorMsg = error?.message || 'Unknown error';
          alert(`Your account is not set up correctly.\n\nError: ${errorMsg}\n\nEmail: ${session.user.email}\n\nPlease contact the administrator.`);
          await supabaseClient.auth.signOut();
          window.location.href = 'index.html';
        }
        return null;
      }
      
      debugLog('✅ Student found:', studentData.name);
      
      // If admin account, redirect to Student Manager
      if (studentData.role === 'admin') {
        window.location.href = 'Student-Manager.html';
        return null;
      }
      
      return studentData;
    }
    
    // ==========================================================================
    // DEBUG MODE - Set to false for production
    // ==========================================================================
    /* ==========================================================================
       🚀 PERFORMANCE AUDIT COMPLETE - STUDENT PORTAL OPTIMIZED
       ========================================================================== 
       
       ✅ VERIFIED OPTIMIZATIONS:
       
       1. CACHING SYSTEM
          - Data cache: 5-minute TTL for all database queries
          - DOM cache: Stores querySelector results
          - Payment history cached
          - Group schedule cached
          - Dramatically reduces database hits
       
       2. INTERVAL MANAGEMENT
          - Payment auto-refresh: Every 2 MINUTES (was 30s)
          - Forum auto-refresh: Every 30 SECONDS (was 10s)
          - All intervals use visibility check (document.hidden)
          - Intervals cleared on page unload
          - No duplicate intervals possible
       
       3. ANIMATIONS DISABLED
          - ALL infinite background animations removed
          - Only essential UI transitions enabled
          - New message tag: Pulses 5 times only (not infinite)
          - New message highlight: Pulses 3 times only
          - Slide animations: One-time only
       
       4. DOM OPTIMIZATION
          - No querySelector in loops
          - DOM caching for repeated queries
          - Efficient event delegation
          - No memory leaks
       
       5. DEBUG MODE
          - DEBUG_MODE = false (production)
          - All console.log statements behind debug flag
          - Zero console spam
       
       6. DATABASE EFFICIENCY
          - Specific column selection (no SELECT *)
          - Single queries with .single()
          - Cached results reused
          - Tab visibility checks prevent wasted queries
       
       7. CLEANUP
          - Unused keyframe animations removed
          - Event listeners properly managed
          - Intervals cleared on component unmount
          - No background processes when tab hidden
       
       8. INSTANT LOADING (Dec 9, 2025)
          - Portal shows UI INSTANTLY on load
          - No blocking await on data loading
          - All sections load in background
          - User sees content within 100ms
          - Schedule loads first (visible section)
          - Payments/Materials load in background
          - Section switching is instant (0ms blocking)
       
       RESULT: SUPER FAST, NO LAGGING, NO HEATING, NO BUGS ✨
       ========================================================================== */

    const DEBUG_MODE = false; // PERFORMANCE: Disabled to reduce CPU usage
    
    // Wrap console methods to respect DEBUG_MODE
    const debugLog = (...args) => DEBUG_MODE && console.log(...args);
    const debugDebug = (...args) => DEBUG_MODE && console.debug(...args);
    
    // 🚀 PERFORMANCE TIMER - Track load times
    const perfTimer = {
      start: performance.now(),
      marks: {},
      mark(label) {
        this.marks[label] = performance.now() - this.start;
      },
      summary() {
        const total = performance.now() - this.start;
        if (DEBUG_MODE) console.table(this.marks);
      }
    };
    
    let currentStudent = null;
    window.currentStudent = null; // Expose globally for profile modal
    let currentTotalUnpaid = 0; // Store calculated unpaid amount
    window.currentTotalUnpaid = 0; // Expose globally for profile modal
    let currentEmail = null;
    let isAdmin = false;
    let impersonationMode = false;
    let impersonationToken = null;
    let impersonationTimer = null;
    let countdownInterval = null;
  let currentGroupScheduleData = null;
  let currentGroupScheduleSummary = null;
    let currentPayments = []; // Store payment history globally
    window.paymentHistory = null;
    window.allPayments = [];
    let activeSection = 'overview';
    const sectionLoadedState = {
      overview: false,
      payments: false,
      progress: false,
      materials: false
    };
    let paymentsLoaded = false;
    let paymentsLoadingPromise = null;
    let progressLoaded = false;
    let materialsLoaded = false;
    
    // ==========================================================================
    // CACHING SYSTEM - Performance Optimization
    // ==========================================================================
    
    const dataCache = new Map();
    const domCache = new Map();
    const CACHE_TTL = 5 * 60 * 1000; // 5 minutes
    
    function getCachedData(key) {
      const cached = dataCache.get(key);
      if (!cached) return null;
      
      const now = Date.now();
      if (now - cached.timestamp > CACHE_TTL) {
        dataCache.delete(key);
        return null;
      }
      
      return cached.data;
    }
    
    function setCachedData(key, data) {
      dataCache.set(key, {
        data,
        timestamp: Date.now()
      });
    }
    
    function clearDataCache(pattern = null) {
      if (!pattern) {
        dataCache.clear();
        if (DEBUG_MODE) debugDebug('🧹 Cleared all data cache');
        return;
      }
      
      // Clear matching keys
      for (const key of dataCache.keys()) {
        if (key.includes(pattern)) {
          dataCache.delete(key);
        }
      }
      if (DEBUG_MODE) debugDebug(`🧹 Cleared cache pattern: ${pattern}`);
    }
    
    function getCachedDOM(selector) {
      return domCache.get(selector) || null;
    }
    
    function setCachedDOM(selector, element) {
      domCache.set(selector, element);
    }
    
    function clearDOMCache() {
      domCache.clear();
      if (DEBUG_MODE) debugDebug('🧹 Cleared DOM cache');
    }
    
    // ==========================================================================
    // GLOBAL INTERVAL MANAGER - PERFORMANCE FIX
    // ==========================================================================
    // Prevents duplicate intervals and ensures proper cleanup
    const intervalManager = {
      intervals: new Map(),
      
      set(name, callback, delay) {
        // Clear existing interval if it exists
        this.clear(name);
        
        // Create new interval
        const id = setInterval(callback, delay);
        this.intervals.set(name, id);
        if (DEBUG_MODE) debugDebug(`✅ Interval '${name}' started (${delay}ms)`);
        return id;
      },
      
      clear(name) {
        if (this.intervals.has(name)) {
          clearInterval(this.intervals.get(name));
          this.intervals.delete(name);
          if (DEBUG_MODE) debugDebug(`🛑 Interval '${name}' cleared`);
        }
      },
      
      clearAll() {
        if (DEBUG_MODE) debugDebug(`🧹 Clearing all ${this.intervals.size} intervals`);
        this.intervals.forEach((id, name) => {
          clearInterval(id);
          if (DEBUG_MODE) debugDebug(`  🛑 Cleared '${name}'`);
        });
        this.intervals.clear();
      }
    };
    
    // Clean up all intervals and end session when page unloads
    window.addEventListener('beforeunload', () => {
      intervalManager.clearAll();
      clearDataCache();
      clearDOMCache();
      // End session if one was started (not during impersonation)
      if (sessionId) {
        endSession();
      }
    });
    
    // ==========================================================================
    // CUSTOM DIALOG SYSTEM
    // ==========================================================================
    
    function showLockedNoteDialog(classDate, noteItem = null, isAbsent = false) {
      // Create modal overlay
      const overlay = document.createElement('div');
      overlay.style.cssText = `
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.75);
  backdrop-filter: blur(8px);
  -webkit-backdrop-filter: blur(8px);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10000;
        animation: fadeIn 0.15s ease;
      `;
      
      // Create dialog
      const dialog = document.createElement('div');
      dialog.style.cssText = `
        background: linear-gradient(135deg, rgba(30, 41, 59, 0.95), rgba(15, 23, 42, 0.98));
        border: 1px solid rgba(148, 163, 184, 0.3);
        border-radius: 24px;
        padding: 32px;
        max-width: 440px;
        width: 90%;
        box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
  backdrop-filter: blur(12px);
  -webkit-backdrop-filter: blur(12px);
        animation: slideUp 0.2s ease;
      `;
      
      // 🔥 Different message for absent vs unpaid
      const dialogContent = isAbsent ? `
        <div style="text-align: center;">
          <div style="
            width: 80px;
            height: 80px;
            margin: 0 auto 20px;
            border-radius: 20px;
            background: linear-gradient(135deg, rgba(251, 146, 60, 0.2), rgba(249, 115, 22, 0.1));
            border: 1px solid rgba(251, 146, 60, 0.4);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 40px;
          ">🚫</div>
          
          <h3 style="
            color: rgba(255, 255, 255, 0.95);
            font-size: 1.5rem;
            font-weight: 600;
            margin: 0 0 12px 0;
            letter-spacing: -0.02em;
          ">Note Locked - Absent</h3>
          
          <p style="
            color: rgba(255, 255, 255, 0.75);
            font-size: 1rem;
            line-height: 1.6;
            margin: 0 0 28px 0;
          ">
            The system shows you were <strong style="color: rgba(251, 146, 60, 0.95);">absent</strong> on <strong style="color: rgba(255, 255, 255, 0.95);">${classDate}</strong>. 
            <br><br>
            If you still want to access the notes and class recording, please make the payment
            <button id="paymentInfoBtn" style="
              display: inline-flex;
              align-items: center;
              justify-content: center;
              width: 18px;
              height: 18px;
              border-radius: 50%;
              background: rgba(251, 146, 60, 0.2);
              border: 1px solid rgba(251, 146, 60, 0.4);
              color: rgba(251, 146, 60, 0.9);
              cursor: pointer;
              font-size: 12px;
              font-weight: 600;
              vertical-align: baseline;
              margin: 0 3px;
              padding: 0;
              transition: all 0.2s ease;
              position: relative;
              top: 2px;
            " onmouseover="this.style.background='rgba(251, 146, 60, 0.3)'; this.style.transform='scale(1.15)'"
               onmouseout="this.style.background='rgba(251, 146, 60, 0.2)'; this.style.transform='scale(1)'"
               title="Payment Information">
              <svg xmlns="http://www.w3.org/2000/svg" width="11" height="11" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="12" cy="12" r="10"/>
                <line x1="12" y1="16" x2="12" y2="12"/>
                <line x1="12" y1="8" x2="12.01" y2="8"/>
              </svg>
            </button>
            for this class.
          </p>
          
          <button id="closeDialogBtn" style="
            width: 100%;
            padding: 14px 24px;
            background: linear-gradient(135deg, rgba(251, 146, 60, 0.9), rgba(249, 115, 22, 0.9));
            border: 1px solid rgba(251, 146, 60, 0.5);
            border-radius: 12px;
            color: white;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
          " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 8px 20px rgba(251, 146, 60, 0.4)'"
             onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='none'">
            Got it
          </button>
        </div>
      ` : `
        <div style="text-align: center;">
          <div style="
            width: 80px;
            height: 80px;
            margin: 0 auto 20px;
            border-radius: 20px;
            background: linear-gradient(135deg, rgba(56, 189, 248, 0.2), rgba(14, 165, 233, 0.1));
            border: 1px solid rgba(56, 189, 248, 0.4);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 40px;
          ">🔒</div>
          
          <h3 style="
            color: rgba(255, 255, 255, 0.95);
            font-size: 1.5rem;
            font-weight: 600;
            margin: 0 0 12px 0;
            letter-spacing: -0.02em;
          ">Note Locked</h3>
          
          <p style="
            color: rgba(255, 255, 255, 0.75);
            font-size: 1rem;
            line-height: 1.6;
            margin: 0 0 28px 0;
          ">
            This note is locked. Please complete payment
            <button id="paymentInfoBtn" style="
              display: inline-flex;
              align-items: center;
              justify-content: center;
              width: 18px;
              height: 18px;
              border-radius: 50%;
              background: rgba(56, 189, 248, 0.2);
              border: 1px solid rgba(56, 189, 248, 0.4);
              color: rgba(56, 189, 248, 0.9);
              cursor: pointer;
              font-size: 12px;
              font-weight: 600;
              vertical-align: baseline;
              margin: 0 3px;
              padding: 0;
              transition: all 0.2s ease;
              position: relative;
              top: 2px;
            " onmouseover="this.style.background='rgba(56, 189, 248, 0.3)'; this.style.transform='scale(1.15)'"
               onmouseout="this.style.background='rgba(56, 189, 248, 0.2)'; this.style.transform='scale(1)'"
               title="Payment Information">
              <svg xmlns="http://www.w3.org/2000/svg" width="11" height="11" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="12" cy="12" r="10"/>
                <line x1="12" y1="16" x2="12" y2="12"/>
                <line x1="12" y1="8" x2="12.01" y2="8"/>
              </svg>
            </button>
            for <strong style="color: rgba(255, 255, 255, 0.95);">${classDate}</strong> class to unlock.
          </p>
          
          <button id="closeDialogBtn" style="
            width: 100%;
            padding: 14px 24px;
            background: linear-gradient(135deg, rgba(56, 189, 248, 0.9), rgba(14, 165, 233, 0.9));
            border: 1px solid rgba(56, 189, 248, 0.5);
            border-radius: 12px;
            color: white;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
          " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 8px 20px rgba(56, 189, 248, 0.4)'"
             onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='none'">
            Got it
          </button>
        </div>
      `;
      
      dialog.innerHTML = dialogContent;
      
      overlay.appendChild(dialog);
      document.body.appendChild(overlay);
      
      // Payment info button handler
      document.getElementById('paymentInfoBtn').addEventListener('click', (e) => {
        e.stopPropagation();
        showPaymentInfoModal();
      });
      
      // Close handlers - PERFORMANCE: Instant close + collapse note
      const closeDialog = () => {
        // Collapse the note immediately if it was passed in
        if (noteItem) {
          noteItem.classList.add('note-collapsed');
          noteItem.classList.remove('note-expanded');
          const attachmentsDiv = noteItem.querySelector('.note-attachments');
          const indicator = noteItem.querySelector('.note-expand-indicator');
          if (attachmentsDiv) attachmentsDiv.style.display = 'none';
          if (indicator) indicator.innerHTML = '▼';
        }
        // Remove overlay instantly
        overlay.remove();
      };
      
      document.getElementById('closeDialogBtn').addEventListener('click', closeDialog);
      overlay.addEventListener('click', (e) => {
        if (e.target === overlay) closeDialog();
      });
      
      // Add animations
      if (!document.querySelector('#dialogAnimations')) {
        const style = document.createElement('style');
        style.id = 'dialogAnimations';
        style.textContent = `
          @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
          }
          @keyframes fadeOut {
            from { opacity: 1; }
            to { opacity: 0; }
          }
          @keyframes slideUp {
            from { 
              opacity: 0;
              transform: translateY(20px) scale(0.95);
            }
            to { 
              opacity: 1;
              transform: translateY(0) scale(1);
            }
          }
        `;
        document.head.appendChild(style);
      }
    }
    
    // Show dialog for absent students
    function showAbsentNoteDialog(classDate, noteItem = null) {
      // Create modal overlay
      const overlay = document.createElement('div');
      overlay.style.cssText = `
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.75);
        backdrop-filter: blur(8px);
        -webkit-backdrop-filter: blur(8px);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10000;
        animation: fadeIn 0.15s ease;
      `;
      
      // Create dialog
      const dialog = document.createElement('div');
      dialog.style.cssText = `
        background: linear-gradient(135deg, rgba(30, 41, 59, 0.95), rgba(15, 23, 42, 0.98));
        border: 1px solid rgba(148, 163, 184, 0.3);
        border-radius: 24px;
        padding: 32px;
        max-width: 440px;
        width: 90%;
        box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
        backdrop-filter: blur(12px);
        -webkit-backdrop-filter: blur(12px);
        animation: slideUp 0.2s ease;
      `;
      
      dialog.innerHTML = `
        <div style="text-align: center;">
          <div style="
            width: 80px;
            height: 80px;
            margin: 0 auto 20px;
            border-radius: 20px;
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.2), rgba(220, 38, 38, 0.1));
            border: 1px solid rgba(239, 68, 68, 0.4);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 40px;
          ">🚫</div>
          
          <h3 style="
            color: rgba(255, 255, 255, 0.95);
            font-size: 1.5rem;
            font-weight: 600;
            margin: 0 0 12px 0;
            letter-spacing: -0.02em;
          ">Note Not Available</h3>
          
          <p style="
            color: rgba(255, 255, 255, 0.75);
            font-size: 1rem;
            line-height: 1.6;
            margin: 0 0 28px 0;
          ">
            You were marked absent for <strong style="color: rgba(255, 255, 255, 0.95);">${classDate}</strong>. 
            Notes for this date are not accessible.
          </p>
          
          <button id="closeDialogBtn" style="
            width: 100%;
            padding: 14px 24px;
            border: none;
            border-radius: 12px;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.2), rgba(118, 75, 162, 0.15));
            color: rgba(255, 255, 255, 0.95);
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 1px solid rgba(102, 126, 234, 0.3);
          " onmouseover="this.style.background='linear-gradient(135deg, rgba(102, 126, 234, 0.3), rgba(118, 75, 162, 0.2))'; this.style.transform='translateY(-1px)'; this.style.boxShadow='0 4px 12px rgba(102, 126, 234, 0.3)'"
             onmouseout="this.style.background='linear-gradient(135deg, rgba(102, 126, 234, 0.2), rgba(118, 75, 162, 0.15))'; this.style.transform='translateY(0)'; this.style.boxShadow='none'">
            Got It
          </button>
        </div>
      `;
      
      overlay.appendChild(dialog);
      document.body.appendChild(overlay);
      
      // Close handlers - PERFORMANCE: Instant close + collapse note
      const closeDialog = () => {
        // Collapse the note immediately if it was passed in
        if (noteItem) {
          noteItem.classList.add('note-collapsed');
          noteItem.classList.remove('note-expanded');
          const attachmentsDiv = noteItem.querySelector('.note-attachments');
          const indicator = noteItem.querySelector('.note-expand-indicator');
          if (attachmentsDiv) attachmentsDiv.style.display = 'none';
          if (indicator) indicator.innerHTML = '▼';
        }
        // Remove overlay instantly
        overlay.remove();
      };
      
      document.getElementById('closeDialogBtn').addEventListener('click', closeDialog);
      overlay.addEventListener('click', (e) => {
        if (e.target === overlay) closeDialog();
      });
    }
    
    // Payment Information Modal
    function showPaymentInfoModal() {
      const overlay = document.createElement('div');
      overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.7);
        backdrop-filter: blur(8px);
        -webkit-backdrop-filter: blur(8px);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10001;
        animation: fadeIn 0.2s ease;
      `;
      
      const modal = document.createElement('div');
      modal.style.cssText = `
        max-width: 380px;
        width: 90%;
        max-height: 75vh;
        overflow-y: auto;
        background: linear-gradient(145deg, rgba(30, 41, 59, 0.95), rgba(51, 65, 85, 0.95));
        border: 1px solid rgba(148, 163, 184, 0.3);
        border-radius: 20px;
        padding: 24px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        backdrop-filter: blur(14px);
        -webkit-backdrop-filter: blur(14px);
        animation: slideUp 0.3s ease;
      `;
      
      modal.innerHTML = `
        <div style="text-align: center;">
          <h3 style="
            color: rgba(255, 255, 255, 0.95);
            font-size: 1.3rem;
            font-weight: 600;
            margin: 0 0 20px 0;
            letter-spacing: -0.02em;
          ">Payment Information</h3>
          
          <div style="
            background: linear-gradient(135deg, rgba(118, 75, 162, 0.15), rgba(102, 126, 234, 0.1));
            border: 1px solid rgba(118, 75, 162, 0.3);
            border-radius: 14px;
            padding: 20px;
            margin-bottom: 20px;
            text-align: center;
          ">
            <p style="
              margin: 0 0 8px 0;
              font-size: 15px;
              color: rgba(255, 255, 255, 0.85);
              font-weight: 600;
            ">
              Send Money with <span style="color: #c084fc">Zelle®</span>
            </p>
            <p style="
              margin: 0 0 12px 0;
              font-size: 13px;
              color: rgba(255, 255, 255, 0.7);
            ">
              Scan in your banking app to pay
            </p>
            
            <div style="margin: 12px 0;">
              <p style="
                margin: 0 0 4px 0;
                font-size: 16px;
                font-weight: 600;
                color: rgba(255, 255, 255, 0.95);
              ">Arnoma</p>
              <p style="
                margin: 0 0 12px 0;
                font-size: 15px;
                color: rgba(255, 255, 255, 0.8);
              ">909-300-5155</p>
            </div>
            
            <img
              src="https://raw.githubusercontent.com/easylearnrn-hash/ARNOMA/main/Arnoma%20Zelle.JPG"
              alt="Zelle QR Code"
              style="
                max-width: 160px;
                width: 100%;
                height: auto;
                border-radius: 10px;
                margin: 12px auto;
                display: block;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
              "
            />
            
            <p style="
              margin: 12px 0 0 0;
              font-size: 13px;
              color: rgba(192, 132, 252, 0.9);
              font-weight: 600;
            ">Zelle</p>
          </div>
          
          <div style="
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.15), rgba(220, 38, 38, 0.1));
            border: 1px solid rgba(239, 68, 68, 0.3);
            border-radius: 12px;
            padding: 16px;
            margin: 0 0 20px 0;
            text-align: left;
          ">
            <p style="
              color: rgba(255, 255, 255, 0.95);
              font-size: 14px;
              font-weight: 600;
              margin: 0 0 10px 0;
            ">⚠️ Important: Include Class Date</p>
            <p style="
              color: rgba(255, 255, 255, 0.8);
              font-size: 13px;
              line-height: 1.6;
              margin: 0;
            ">
              In the Zelle <strong>memo/description field</strong>, you must include the <strong>exact class date</strong> you want to access.<br><br>
              <span style="color: rgba(255, 255, 255, 0.95); font-weight: 600;">Example:</span> "Dec 13, 2025" or "12/13/2025"<br><br>
              Without the date in your payment memo, the system cannot automatically unlock your notes.
            </p>
          </div>
          
          <button id="closePaymentInfoBtn" style="
            width: 100%;
            padding: 12px 20px;
            background: linear-gradient(135deg, rgba(118, 75, 162, 0.9), rgba(102, 126, 234, 0.9));
            border: 1px solid rgba(118, 75, 162, 0.5);
            border-radius: 12px;
            color: white;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
          " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 8px 20px rgba(118, 75, 162, 0.4)'"
             onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='none'">
            Close
          </button>
        </div>
      `;
      
      overlay.appendChild(modal);
      document.body.appendChild(overlay);
      
      // Close handlers
      const closeModal = () => {
        overlay.style.animation = 'fadeOut 0.2s ease';
        setTimeout(() => overlay.remove(), 200);
      };
      
      document.getElementById('closePaymentInfoBtn').addEventListener('click', closeModal);
      overlay.addEventListener('click', (e) => {
        if (e.target === overlay) closeModal();
      });
    }
    
    // ==========================================================================
    // SCHEDULE HELPER FUNCTIONS - EXACT COPY FROM CALENDAR.HTML
    // ==========================================================================
    // LA Timezone constant
    const LA_TIMEZONE = 'America/Los_Angeles';
    
    // 🔧 EXACT COPY FROM CALENDAR: Intl.DateTimeFormat for LA timezone
    const laDateTimeFormatter = new Intl.DateTimeFormat('en-US', {
      timeZone: LA_TIMEZONE,
      year: 'numeric',
      month: '2-digit',
      day: '2-digit',
      weekday: 'long',
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit',
      hour12: false,
    });
    
    // 🔧 EXACT COPY FROM CALENDAR: Get LA date parts
    function getLAParts(dateInput) {
      const date = dateInput instanceof Date ? dateInput : new Date(dateInput);
      if (isNaN(date.getTime())) return null;
      const parts = {};
      laDateTimeFormatter.formatToParts(date).forEach(part => {
        parts[part.type] = part.value;
      });
      return parts;
    }
    
    // 🔧 EXACT COPY FROM CALENDAR: Get today in LA timezone
    function getTodayLAParts() {
      return getLAParts(new Date());
    }
    
    // Get current date/time in LA timezone
    function getNowLA() {
      const parts = getTodayLAParts();
      if (!parts) return new Date();
      // Create date using LA timezone parts (year, month, day, hour, minute)
      return new Date(
        parseInt(parts.year),
        parseInt(parts.month) - 1,
        parseInt(parts.day),
        parseInt(parts.hour),
        parseInt(parts.minute),
        parseInt(parts.second) || 0
      );
    }
    
    // Normalize day names to full capitalized form
    function normalizeDayName(input) {
      if (!input || typeof input !== 'string') return null;
      const normalized = input.trim().toLowerCase();
      const dayMap = {
        'sun': 'Sunday', 'sunday': 'Sunday',
        'mon': 'Monday', 'monday': 'Monday',
        'tue': 'Tuesday', 'tues': 'Tuesday', 'tuesday': 'Tuesday',
        'wed': 'Wednesday', 'wednesday': 'Wednesday',
        'thu': 'Thursday', 'thur': 'Thursday', 'thurs': 'Thursday', 'thursday': 'Thursday',
        'fri': 'Friday', 'friday': 'Friday',
        'sat': 'Saturday', 'saturday': 'Saturday'
      };
      return dayMap[normalized] || null;
    }
    
    // Normalize time labels to consistent 12-hour format
    function normalizeTimeLabel(input) {
      if (!input || typeof input !== 'string') return '';
      const trimmed = input.trim();
      const match = trimmed.match(/^(\d{1,2}):(\d{2})\s*(AM|PM)$/i);
      if (!match) return trimmed;
      const hours = match[1];
      const minutes = match[2];
      const meridiem = match[3].toUpperCase();
      return `${hours}:${minutes} ${meridiem}`;
    }
    
    // Convert LA time to Yerevan time with DST awareness
    function convertLAtoYerevan(day, time12) {
      const normalizedDay = normalizeDayName(day) || day || 'Sunday';
      const normalizedTime = normalizeTimeLabel(time12);
      
      // Current month to determine DST
      const currentDate = new Date();
      const month = currentDate.getMonth(); // 0-11
      
      // PST to AMT: +12 hours, PDT to AMT: +11 hours
      const isDST = month >= 2 && month < 10; // Mar-Oct is DST
      const hourDiff = isDST ? 11 : 12;
      
      // Parse 12-hour time
      const timeSource = normalizedTime || time12 || '';
      const timeMatch = timeSource.match(/^(\d{1,2}):(\d{2})\s*(AM|PM)$/i);
      if (!timeMatch) {
        return { day: normalizedDay, time: timeSource };
      }
      
      let hours = parseInt(timeMatch[1]);
      const minutes = timeMatch[2];
      const meridiem = timeMatch[3].toUpperCase();
      
      // Convert to 24-hour
      if (meridiem === 'PM' && hours !== 12) hours += 12;
      if (meridiem === 'AM' && hours === 12) hours = 0;
      
      // Add hour difference
      hours += hourDiff;
      
      // Day mapping
      const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
      const baseDayIndex = days.indexOf(normalizedDay);
      let newDayIndex = baseDayIndex === -1 ? 0 : baseDayIndex;
      
      // Handle day overflow
      if (hours >= 24) {
        hours -= 24;
        newDayIndex = (newDayIndex + 1) % 7;
      } else if (hours < 0) {
        hours += 24;
        newDayIndex = (newDayIndex - 1 + 7) % 7;
      }
      
      // Convert back to 12-hour format
      const newMeridiem = hours >= 12 ? 'PM' : 'AM';
      let displayHours = hours % 12;
      if (displayHours === 0) displayHours = 12;
      
      return {
        day: days[newDayIndex],
        time: `${displayHours}:${minutes} ${newMeridiem}`,
      };
    }
    
    // Convert LA time to Miami time (ET is +3 hours from PT)
    function convertLAtoMiami(day, time12) {
      const normalizedDay = normalizeDayName(day) || day || 'Sunday';
      const normalizedTime = normalizeTimeLabel(time12);
      
      // LA to Miami is always +3 hours
      const hourDiff = 3;
      
      // Parse 12-hour time
      const timeSource = normalizedTime || time12 || '';
      const timeMatch = timeSource.match(/^(\d{1,2}):(\d{2})\s*(AM|PM)$/i);
      if (!timeMatch) {
        return { day: normalizedDay, time: timeSource };
      }
      
      let hours = parseInt(timeMatch[1]);
      const minutes = timeMatch[2];
      const meridiem = timeMatch[3].toUpperCase();
      
      // Convert to 24-hour
      if (meridiem === 'PM' && hours !== 12) hours += 12;
      if (meridiem === 'AM' && hours === 12) hours = 0;
      
      // Add hour difference
      hours += hourDiff;
      
      // Day mapping
      const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
      const baseDayIndex = days.indexOf(normalizedDay);
      let newDayIndex = baseDayIndex === -1 ? 0 : baseDayIndex;
      
      // Handle day overflow
      if (hours >= 24) {
        hours -= 24;
        newDayIndex = (newDayIndex + 1) % 7;
      } else if (hours < 0) {
        hours += 24;
        newDayIndex = (newDayIndex - 1 + 7) % 7;
      }
      
      // Convert back to 12-hour format
      const newMeridiem = hours >= 12 ? 'PM' : 'AM';
      let displayHours = hours % 12;
      if (displayHours === 0) displayHours = 12;
      
      return {
        day: days[newDayIndex],
        time: `${displayHours}:${minutes} ${newMeridiem}`,
      };
    }
    
    // Format schedule elegantly (returns HTML string)
    function formatSchedule(scheduleString, oneTimeSchedules = []) {
      const hasRegularSchedule = scheduleString && scheduleString.trim() !== '';
      const hasOneTimeSchedule = oneTimeSchedules && oneTimeSchedules.length > 0;
      
      if (!hasRegularSchedule && !hasOneTimeSchedule) {
        return '<div class="schedule-empty">No schedule set</div>';
      }
      
      const dayOrder = { Monday: 1, Tuesday: 2, Wednesday: 3, Thursday: 4, Friday: 5, Saturday: 6, Sunday: 7 };
      
      const expandSchedulePart = part => {
        if (!part) return [];
        const trimmed = part.trim();
        if (!trimmed) return [];
        
        const timeMatch = trimmed.match(/(\d{1,2}):(\d{2})\s*(?:AM|PM)/i);
        if (timeMatch) {
          const timeValue = normalizeTimeLabel(timeMatch[0]);
          const daySectionRaw = trimmed.slice(0, timeMatch.index).trim();
          const sanitized = daySectionRaw
            .replace(/\band\b/gi, ' ')
            .replace(/\bat\b/gi, ' ')
            .replace(/\bon\b/gi, ' ')
            .trim();
          
          const chunks = sanitized
            .split(/[\/,&]+/)
            .map(token => token.trim())
            .filter(Boolean);
          
          const normalizedDays = [];
          chunks.forEach(chunk => {
            chunk
              .split(/\s+/)
              .map(token => token.trim())
              .filter(Boolean)
              .forEach(token => {
                const normalized = normalizeDayName(token);
                if (normalized) {
                  normalizedDays.push(normalized);
                }
              });
          });
          
          if (normalizedDays.length) {
            return normalizedDays.map(dayName => ({ day: dayName, time: timeValue }));
          }
          
          if (daySectionRaw) {
            return [{ day: daySectionRaw, time: timeValue }];
          }
        }
        
        const fallbackMatch = trimmed.match(/^(\w+)\s+(.+)$/);
        if (fallbackMatch) {
          return [{ day: fallbackMatch[1], time: fallbackMatch[2].trim() }];
        }
        
        return [{ day: trimmed, time: '' }];
      };
      
      // Parse regular schedules
      let parsed = [];
      if (hasRegularSchedule) {
        const parts = scheduleString
          .split(',')
          .map(part => part.trim())
          .filter(Boolean);
        
        parsed = parts
          .reduce((acc, part) => acc.concat(expandSchedulePart(part)), [])
          .map(entry => {
            const laDay = normalizeDayName(entry.day) || entry.day;
            const laTime = normalizeTimeLabel(entry.time);
            const miami = convertLAtoMiami(laDay, laTime);
            const yerevan = convertLAtoYerevan(laDay, laTime);
            
            return {
              day: laDay,
              time: laTime,
              miamiDay: miami.day,
              miamiTime: miami.time,
              yerevanDay: yerevan.day,
              yerevanTime: yerevan.time,
              order: dayOrder[laDay] || 999,
              isOneTime: false,
            };
          })
          .sort((a, b) => a.order - b.order);
      }
      
      // Add one-time schedules (filter out past ones)
      // Get current time in LA timezone
      const nowLA = getNowLA();
      
      const oneTimeParsed = (oneTimeSchedules || [])
        .filter(schedule => {
          if (!schedule.date) return false; // Skip if no date
          
          // Parse the class date and time
          const classDateParts = schedule.date.split('-');
          if (classDateParts.length !== 3) return false;
          
          // Extract time from schedule.time (e.g., "8:00 AM")
          const timeMatch = schedule.time ? schedule.time.match(/(\d{1,2}):(\d{2})\s*(AM|PM)/i) : null;
          let hours = 0, minutes = 0;
          if (timeMatch) {
            hours = parseInt(timeMatch[1]);
            const minutesPart = parseInt(timeMatch[2]);
            const meridiem = timeMatch[3].toUpperCase();
            if (meridiem === 'PM' && hours !== 12) hours += 12;
            if (meridiem === 'AM' && hours === 12) hours = 0;
            minutes = minutesPart;
          }
          
          // Create class end time (class + 2 hours) in LA timezone
          const classEndTime = new Date(
            parseInt(classDateParts[0]),
            parseInt(classDateParts[1]) - 1,
            parseInt(classDateParts[2]),
            hours + 2, // Add 2 hours for class duration directly
            minutes
          );
          
          // Only show if class hasn't ended yet (compare LA times)
          return nowLA < classEndTime;
        })
        .map(schedule => {
          const laDay = normalizeDayName(schedule.day) || schedule.day;
          const laTime = normalizeTimeLabel(schedule.time);
          const miami = convertLAtoMiami(laDay, laTime);
          const yerevan = convertLAtoYerevan(laDay, laTime);
          
          return {
            day: laDay,
            time: laTime,
            date: schedule.date,
            miamiDay: miami.day,
            miamiTime: miami.time,
            yerevanDay: yerevan.day,
            yerevanTime: yerevan.time,
            order: dayOrder[laDay] || 999,
            isOneTime: true,
          };
        })
        .sort((a, b) => a.order - b.order);
      
      // Combine and render
      const allSchedules = [...parsed, ...oneTimeParsed];
      
      return allSchedules
        .map(({ day, time, miamiDay, miamiTime, yerevanDay, yerevanTime, isOneTime, date }) => {
          if (time) {
            const classType = isOneTime ? 'schedule-card one-time' : 'schedule-card';
            const dateLabel = isOneTime ? `<span class="one-time-date">📅 ${date}</span>` : '';
            
            return `
              <div class="${classType}">
                <div class="time-row">
                  <span class="flag">🇺🇸</span>
                  <span class="day-name">${day}</span>
                  <span class="time-value la-time">${time} LA</span>
                </div>
                
                <div class="time-divider"></div>
                
                <div class="time-row">
                  <span class="flag">🇺🇸</span>
                  <span class="day-name">${miamiDay}</span>
                  <span class="time-value miami-time">${miamiTime} MIA</span>
                </div>
                
                <div class="time-divider"></div>
                
                <div class="time-row">
                  <span class="flag">🇦🇲</span>
                  <span class="day-name">${yerevanDay}</span>
                  <span class="time-value yerevan-time">${yerevanTime}</span>
                </div>
                ${dateLabel}
              </div>`;
          }
          return `<div class="schedule-card">${day}</div>`;
        })
        .join('');
    }

    function buildScheduleSummary(scheduleString, oneTimeSchedules = []) {
      if (scheduleString && typeof scheduleString === 'string' && scheduleString.trim()) {
        return scheduleString.replace(/\s+/g, ' ').trim();
      }
      if (Array.isArray(oneTimeSchedules) && oneTimeSchedules.length > 0) {
        const entries = oneTimeSchedules
          .map(entry => {
            if (!entry) return '';
            const chunks = [];
            if (entry.day) chunks.push(entry.day);
            if (entry.date) chunks.push(entry.date);
            if (entry.time) chunks.push(entry.time);
            return chunks.join(' ').replace(/\s+/g, ' ').trim();
          })
          .filter(Boolean);
        if (entries.length) {
          return entries.join(' • ');
        }
      }
      return 'Not scheduled';
    }

    function setProfileScheduleText(text) {
      const el = document.getElementById('modalStudentSchedule');
      if (!el) return;
      const safeText = text == null ? '' : String(text).trim();
      el.textContent = safeText || 'Not scheduled';
    }
    
    // ==========================================================================
    // END SCHEDULE HELPER FUNCTIONS
    // ==========================================================================
    
    // ==========================================================================
    // SCHEDULE DATA LOADING
    // ==========================================================================
    
    /**
     * Normalizes group codes to canonical uppercase single-letter format.
     * 
     * @param {string|number} value - Raw group value (e.g., "Group C", "group a", "B")
     * @returns {string} Normalized uppercase letter (A-F) or empty string
     * 
     * @description
     * Handles various group code formats from database and user input:
     * - Strips "group" prefix (case-insensitive)
     * - Removes all non-alphanumeric characters
     * - Converts to uppercase
     * - Returns first character only
     * 
     * Critical for consistency across modules (Student-Manager, Payment-Records, Calendar).
     * 
     * @example
     * canonicalizeGroupCode("Group C")  // → "C"
     * canonicalizeGroupCode("group a")  // → "A"
     * canonicalizeGroupCode("B")        // → "B"
     * canonicalizeGroupCode(" c ")      // → "C"
     * canonicalizeGroupCode("")         // → ""
     */
    function canonicalizeGroupCode(value) {
      if (!value) return '';
      const raw = value.toString().trim();
      if (!raw) return '';
      let normalized = raw.replace(/^group\s+/i, ''); // Strip "group" prefix
      normalized = normalized.replace(/[^a-z0-9]/gi, ''); // Remove non-alphanumeric
      return normalized.toUpperCase(); // Uppercase
    }
    
    function getStudentGroup(student) {
      if (!student) return null;
      const rawGroup = student.group_name || student.group_letter || student.group || null;
      const normalized = canonicalizeGroupCode(rawGroup);
      debugDebug('🎯 Student group:', { raw: rawGroup, normalized: normalized });
      return normalized;
    }
    
    // Get group schedule from Supabase (with caching for performance)
    async function getGroupSchedule(groupName) {
      if (!groupName || !supabase) {
        console.warn('❌ Cannot get schedule - missing groupName or supabase:', { groupName, hasSupabase: !!supabase });
        debugDebug('❌ No groupName or supabase:', { groupName, hasSupabase: !!supabase });
        return null;
      }
      
      try {
        // Normalize group name for consistent lookup
        const normalizedGroup = canonicalizeGroupCode(groupName);
        console.log('🔍 Looking up group schedule:', { original: groupName, normalized: normalizedGroup });
        debugDebug('🔍 Looking up group schedule:', { original: groupName, normalized: normalizedGroup });
        
        // Check cache first
        const cacheKey = `group-schedule-${normalizedGroup}`;
        const cached = getCachedData(cacheKey);
        if (cached) {
          console.log('⚡ Using cached group schedule for:', normalizedGroup);
          debugDebug('⚡ Using cached group schedule:', normalizedGroup);
          return cached;
        }
        
        // Fetch all groups and find the match (more reliable than .eq() with various column names)
        const { data: allGroups, error } = await supabaseClient
          .from('groups')
          .select('*');
        
        if (error) {
          console.error('❌ Error loading groups:', error);
          return null;
        }
        
        if (!allGroups || allGroups.length === 0) {
          console.error('⚠️ CRITICAL: No groups found in database - Group Manager may not have saved any groups yet');
          console.log('💡 SOLUTION: Admin needs to open Group-Manager.html and create/save groups with schedules');
          debugDebug('⚠️ No groups found in database');
          return null;
        }
        
        console.log('📚 All groups in database:', allGroups.map(g => ({
          group_code: g.group_code,
          group_name: g.group_name,
          name: g.name,
          active: g.active,
          schedule: g.schedule
        })));
        
        // Find matching group (check multiple possible fields)
        const matchingGroup = allGroups.find(g => {
          const gCode = canonicalizeGroupCode(g.group_code || g.group_name || g.name || '');
          return gCode === normalizedGroup;
        });
        
        if (!matchingGroup) {
          console.error('⚠️ No matching group found for:', normalizedGroup);
          console.log('Available groups:', allGroups.map(g => ({
            group_code: g.group_code,
            group_name: g.group_name,
            name: g.name,
            normalized: canonicalizeGroupCode(g.group_code || g.group_name || g.name || '')
          })));
          debugDebug('⚠️ No matching group found for:', normalizedGroup, 'Available groups:', allGroups.map(g => ({
            group_code: g.group_code,
            group_name: g.group_name,
            name: g.name
          })));
          return null;
        }
        
        console.log('✅ Found matching group:', matchingGroup);
        debugDebug('✅ Found group schedule:', matchingGroup);
        
        const scheduleData = {
          schedule: matchingGroup.schedule || '',
          one_time_schedules: matchingGroup.one_time_schedules || [],
          updated_at: matchingGroup.updated_at ? new Date(matchingGroup.updated_at) : null
        };
        
        // Cache the result
        setCachedData(cacheKey, scheduleData);
        
        return scheduleData;
      } catch (e) {
        console.error('Exception loading group schedule:', e);
        return null;
      }
    }
    
    // Compute next class date/time from schedule
    function computeNextClass(schedule) {
      if (!schedule || (!schedule.schedule && !schedule.one_time_schedules?.length)) {
        return null;
      }
      
      const now = getNowLA();
      const currentDay = now.getDay(); // 0 = Sunday, 6 = Saturday
      const currentTime = now.getHours() * 60 + now.getMinutes();
      
      const dayMap = {
        'Sunday': 0, 'Monday': 1, 'Tuesday': 2, 'Wednesday': 3,
        'Thursday': 4, 'Friday': 5, 'Saturday': 6
      };
      
      let nextClass = null;
      let minDaysDiff = Infinity;
      
      // Parse regular schedule
      if (schedule.schedule && schedule.schedule.trim()) {
        const parts = schedule.schedule.split(',').map(p => p.trim()).filter(Boolean);
        
        parts.forEach(part => {
          const timeMatch = part.match(/(\d{1,2}):(\d{2})\s*(AM|PM)/i);
          if (!timeMatch) return;
          
          const daySection = part.slice(0, timeMatch.index).trim();
          const days = daySection.split(/[\/,&\s]+/).map(d => normalizeDayName(d)).filter(Boolean);
          
          const timeStr = timeMatch[0];
          const timeParsed = timeMatch[0].match(/^(\d{1,2}):(\d{2})\s*(AM|PM)$/i);
          if (!timeParsed) return;
          
          let hours = parseInt(timeParsed[1]);
          const minutes = parseInt(timeParsed[2]);
          const meridiem = timeParsed[3].toUpperCase();
          
          // Convert to 24-hour
          if (meridiem === 'PM' && hours !== 12) hours += 12;
          if (meridiem === 'AM' && hours === 12) hours = 0;
          
          const classTimeInMinutes = hours * 60 + minutes;
          
          days.forEach(dayName => {
            const dayIndex = dayMap[dayName];
            if (dayIndex === undefined) return;
            
            let daysDiff = dayIndex - currentDay;
            
            // If class is today but already passed or in progress (within 2 hours of start), move to next week
            const twoHoursInMinutes = 2 * 60; // 120 minutes
            const timeSinceClass = currentTime - classTimeInMinutes;
            if (daysDiff === 0 && timeSinceClass >= 0 && timeSinceClass < twoHoursInMinutes) {
              // Class is currently in progress, skip to next week
              daysDiff = 7;
            } else if (daysDiff === 0 && classTimeInMinutes <= currentTime) {
              // Class already passed (more than 2 hours ago), move to next week
              daysDiff = 7;
            }
            
            // If day is in the past this week, move to next week
            if (daysDiff < 0) {
              daysDiff += 7;
            }
            
            if (daysDiff < minDaysDiff) {
              minDaysDiff = daysDiff;
              
              const nextDate = new Date(now);
              nextDate.setDate(nextDate.getDate() + daysDiff);
              nextDate.setHours(hours, minutes, 0, 0);
              
              nextClass = {
                date: nextDate,
                day: dayName,
                time: timeStr,
                isOneTime: false
              };
            }
          });
        });
      }
      
      // Check one-time schedules
      if (schedule.one_time_schedules && schedule.one_time_schedules.length > 0) {
        schedule.one_time_schedules.forEach(oneTime => {
          if (!oneTime.date || !oneTime.time) return;
          
          const dateParts = oneTime.date.split('-');
          if (dateParts.length !== 3) return;
          
          const timeMatch = oneTime.time.match(/^(\d{1,2}):(\d{2})\s*(AM|PM)$/i);
          if (!timeMatch) return;
          
          let hours = parseInt(timeMatch[1]);
          const minutes = parseInt(timeMatch[2]);
          const meridiem = timeMatch[3].toUpperCase();
          
          if (meridiem === 'PM' && hours !== 12) hours += 12;
          if (meridiem === 'AM' && hours === 12) hours = 0;
          
          const oneTimeDate = new Date(
            parseInt(dateParts[0]),
            parseInt(dateParts[1]) - 1,
            parseInt(dateParts[2]),
            hours,
            minutes,
            0
          );
          
          // Only consider future one-time classes
          if (oneTimeDate > now) {
            const daysDiff = Math.floor((oneTimeDate - now) / (1000 * 60 * 60 * 24));
            
            if (daysDiff < minDaysDiff) {
              minDaysDiff = daysDiff;
              nextClass = {
                date: oneTimeDate,
                day: oneTime.day,
                time: oneTime.time,
                isOneTime: true
              };
            }
          }
        });
      }
      
      return nextClass;
    }
    
    /**
     * Starts a real-time countdown timer to the next scheduled class.
     * 
     * @param {Date|null} nextClassDate - JavaScript Date object for next class start time
     * @returns {void}
     * 
     * @description
     * Creates an interval that updates every second to display:
     * - Days, hours, minutes, seconds until class starts
     * - "Class in Progress" if class started within last 2 hours
     * - "Class has ended" if more than 2 hours past start time
     * - Empty schedule message if no nextClassDate provided
     * 
     * Uses Los Angeles timezone (America/Los_Angeles) for all calculations.
     * Automatically clears any existing countdown before starting new one.
     * 
     * @example
     * const nextClass = calculateNextClass(schedule);
     * startCountdown(nextClass.date);
     */
    function startCountdown(nextClassDate) {
      // Clear any existing countdown
      if (countdownInterval) {
        clearInterval(countdownInterval);
        countdownInterval = null;
      }
      
      if (!nextClassDate) {
        document.getElementById('nextClassTimer').innerHTML = `
          <div class="schedule-empty" style="padding: 20px; margin: 0;">
            No upcoming classes at this time.<br>
            Please check for schedule updates.
          </div>
        `;
        return;
      }
      
      const updateCountdown = () => {
        const countdownEl = document.getElementById('countdownValue');
        if (!countdownEl) return;

        const now = getNowLA();
        const diff = nextClassDate - now;
        
        // Check if class is in progress (started but less than 2 hours ago)
        const twoHours = 2 * 60 * 60 * 1000; // 2 hours in milliseconds
        if (diff < 0 && Math.abs(diff) < twoHours) {
          // Class is in progress - red and blinking
          countdownEl.textContent = 'Class in Progress';
          countdownEl.style.fontSize = '16px';
          countdownEl.style.color = '#ef4444'; // Red color
          countdownEl.style.animation = 'urgentBlink 1.5s ease-in-out infinite';
          countdownEl.style.fontWeight = '700';
          return;
        }
        
        if (diff <= -twoHours) {
          // Class ended more than 2 hours ago, stop countdown
          intervalManager.clear('countdown');
          countdownEl.textContent = 'Check schedule for next class';
          countdownEl.style.fontSize = '14px';
          countdownEl.style.color = 'rgba(255,255,255,0.6)';
          return;
        }
        
        // Class hasn't started yet - show countdown (reset styles)
        const dayMs = 24 * 60 * 60 * 1000;
        const hourMs = 60 * 60 * 1000;
        const minuteMs = 60 * 1000;
        const thirtyMinMs = 30 * 60 * 1000; // 30 minutes
        
        if (diff >= dayMs) {
          // More than 1 day away - show days + hours
          const days = Math.floor(diff / dayMs);
          const hours = Math.floor((diff % dayMs) / hourMs);
          const dayLabel = `${days} day${days === 1 ? '' : 's'}`;
          const hourLabel = `${hours} hour${hours === 1 ? '' : 's'}`;
          countdownEl.textContent = hours > 0 ? `${dayLabel} ${hourLabel}` : dayLabel;
          countdownEl.style.fontSize = '18px';
        } else if (diff >= thirtyMinMs) {
          // Between 30 minutes and 1 day - show hours only, rounded to 30-min increments
          const totalMinutes = Math.floor(diff / minuteMs);
          const roundedMinutes = Math.ceil(totalMinutes / 30) * 30; // Round up to nearest 30 min
          const hours = Math.floor(roundedMinutes / 60);
          const minutes = roundedMinutes % 60;
          
          if (hours > 0 && minutes > 0) {
            countdownEl.textContent = `${hours}h ${minutes}m`;
          } else if (hours > 0) {
            countdownEl.textContent = `${hours}h`;
          } else {
            countdownEl.textContent = `${minutes}m`;
          }
          countdownEl.style.fontSize = '22px';
        } else {
          // Last 30 minutes - show minute-by-minute countdown (no seconds)
          const minutes = Math.floor(diff / minuteMs);
          
          if (minutes > 0) {
            countdownEl.textContent = `${minutes} minute${minutes === 1 ? '' : 's'}`;
          } else {
            countdownEl.textContent = 'Starting soon';
          }
          countdownEl.style.fontSize = '20px';
          countdownEl.style.color = '#fbbf24'; // Amber color for urgency
          countdownEl.style.fontWeight = '600';
        }

        // Reset styles for non-urgent states
        if (diff >= thirtyMinMs) {
          countdownEl.style.color = '';
          countdownEl.style.animation = '';
          countdownEl.style.fontWeight = '';
        }
      };
      
      // Update immediately
      updateCountdown();
      
      // PERFORMANCE FIX: Update every 30 minutes instead of every 1 second
      // Massive CPU savings - countdown doesn't need frequent updates
      intervalManager.set('countdown', updateCountdown, 1800000); // 30 minutes
    }
    
    // Load schedule change announcements
    async function loadChangeNotes(groupName) {
      if (!groupName || !supabase) {
        document.getElementById('announcementsFeed').innerHTML = 
          '<div class="announcement-empty">No announcements at this time.</div>';
        return;
      }
      
      // Normalize group to single letter (A-F)
      const normalizedGroup = groupName.toString().trim().replace(/group\s*/i, '').toUpperCase().charAt(0);
      if (DEBUG_MODE) debugLog('📢 Loading announcements for Group:', normalizedGroup);
      
      try {
        // Fetch both schedule changes AND note announcements
        const [scheduleData, noteData] = await Promise.all([
          supabaseClient
            .from('schedule_changes')
            .select('*')
            .eq('group_name', groupName)
            .order('created_at', { ascending: false })
            .limit(10),
          supabaseClient
            .from('note_assignments')
            .select('id, class_date, template_id')
            .eq('group_id', normalizedGroup)
            .eq('is_open', true)
            .is('deleted_at', null) // FIX: Use deleted_at column
            .order('class_date', { ascending: false })
            .limit(10)
        ]);
        
        if (scheduleData.error) {
          console.error('❌ Error loading schedule changes:', scheduleData.error);
        }
        
        if (noteData.error) {
          console.error('❌ Error loading note announcements:', noteData.error);
        }
        
        const scheduleChanges = scheduleData.data || [];
        const noteAnnouncements = noteData.data || [];
        
        // Load templates for announcements
        const announcementTemplateIds = noteAnnouncements
          .map(assignment => assignment.template_id)
          .filter(id => !!id);
        const announcementTemplatesById = {};
        if (announcementTemplateIds.length > 0) {
          const { data: announcementTemplates, error: announcementTemplateError } = await supabaseClient
            .from('note_templates')
            .select(`
              id,
              note_title,
              note_folders (
                folder_name,
                icon
              )
            `)
            .in('id', announcementTemplateIds);
          
          if (announcementTemplateError) {
            console.error('❌ Error loading announcement templates:', announcementTemplateError);
          } else {
            announcementTemplates?.forEach(template => {
              announcementTemplatesById[template.id] = template;
            });
          }
        }
        
        if (DEBUG_MODE) debugLog(`✅ Found ${scheduleChanges.length} schedule changes and ${noteAnnouncements.length} note announcements`);
        
        // Combine and sort by date
        const allAnnouncements = [];
        
        // Add schedule changes
        scheduleChanges.forEach(note => {
          const type = note.change_type || 'general';
          let icon = '📢';
          let className = 'announcement-item';
          
          if (type.includes('cancel')) {
            className += ' cancelation';
            icon = '❌';
          } else if (type.includes('reschedule') || type.includes('move')) {
            className += ' reschedule';
            icon = '🔄';
          } else if (type.includes('new') || type.includes('add')) {
            className += ' new-class';
            icon = '✨';
          } else if (type.includes('permanent') || type.includes('change')) {
            className += ' permanent-change';
            icon = '📅';
          }
          
          allAnnouncements.push({
            date: new Date(note.created_at),
            className,
            icon,
            text: note.message || note.description || 'Schedule update'
          });
        });
        
        // Add note announcements
        noteAnnouncements.forEach(assignment => {
          const template = announcementTemplatesById[assignment.template_id];
          const folder = template?.note_folders;
          
          // Skip if template is null (broken foreign key)
          if (!template) {
            console.warn('⚠️ Skipping announcement with missing template:', assignment.id);
            return;
          }
          
          allAnnouncements.push({
            date: new Date(assignment.class_date),
            className: 'announcement-item new-class',
            icon: folder?.icon || '📚',
            text: `Richy Festa added ${template?.note_title || 'New Note'} in ${folder?.folder_name || 'General'}`
          });
        });
        
        // Sort by date (newest first)
        allAnnouncements.sort((a, b) => b.date - a.date);
        
        // Take top 15
        const recentAnnouncements = allAnnouncements.slice(0, 15);
        
        if (recentAnnouncements.length === 0) {
          document.getElementById('announcementsFeed').innerHTML = 
            '<div class="announcement-empty">No announcements at this time.</div>';
          return;
        }
        
        // Render announcements
        const html = recentAnnouncements.map(announcement => {
          const createdDate = announcement.date.toLocaleDateString('en-US', {
            month: 'short',
            day: 'numeric',
            year: 'numeric'
          });
          
          return `
            <div class="${announcement.className}">
              <span class="announcement-icon">${announcement.icon}</span>
              <div style="flex: 1;">
                <div class="announcement-text">${announcement.text}</div>
                <div class="announcement-date">Posted ${createdDate}</div>
              </div>
            </div>
          `;
        }).join('');
        
        document.getElementById('announcementsFeed').innerHTML = html;
      } catch (e) {
        console.error('Exception loading announcements:', e);
        document.getElementById('announcementsFeed').innerHTML = 
          '<div class="announcement-empty">Unable to load announcements.</div>';
      }
    }
    
    // ============================================================
    // END SCHEDULE DATA LOADING FUNCTIONS
    // ============================================================
    
    // Initialize app - Check authentication
    (async function() {
      try {
        // CHECK FOR ADMIN CHAT MODE FIRST - Skip this entire flow if admin chat is active
        const adminChatTokenStr = localStorage.getItem('admin_chat_token') || sessionStorage.getItem('admin_chat_token');
        if (adminChatTokenStr) {
          debugLog('🎯 Admin chat mode detected - skipping normal authentication flow');
          return; // Exit early, let initPortal() handle admin chat mode
        }
        
        // SECURITY: Hide Portal Admin button by default for all users
        // Only show it if user is verified admin from admin_accounts table
        const portalBtn = document.getElementById('portalAdminBtn');
        if (portalBtn) {
          portalBtn.style.display = 'none';
        }
        
        // Check for impersonation mode first
        const urlParams = new URLSearchParams(window.location.search);
        const impersonateId = urlParams.get('impersonate');
        
        debugDebug('🎭 Checking impersonation mode:', { impersonateId });
        
        if (impersonateId) {
          // Load impersonation token from sessionStorage
          const tokenData = sessionStorage.getItem('impersonation_token');
          
          debugDebug('🎭 Impersonation token from sessionStorage:', tokenData);
          
          if (tokenData) {
            impersonationToken = JSON.parse(tokenData);
            
            debugDebug('🎭 Parsed impersonation token:', impersonationToken);
            
            // 🔥 REMOVED TIMEOUT CHECK - impersonation never expires
            // Admin can stay in impersonation mode indefinitely
            // if (impersonationToken.expiresAt < Date.now()) {
            //   alert('Impersonation session has expired. Returning to admin panel.');
            //   exitImpersonation();
            //   return;
            // }
            
            // Validate student ID matches
            if (impersonationToken.studentId != impersonateId) {
              console.error('❌ Student ID mismatch!', { 
                tokenStudentId: impersonationToken.studentId, 
                urlStudentId: impersonateId 
              });
              alert('Invalid impersonation token. Returning to admin panel.');
              exitImpersonation();
              return;
            }
            
            // Enable impersonation mode
            impersonationMode = true;
            
            debugDebug('🎭 Loading student with ID:', impersonateId);
            
            // Load the impersonated student's data
            const { data: student, error } = await supabaseClient
              .from('students')
              .select('*')
              .eq('id', impersonateId)
              .single();
            
            debugDebug('🎭 Loaded student:', student);
            
            if (error || !student) {
              console.error('Impersonated student not found:', error);
              alert('Student not found. Returning to admin panel.');
              exitImpersonation();
              return;
            }
            
            currentStudent = student;
            window.currentStudent = student; // Also set window property
            currentEmail = student.email; // Use student's email for all queries
            
            // Keep banner name in sync with actual record (prevents stale names)
            impersonationToken.studentName = student.name || impersonationToken.studentName;
            impersonationToken.studentId = student.id;
            sessionStorage.setItem('impersonation_token', JSON.stringify(impersonationToken));
            
            // Show impersonation banner
            showImpersonationBanner(impersonationToken);
            
            // Add impersonating class to body
            document.body.classList.add('impersonating');
            
            // FORCE HIDE admin buttons during impersonation
            const portalBtn = document.getElementById('portalAdminBtn');
            if (portalBtn) {
              portalBtn.style.display = 'none';
              portalBtn.disabled = true;
            }
            
            await loadPortalData();
            return;
          } else {
            alert('No valid impersonation token found. Returning to admin panel.');
            exitImpersonation();
            return;
          }
        }
        
        // ---------- Admin Detection & Verification ----------
        // Normal authentication flow (non-impersonation)
        // Check if user is authenticated via Supabase Auth
        const { data: { session } } = await supabaseClient.auth.getSession();
        
        if (session && session.user) {
          currentEmail = session.user.email;
          
          // First, try to find student record by email
          const { data: studentRecord, error: studentError } = await supabaseClient
            .from('students')
            .select('*')
            .eq('email', currentEmail)
            .single();
          
          // Check if admin by verifying against admin_accounts table
          const { data: adminAccounts, error: adminError } = await supabaseClient
            .from('admin_accounts')
            .select('*')
            .eq('email', currentEmail)
            .maybeSingle(); // Use maybeSingle() instead of single() - returns null if not found
          
          // Determine if user is admin
          // Admin must be in admin_accounts table AND not have a student record
          const isAdminUser = adminAccounts && !adminError && !studentRecord;
          
          if (isAdminUser) {
            isAdmin = true;
            
            // Show Portal Admin button for admin
            const portalBtn = document.getElementById('portalAdminBtn');
            if (portalBtn) {
              portalBtn.style.display = 'flex';
            }
            
            // For admin, load any student (can be selected later)
            // For now, load first student as default
            const { data: students, error } = await supabaseClient
              .from('students')
              .select('*')
              .limit(1)
              .single();
            
            if (error) {
              console.error('Error loading student data:', error);
              alert('No students found in database');
              return;
            }
            
            currentStudent = students;
            window.currentStudent = students; // Also set window property
            await loadPortalData();
          } else if (studentRecord) {
            // Regular student login - must have student record
            isAdmin = false;
            
            // FORCE HIDE admin buttons for students
            const portalBtn = document.getElementById('portalAdminBtn');
            if (portalBtn) {
              portalBtn.style.display = 'none';
              portalBtn.remove(); // Remove from DOM entirely for security
            }
            
            currentStudent = studentRecord;
            window.currentStudent = studentRecord; // Also set window property
            await loadPortalData();
          } else {
            // No student record and not admin - deny access
            console.error('Access denied - no student or admin record found for:', currentEmail);
            await supabaseClient.auth.signOut();
            window.location.href = 'index.html';
            return;
          }
        } else {
          // No session - redirect to login
          window.location.href = 'index.html';
        }
      } catch (error) {
        console.error('Authentication error:', error);
        window.location.href = 'index.html';
      }
    })();
    
    /**
     * Main portal data loader - orchestrates loading all student dashboard data.
     * 
     * @async
     * @returns {Promise<void>}
     * 
     * @description
     * OPTIMIZED LOADING STRATEGY:
     * 1. Validates currentStudent exists
     * 2. Shows basic student info IMMEDIATELY (name, welcome message)
     * 3. Loads everything else IN PARALLEL (non-blocking):
     *    - Payment history
     *    - Classroom notes
     *    - Systems progress
     * 
     * This ensures students see the page instantly and can access Practice Tests
     * while data loads in the background.
     * 
     * Handles errors by signing out user and redirecting to login.
     * 
     * @throws {Error} If student data unavailable or database queries fail
     * 
     * @example
     * // Called after successful authentication
     * await loadPortalData();
     */
    
    // ==========================================================================
    // ALERT FUNCTIONS
    // ==========================================================================
    
    let currentAlertIndex = 0;
    let studentAlerts = [];
    
    async function loadStudentAlerts() {
      debugLog('🚀 loadStudentAlerts() CALLED');
      try {
        if (!currentStudent || !currentStudent.id) {
          debugLog('⚠️ No student ID available for alerts');
          return;
        }
        
        debugLog('📢 Loading alerts for student:', currentStudent.id, currentStudent.name);
        
        // CACHE BUSTER: Add timestamp to force fresh query every time
        const cacheBuster = new Date().getTime();
        
        // Fetch all alerts for this student (NO CACHE - always fresh)
        const { data: alerts, error } = await supabaseClient
          .from('student_alerts')
          .select('*')
          .eq('student_id', currentStudent.id)
          .order('created_at', { ascending: false })
          .limit(100); // Reasonable limit
        
        if (error) {
          console.error('❌ Error loading alerts:', error);
          return;
        }
        
        debugLog('📬 Found alerts:', alerts?.length || 0, alerts);
        
        if (!alerts || alerts.length === 0) {
          debugLog('ℹ️ No alerts found for this student');
          return;
        }
        
        const now = new Date();
        
        // Filter alerts based on schedule, expiration, and read status
        studentAlerts = alerts.filter(alert => {
          const maxViews = Number(alert.max_show_count);
          const timesShown = Number(alert.times_shown || 0);
          if (Number.isFinite(maxViews) && maxViews > 0 && timesShown >= maxViews) {
            debugLog('🔁 Skipping alert - max views reached:', alert.id, timesShown, '/', maxViews);
            return false;
          }
          
          // Check expiration
          if (alert.expires_at && new Date(alert.expires_at) < now) {
            debugLog('⏰ Skipping expired alert:', alert.id);
            return false;
          }
          
          // Check schedule
          if (alert.scheduled_for && new Date(alert.scheduled_for) > now) {
            debugLog('📅 Skipping scheduled alert (future):', alert.id);
            return false;
          }
          
          // Check one-time and read status
          if (alert.is_one_time && alert.is_read) {
            debugLog('✓ Skipping one-time read alert:', alert.id);
            return false;
          }
          
          return true;
        });
        
        debugLog('✅ Filtered alerts to show:', studentAlerts.length);
        
        // Show alerts that should display on open
        const onOpenAlerts = studentAlerts.filter(a => a.show_on_open && !a.is_read);
        debugLog('🔔 Show-on-open unread alerts:', onOpenAlerts.length);
        
        if (onOpenAlerts.length > 0) {
          currentAlertIndex = 0;
          studentAlerts = onOpenAlerts;
          debugLog('🎯 Showing first alert:', studentAlerts[0].id);
          showAlert(studentAlerts[0]);
        } else if (studentAlerts.length > 0) {
          debugLog('ℹ️ Alerts exist but none marked as show-on-open or all read');
        }
        
      } catch (error) {
        console.error('❌ Error in loadStudentAlerts:', error);
      }
    }
    
    function showAlert(alert) {
      if (!alert) return;
      
      const modal = document.getElementById('alertModal');
      const content = document.getElementById('alertContent');
      
      // Build alert HTML
      let html = `
        <div style="text-align: center; margin-bottom: 24px;">
          <div style="font-size: 48px; margin-bottom: 16px;">
            ${alert.alert_type === 'urgent' ? '🚨' : alert.alert_type === 'info' ? 'ℹ️' : '📢'}
          </div>
          <h3 style="font-size: 22px; font-weight: 700; color: white; margin-bottom: 12px;">
            ${alert.alert_type === 'urgent' ? 'Urgent Message' : alert.alert_type === 'info' ? 'Information' : 'Announcement'}
          </h3>
        </div>
        
        <div style="background: rgba(255, 255, 255, 0.05); border-radius: 16px; padding: 24px; margin-bottom: 24px;">
          <p style="font-size: 16px; line-height: 1.6; color: rgba(255, 255, 255, 0.9); white-space: pre-wrap;">
            ${alert.message}
          </p>
        </div>
      `;
      
      // Add question if exists
      if (alert.has_question && alert.question_text && !alert.student_answer) {
        html += `
          <div style="background: rgba(102, 126, 234, 0.1); border: 2px solid rgba(102, 126, 234, 0.3); border-radius: 16px; padding: 24px; margin-bottom: 24px;">
            <p style="font-size: 15px; font-weight: 600; color: #8ab4ff; margin-bottom: 16px;">
              ${alert.question_text}
            </p>
            <div style="display: flex; gap: 12px; justify-content: center;">
              <button onclick="answerAlertQuestion(${alert.id}, '${alert.answer_option_1}')" style="flex: 1; max-width: 200px; padding: 14px 24px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border: none; border-radius: 12px; color: white; font-size: 15px; font-weight: 700; cursor: pointer; transition: all 0.3s;" onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 8px 20px rgba(102,126,234,0.4)'" onmouseout="this.style.transform=''; this.style.boxShadow=''">
                ${alert.answer_option_1 || 'Yes'}
              </button>
              <button onclick="answerAlertQuestion(${alert.id}, '${alert.answer_option_2}')" style="flex: 1; max-width: 200px; padding: 14px 24px; background: rgba(255, 255, 255, 0.1); border: 2px solid rgba(255, 255, 255, 0.2); border-radius: 12px; color: white; font-size: 15px; font-weight: 700; cursor: pointer; transition: all 0.3s;" onmouseover="this.style.background='rgba(255,255,255,0.15)'; this.style.transform='translateY(-2px)'" onmouseout="this.style.background='rgba(255,255,255,0.1)'; this.style.transform=''">
                ${alert.answer_option_2 || 'No'}
              </button>
            </div>
          </div>
        `;
      } else if (alert.student_answer) {
        html += `
          <div style="background: rgba(16, 185, 129, 0.1); border: 2px solid rgba(16, 185, 129, 0.3); border-radius: 16px; padding: 16px; margin-bottom: 24px; text-align: center;">
            <p style="font-size: 14px; color: #6ee7b7;">
              ✓ You answered: <strong>${alert.student_answer}</strong>
            </p>
          </div>
        `;
      }
      
      // Add navigation buttons if multiple alerts
      if (studentAlerts.length > 1) {
        html += `
          <div style="text-align: center; margin-top: 24px; padding-top: 20px; border-top: 1px solid rgba(255, 255, 255, 0.1);">
            <p style="font-size: 13px; color: rgba(255, 255, 255, 0.5); margin-bottom: 12px;">
              Alert ${currentAlertIndex + 1} of ${studentAlerts.length}
            </p>
            <div style="display: flex; gap: 12px; justify-content: center;">
              ${currentAlertIndex > 0 ? `
                <button onclick="previousAlert()" style="padding: 10px 20px; background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 10px; color: white; font-size: 14px; cursor: pointer;">
                  ← Previous
                </button>
              ` : ''}
              ${currentAlertIndex < studentAlerts.length - 1 ? `
                <button onclick="nextAlert()" style="padding: 10px 20px; background: rgba(102, 126, 234, 0.2); border: 1px solid rgba(102, 126, 234, 0.4); border-radius: 10px; color: #8ab4ff; font-size: 14px; cursor: pointer; font-weight: 600;">
                  Next →
                </button>
              ` : `
                <button onclick="closeCurrentAlert()" style="padding: 10px 20px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border: none; border-radius: 10px; color: white; font-size: 14px; cursor: pointer; font-weight: 600;">
                  Done
                </button>
              `}
            </div>
          </div>
        `;
      } else {
        html += `
          <div style="text-align: center; margin-top: 24px;">
            <button onclick="closeCurrentAlert()" style="padding: 12px 32px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border: none; border-radius: 12px; color: white; font-size: 15px; cursor: pointer; font-weight: 700; transition: all 0.3s;" onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 8px 20px rgba(102,126,234,0.4)'" onmouseout="this.style.transform=''; this.style.boxShadow=''">
              Got it!
            </button>
          </div>
        `;
      }
      
      content.innerHTML = html;
      modal.style.display = 'flex';
      
      // Mark as read
      markAlertAsRead(alert);
    }
    
    async function markAlertAsRead(alertOrId) {
      try {
        const alertData = typeof alertOrId === 'object' ? alertOrId : null;
        const alertId = alertData ? alertData.id : alertOrId;
        if (!alertId) return;
        
        // Check if in impersonation mode - don't track opens for admin viewing as student
        const urlParams = new URLSearchParams(window.location.search);
        const isImpersonating = urlParams.has('impersonate');
        
        if (isImpersonating) {
          debugLog('🎭 Impersonation mode: Skipping alert read tracking');
          return; // Don't mark as read during impersonation
        }

        const updates = {
          is_read: true,
          read_at: new Date().toISOString()
        };

        if (alertData) {
          const currentCount = Number(alertData.times_shown || 0);
          const nextCount = currentCount + 1;
          const maxViews = Number(alertData.max_show_count);
          const hasLimit = Number.isFinite(maxViews) && maxViews > 0;
          updates.times_shown = nextCount;
          if (hasLimit && nextCount >= maxViews) {
            updates.is_read = true;
          }
          alertData.times_shown = nextCount;
        }
        
        await supabaseClient
          .from('student_alerts')
          .update(updates)
          .eq('id', alertId);
      } catch (error) {
        console.error('Error marking alert as read:', error);
      }
    }
    
    async function answerAlertQuestion(alertId, answer) {
      try {
        // Check if in impersonation mode - don't save answers for admin viewing as student
        const urlParams = new URLSearchParams(window.location.search);
        const isImpersonating = urlParams.has('impersonate');
        
        if (isImpersonating) {
          debugLog('🎭 Impersonation mode: Skipping alert answer tracking');
          alert('Impersonation Mode: Answers are not saved when viewing as a student.');
          return;
        }
        
        const { error } = await supabaseClient
          .from('student_alerts')
          .update({ 
            student_answer: answer,
            answered_at: new Date().toISOString()
          })
          .eq('id', alertId);
        
        if (error) throw error;
        
        // Update local alert object
        const alert = studentAlerts[currentAlertIndex];
        if (alert && alert.id === alertId) {
          alert.student_answer = answer;
          alert.answered_at = new Date().toISOString();
          showAlert(alert); // Refresh display
        }
        
      } catch (error) {
        console.error('Error answering question:', error);
        alert('Failed to save answer. Please try again.');
      }
    }
    
    function nextAlert() {
      if (currentAlertIndex < studentAlerts.length - 1) {
        currentAlertIndex++;
        showAlert(studentAlerts[currentAlertIndex]);
      }
    }
    
    function previousAlert() {
      if (currentAlertIndex > 0) {
        currentAlertIndex--;
        showAlert(studentAlerts[currentAlertIndex]);
      }
    }
    
    function closeCurrentAlert() {
      const modal = document.getElementById('alertModal');
      modal.style.display = 'none';
      currentAlertIndex = 0;
      studentAlerts = [];
    }
    
    // Make functions globally available for inline onclick handlers
    window.closeCurrentAlert = closeCurrentAlert;
    window.nextAlert = nextAlert;
    window.previousAlert = previousAlert;
    
    // ==========================================================================
    // PORTAL DATA LOADING
    // ==========================================================================
    
    async function loadPortalData() {
      try {
        perfTimer.mark('loadPortalData START');
        
        // Skip loading portal data if in admin chat mode
        if (currentStudent && currentStudent.isAdminChatMode) {
          debugLog('💬 Admin chat mode - skipping portal data load');
          return;
        }
        
        // Check if currentStudent exists
        if (!currentStudent || !currentStudent.id) {
          console.error('❌ No student data available');
          await supabaseClient.auth.signOut();
          window.location.href = 'index.html';
          return;
        }
        
        // 🚀 PHASE 1: Show basic student info IMMEDIATELY (instant feedback)
        showBasicStudentInfo(currentStudent);
        perfTimer.mark('UI shown (instant)');
        
        // 🚀 PHASE 2: Load ONLY the active section (Overview/Schedule)
        // Don't block on anything - load in background
        loadScheduleForStudent(currentStudent).then(() => {
          sectionLoadedState.overview = true;
          perfTimer.mark('Schedule loaded');
        }).catch(error => {
          console.error('Schedule load failed:', error);
        });
        
        // 🚀 PHASE 3: Load ALL other sections in background (completely non-blocking)
        // These will load when user clicks the tabs
        Promise.allSettled([
          loadPaymentsSection().then(() => {
            sectionLoadedState.payments = true;
            perfTimer.mark('Payments loaded');
          }),
          loadMaterialsSection().then(() => {
            sectionLoadedState.materials = true;
            perfTimer.mark('Materials loaded');
          }),
          loadProgressSection().then(() => {
            sectionLoadedState.progress = true;
            perfTimer.mark('Progress loaded');
          }),
          loadStudentAlerts().then(() => {
            perfTimer.mark('Alerts loaded');
          })
        ]).then(results => {
          results.forEach((result, index) => {
            if (result.status === 'rejected') {
              const sections = ['payments', 'materials', 'progress', 'alerts'];
              console.warn(`${sections[index]} background load failed:`, result.reason);
            }
          });
          perfTimer.summary(); // Show final timing
        });
        
      } catch (error) {
        console.error('Critical error loading portal:', error);
        // Sign out and redirect only on critical failures
        await supabaseClient.auth.signOut();
        window.location.href = 'index.html';
      }

      // AUTO-REFRESH payments every 2 MINUTES (reduced from 30s for performance)
      // Only refresh if tab is visible to save resources
      intervalManager.set('payment-refresh', async () => {
        if (document.hidden) return; // Skip if tab not visible
        
        try {
          await refreshPaymentsData();
        } catch (error) {
          console.warn('Failed to auto-refresh payments:', error);
        }
      }, 120000); // 2 minutes instead of 30 seconds
    }
    
    /**
     * Shows basic student info immediately without waiting for database queries.
     * This makes the page feel instant and interactive.
     */
    function showBasicStudentInfo(student) {
      // Update welcome message immediately
      const welcomeMessage = document.getElementById('welcomeMessage');
      if (welcomeMessage) {
        // Check if Christmas theme is active
        const isChristmasTheme = document.body.classList.contains('christmas-theme');
        const greeting = isChristmasTheme ? 'Merry Christmas,' : 'Welcome,';
        
        welcomeMessage.innerHTML = `
          <span class="title-line">${greeting}</span>
          <span class="name-line">Nurse ${student.name}</span>
        `;
        welcomeMessage.style.opacity = '1';
      }
      
      // Show loading state for stats
      document.getElementById('lastPaid').textContent = '...';
      document.getElementById('lastPaidDate').textContent = 'Loading';
      document.getElementById('totalUnpaid').textContent = '...';
    }
    
    // ==========================================================================
    // PAYMENT FUNCTIONS
    // ==========================================================================

    /**
     * Builds a Set of paid class dates from payment records
     * 
     * CRITICAL: Uses payment.for_class dates (allocated class dates) NOT payment.date (receipt dates)
     * This ensures notes are unlocked based on what class the payment was allocated to,
     * even if admin reassigned the payment to a different date than when it was received.
     * 
     * Example: Payment received Dec 16 but reassigned to Dec 18 → note for Dec 18 unlocks
     * 
     * @param {Array<Object>} payments - Payment objects with dateString (from for_class)
     * @returns {Set<string>} Set of YYYY-MM-DD date strings student has paid for
     */
    function buildPaidDatesSet(payments) {
      console.log('🏗️ Building paidDatesSet from', payments?.length || 0, 'payments');
      
      const filteredPayments = (payments || [])
        .filter(payment => {
          const isPaidOrCredit = payment.status === 'paid' || payment.status === 'credit';
          if (payment.status === 'credit') {
            console.log(`  ✅ Including CREDIT payment: date=${payment.dateString}, amount=${payment.amount}`);
          }
          return isPaidOrCredit;
        });
        
      console.log(`  → Filtered to ${filteredPayments.length} paid/credit payments`);
      
      const paidDates = new Set(
        filteredPayments
          .map(payment => {
            // payment.dateString is already set to for_class in loadPaymentHistory()
            if (payment.dateString) return payment.dateString;
            if (typeof payment.date === 'string') return payment.date.split('T')[0];
            if (payment.date instanceof Date) return payment.date.toISOString().split('T')[0];
            return null;
          })
          .filter(date => date !== null)
      );
      
      console.log(`💰 Built paidDatesSet with ${paidDates.size} dates:`, Array.from(paidDates).sort());
      return paidDates;
    }
    
    // ---------- Payment History Loader ----------
    /**
     * Loads payment history from Supabase by querying multiple tables.
     * 
     * @async
     * @param {Object} student - Student object containing id, name, email, and aliases
     * @param {number} student.id - Primary student ID
     * @param {string} student.name - Student's full name
     * @param {string} student.email - Student's email address
     * @param {Array<string>} [student.aliases] - Alternative names for matching payments
     * 
     * @returns {Promise<Array<Object>>} Array of payment objects sorted by date (newest first)
     * 
     * @description
     * Aggregates payments from THREE sources:
     * 1. **payment_records table**: Manual entries linked by student_id
     * 2. **payments table (by linked_student_id)**: Zelle/automated payments with explicit link
     * 3. **payments table (by name matching)**: Payments matched via resolved_student_name and aliases
     * 
     * Each payment object contains: { date, status, amount, source, id }
     * Status values: 'paid', 'unpaid', 'pending', 'cancelled', 'absent'
     * 
     * @example
     * const payments = await loadPaymentHistory(currentStudent);
     * // Returns: [{ date: Date, status: 'paid', amount: 50, source: 'payment_records', id: 123 }, ...]
     */
    async function loadPaymentHistory(student) {
      // PERFORMANCE: Removed console.log to reduce CPU usage
      debugDebug('Loading payment history for student:', {
        id: student.id,
        name: student.name,
        email: student.email,
        aliases: student.aliases,
        group: student.group_name || student.group
      });
      
      // Check cache first
      // 🔥 CACHE VERSION: Increment this number to bust cache after deduplication fix
      const cacheKey = `payments-v2-${student.id}`;
      const cached = getCachedData(cacheKey);
      if (cached) {
        debugDebug('⚡ Using cached payment history for student:', student.id);
        return cached;
      }
      
      try {
        const allPayments = [];
        
        // 1. Query payment_records table (manual tracking by student_id)
        // PERFORMANCE FIX: Wrap in try-catch to handle RLS permission errors gracefully
        let paymentRecords = [];
        try {
          const { data, error: recordsError } = await supabaseClient
            .from('payment_records')
            .select('*')
            .eq('student_id', student.id)
            .order('date', { ascending: false });
          
          if (recordsError) {
            // RLS permission error expected for students - skip silently
            debugDebug('⚠️ Payment records not accessible (expected for students)');
          } else if (data && data.length > 0) {
            paymentRecords = data;
          }
        } catch (err) {
          // Ignore permission errors
          debugDebug('⚠️ Payment records query failed (expected for students)');
        }
        
        if (paymentRecords.length > 0) {
          const records = paymentRecords.map(record => {
            const dateStr = record.date ? record.date.substring(0, 10) : null;
            const normalizedStatus = (record.status || 'unpaid').toLowerCase();
            return {
              date: new Date(record.date),
              dateString: dateStr, // 🔧 Store original date string
              status: normalizedStatus,
              amount: parseFloat(record.amount) || 0,
              payment_method: record.payment_method,
              notes: record.notes,
              id: record.id,
              source: normalizedStatus === 'absent' ? 'absence' : 'manual'
            };
          });
          allPayments.push(...records);
        }
        
        // 2. Query payments table (Zelle emails) - ULTRA-BROAD MATCHING

        // Parse student emails (could be array or string) - SAFELY
        let studentEmails = [];
        if (Array.isArray(student.email)) {
          studentEmails = student.email.filter(e => e && typeof e === 'string' && e.trim().length > 0);
        } else if (student.email && typeof student.email === 'string' && student.email.trim()) {
          // Check if it's a JSON array string
          const emailStr = student.email.trim();
          if (emailStr.startsWith('[') && emailStr.endsWith(']')) {
            try {
              const parsed = JSON.parse(emailStr);
              studentEmails = Array.isArray(parsed) ? parsed.filter(e => e && typeof e === 'string' && e.trim().length > 0) : [emailStr];
            } catch {
              studentEmails = [emailStr];
            }
          } else {
            studentEmails = [emailStr];
          }
        }
        
        // Parse student aliases (could be array or string) - SAFELY
        let studentAliases = [];
        if (Array.isArray(student.aliases)) {
          studentAliases = student.aliases.filter(a => a && typeof a === 'string' && a.trim().length > 0);
        } else if (student.aliases && typeof student.aliases === 'string' && student.aliases.trim()) {
          const aliasStr = student.aliases.trim();
          if (aliasStr.startsWith('[') && aliasStr.endsWith(']')) {
            try {
              const parsed = JSON.parse(aliasStr);
              studentAliases = Array.isArray(parsed) ? parsed.filter(a => a && typeof a === 'string' && a.trim().length > 0) : [aliasStr];
            } catch {
              studentAliases = [aliasStr];
            }
          } else {
            studentAliases = [aliasStr];
          }
        }
        
        
        // OPTIMIZED: Single query with OR conditions instead of multiple queries
        let paymentsQuery = supabaseClient
          .from('payments')
          .select('*')
          .or(`linked_student_id.eq.${student.id},student_id.eq.${student.id}`)
          .order('email_date', { ascending: false });

        const { data: zellePayments, error: zelleError } = await paymentsQuery;

        if (zelleError) {
          console.error('Error loading Zelle payments:', zelleError);
        } else if (zellePayments && zellePayments.length > 0) {
          debugLog(`📧 Loaded ${zellePayments.length} Zelle payments from database`);
          zellePayments.forEach((p, i) => {
            debugLog(`  Payment ${i+1}: date="${p.date}", email_date="${p.email_date}", payer="${p.payer_name}", amount=$${p.amount}`);
          });
          
          const zelle = zellePayments.map(payment => {
            // 🔧 CRITICAL: Use for_class (allocated class date) instead of email_date (when received)
            // This ensures notes unlock based on WHAT CLASS the payment was assigned to
            // Example: Payment received Dec 16 → Admin reassigns to Dec 18 → Note for Dec 18 unlocks
            // Even if student was absent on Dec 16, if admin allocated payment to Dec 18, they get Dec 18 notes
            const forClassStr = payment.for_class ? payment.for_class.substring(0, 10) : null;
            const dateStr = payment.date ? payment.date.substring(0, 10) : null;
            // Use for_class for payment date if available, otherwise fall back to date
            const classDateStr = forClassStr || dateStr;
            const paymentDate = classDateStr ? new Date(classDateStr + 'T00:00:00') : new Date(payment.email_date);
            debugLog(`  → Using for_class="${payment.for_class}" as payment date for note unlocking`);
            return {
              date: paymentDate,
              dateString: classDateStr, // ✅ THIS IS THE for_class DATE - used for note unlocking!
              status: 'paid', // Zelle payments are always paid
              amount: parseFloat(payment.amount) || 0,
              payment_method: 'Zelle',
              notes: payment.payer_name ? `From: ${payment.payer_name}` : payment.memo,
              id: payment.id,
              source: 'zelle',
              receiptDate: dateStr, // Store original receipt date for reference
              forClass: forClassStr // Store for_class explicitly for debugging
            };
          });
          allPayments.push(...zelle);
        }
        
        // 3. Query credit_payments table (payments applied from student credit balance)
        console.log('🔍 Querying credit_payments for student_id:', student.id);
        const { data: creditPayments, error: creditError } = await supabaseClient
          .from('credit_payments')
          .select('*')
          .eq('student_id', student.id)
          .order('class_date', { ascending: false });
          
        if (creditError) {
          console.error('❌ Error loading credit payments:', creditError);
        } else {
          console.log(`💳 Raw credit_payments from database (${creditPayments?.length || 0} records):`, creditPayments);
          if (creditPayments && creditPayments.length > 0) {
            const credits = creditPayments.map(payment => {
              const dateStr = payment.class_date ? payment.class_date.substring(0, 10) : null;
              console.log(`  → Processing credit payment: class_date=${dateStr}, amount=${payment.amount}`);
              return {
                date: new Date(payment.class_date),
                dateString: dateStr, // 🔧 Store original date string
                status: 'credit', // ✅ CRITICAL: Must be 'credit' not 'paid' to match Calendar logic!
                amount: parseFloat(payment.amount) || 0,
                payment_method: 'Credit Balance',
                notes: payment.balance_after != null ? `Balance after: $${payment.balance_after}` : null,
                id: payment.id,
                source: 'credit' // Mark as credit payment for orange badge
              };
            });
            allPayments.push(...credits);
            console.log(`✅ Added ${credits.length} credit payments to allPayments. Total now: ${allPayments.length}`);
          } else {
            console.log('⚠️ No credit payments found for this student');
          }
        }
        
        // 4. Add absences from student_absences table
        // Load absences - this happens BEFORE deduplication
        let absences = [];
        try {
          const { data, error } = await supabaseClient
            .from('student_absences')
            .select('*')
            .eq('student_id', student.id);
          
          if (!error && data) {
            // Convert absences to payment records with status='absent'
            const absenceRecords = data.map(a => {
              const dateStr = a.class_date ? a.class_date.substring(0, 10) : a.class_date;
              return {
                date: new Date(dateStr + 'T00:00:00'),
                dateString: dateStr,
                status: 'absent',
                amount: 0,
                payment_method: null,
                notes: 'Marked absent',
                id: `absence-${a.id}`,
                source: 'absence'
              };
            });
            allPayments.push(...absenceRecords);
          } else if (error) {
            console.error('⚠️ RLS Error loading absences:', error.message, error);
            debugDebug('⚠️ Error loading absences:', error);
          }
        } catch (err) {
          console.error('⚠️ Network error loading absences:', err);
          debugDebug('⚠️ Could not load absences:', err);
        }
        
        // Sort all payments by date (most recent first)
        allPayments.sort((a, b) => b.date - a.date);
        
        // ---------- DEDUPLICATION: Remove duplicate payments for same date ----------
        // IMPORTANT: Credit payments are NEVER deduplicated (they're separate transactions)
        // Absences ARE deduplicated (same date from student_absences + payment_records = one entry)
        // Only deduplicate Zelle/manual payments if they match on the same day
  const deduplicatedPayments = [];
  const seenDates = new Map(); // Track date -> payment mapping (excluding credits)
  const seenAbsenceDates = new Set(); // Track absence dates to prevent duplicates
        
        for (const payment of allPayments) {
          const dateKey = payment.date.toISOString().split('T')[0]; // YYYY-MM-DD format
          
          // ⚠️ ALWAYS include credit payments (don't deduplicate - they're separate transactions)
          if (payment.source === 'credit') {
            deduplicatedPayments.push(payment);
            continue;
          }
          
          // 🔥 FIX: Deduplicate absences (same date from student_absences + payment_records)
          const isAbsentStatus = (payment.status || '').toLowerCase() === 'absent';
          if (payment.source === 'absence' || isAbsentStatus) {
            if (seenAbsenceDates.has(dateKey)) {
              debugDebug(`⚠️ Skipping duplicate absence for ${dateKey}`);
              continue; // Skip duplicate absence
            }
            seenAbsenceDates.add(dateKey);
            deduplicatedPayments.push(payment);
            continue;
          }
          
          if (!seenDates.has(dateKey)) {
            // First payment for this date - add it
            deduplicatedPayments.push(payment);
            seenDates.set(dateKey, payment);
          } else {
            // Duplicate date found - keep manual record over zelle if both exist
            const existing = seenDates.get(dateKey);
            if (payment.source === 'manual' && existing.source === 'zelle') {
              // Replace zelle with manual record (manual is more authoritative)
              const index = deduplicatedPayments.indexOf(existing);
              if (index !== -1) {
                deduplicatedPayments[index] = payment;
                seenDates.set(dateKey, payment);
              }
            }
            // Otherwise skip this duplicate
            debugDebug(`⚠️ Skipping duplicate payment for ${dateKey}:`, {
              kept: existing.source,
              skipped: payment.source,
              amount: payment.amount
            });
          }
        }
        
        debugDebug('💰 Total payments found:', {
          manual: paymentRecords?.length || 0,
          zelle: zellePayments?.length || 0,
          credit: creditPayments?.length || 0,
          totalBeforeDedup: allPayments.length,
          totalAfterDedup: deduplicatedPayments.length,
          duplicatesRemoved: allPayments.length - deduplicatedPayments.length,
          firstPayment: deduplicatedPayments[0]
        });
        
        // PERFORMANCE: Removed console.log statements
        
        // Cache the result
        setCachedData(cacheKey, deduplicatedPayments);
        
        return deduplicatedPayments;
        
      } catch (error) {
        console.error('Exception loading payment history:', error);
        return [];
      }
    }
    
    /**
     * 🔴 Calculate unpaid classes based on student's schedule
     * This matches the Calendar's red dot logic - counts PAST classes without payment
     * 
     * @param {Object} student - Student object with group_name, price_per_class, start_date
     * @param {Array} payments - Array of payment records
     * @param {Object} groupSchedule - Group schedule with days array
     * @returns {Object} { unpaidAmount, unpaidClasses: [] }
     */
    async function calculateUnpaidFromSchedule(student, payments, groupScheduleData) {
      debugDebug('🔴 Calculating unpaid classes from schedule:', {
        student: student.name,
        groupScheduleData: groupScheduleData,
        payments: payments.length
      });
      
      const studentGroup = student.group_name || student.group_letter || student.group;
      if (!studentGroup || !groupScheduleData || !groupScheduleData.schedule) {
        debugDebug('⚠️ No schedule data to calculate unpaid classes');
        return { unpaidAmount: 0, unpaidClasses: [] };
      }
      
      const pricePerClass = parseFloat(student.price_per_class) || 50;
      
      // 🔧 FIX: Get LA timezone date/time using Intl.DateTimeFormat (EXACT CALENDAR METHOD)
      const nowParts = getTodayLAParts();
      if (!nowParts) {
        debugDebug('⚠️ Could not get LA timezone parts');
        return { unpaidAmount: 0, unpaidClasses: [] };
      }
      
      // Create today's date at midnight using LA timezone parts
      const todayLA = new Date(
        parseInt(nowParts.year),
        parseInt(nowParts.month) - 1,
        parseInt(nowParts.day)
      );
      
      // Create nowLA with time for class time comparison
      const nowLA = new Date(
        parseInt(nowParts.year),
        parseInt(nowParts.month) - 1,
        parseInt(nowParts.day),
        parseInt(nowParts.hour),
        parseInt(nowParts.minute),
        parseInt(nowParts.second) || 0
      );
      
      debugDebug('🕐 LA Time:', {
        parts: nowParts,
        todayLA: todayLA.toISOString().split('T')[0],
        nowLA: nowLA.toLocaleString('en-US', { timeZone: 'America/Los_Angeles' })
      });
      
      // Get student start date (when they joined)
      let studentStartDate = null;
      if (student.start_date) {
        // 🔧 FIX: Parse date string correctly to avoid timezone shift
        const parts = student.start_date.split('-');
        if (parts.length === 3) {
          studentStartDate = new Date(parseInt(parts[0]), parseInt(parts[1]) - 1, parseInt(parts[2]));
        } else {
          studentStartDate = new Date(student.start_date);
          studentStartDate.setHours(0, 0, 0, 0);
        }
      }
      
      // Fetch absences data for this student
      // CRITICAL: Check BOTH student_absences table AND payment_records with status='absent'
      let absences = [];
      try {
        const { data, error } = await supabaseClient
          .from('student_absences')
          .select('*')
          .eq('student_id', student.id);
        
        if (!error && data) {
          // Extract just YYYY-MM-DD portion to match scheduled date format
          absences = data.map(a => a.class_date ? a.class_date.substring(0, 10) : a.class_date);
          debugDebug(`✅ Loaded ${absences.length} absences from student_absences table:`, absences);
          debugDebug(`📋 Raw absence data:`, data);
        } else if (error) {
          console.error('⚠️ RLS Error loading absences:', error.message, error);
          debugDebug('⚠️ Error loading absences:', error);
        }
      } catch (err) {
        console.error('⚠️ Network error loading absences:', err);
        debugDebug('⚠️ Could not load absences:', err);
      }
      
      // ALSO CHECK payment_records for status='absent' - this is where admin marks absences!
      try {
        const { data, error } = await supabaseClient
          .from('payment_records')
          .select('date, status')
          .eq('student_id', student.id)
          .eq('status', 'absent');
        if (data && !error && data.length > 0) {
          const absentFromRecords = data.map(a => a.date ? a.date.substring(0, 10) : a.date);
          debugDebug(`✅ Loaded ${absentFromRecords.length} absences from payment_records table:`, absentFromRecords);
          // Merge with student_absences (avoid duplicates)
          absentFromRecords.forEach(date => {
            if (!absences.includes(date)) {
              absences.push(date);
            }
          });
          debugDebug(`📋 Total absences after merging: ${absences.length}`, absences);
        }
      } catch (err) {
        debugDebug('⚠️ Could not load absences from payment_records:', err);
      }
      
      // Fetch credit_payments to see which classes were paid via credit
      let creditPayments = [];
      try {
        const { data, error } = await supabaseClient
          .from('credit_payments')
          .select('*')
          .eq('student_id', student.id);
        
        if (!error && data) {
          // Extract just YYYY-MM-DD portion to match scheduled date format
          creditPayments = data.map(cp => cp.class_date ? cp.class_date.substring(0, 10) : cp.class_date);
        }
      } catch (err) {
        debugDebug('⚠️ Could not load credit payments:', err);
      }
      
      // Fetch skipped_classes to exclude cancelled classes from schedule
      let skippedClassDates = [];
      try {
        // Get the student's group - try all possible field names
        const studentGroup = student.group_name || student.group_letter || student.group || '';
        
        // Canonicalize the group name (A-F format)
        const normalizedGroup = canonicalizeGroupCode(studentGroup);
        
        // Format as "Group X" to match skipped_classes.group_name format
        const groupNameForQuery = normalizedGroup ? `Group ${normalizedGroup}` : null;
        
        debugDebug(`🔍 Loading skipped classes for student group:`, {
          raw: studentGroup,
          normalized: normalizedGroup,
          queryValue: groupNameForQuery
        });
        
        if (!groupNameForQuery) {
          debugDebug('⚠️ No valid group name for student, skipping skipped_classes query');
        } else {
          const { data, error } = await supabaseClient
            .from('skipped_classes')
            .select('*')
            .eq('group_name', groupNameForQuery);
          
          if (!error && data) {
            // Extract just YYYY-MM-DD portion to match scheduled date format
            skippedClassDates = data.map(sc => sc.class_date ? sc.class_date.substring(0, 10) : sc.class_date);
            debugDebug(`✅ Loaded ${skippedClassDates.length} skipped classes for ${groupNameForQuery}:`, skippedClassDates);
          } else if (error) {
            console.error('⚠️ RLS Error loading skipped classes:', error.message, error);
          }
        }
      } catch (err) {
        console.error('⚠️ Network error loading skipped classes:', err);
        debugDebug('⚠️ Could not load skipped classes:', err);
      }
      
      // Parse schedule string to extract active days and class time
      // Format: "Monday, Wednesday, Friday at 7:00 PM" or "Tue, Thu 6:30 PM"
      const daysOfWeek = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
      const scheduleActiveDays = [];
      
      const scheduleStr = groupScheduleData.schedule || '';
      debugDebug('📝 Parsing schedule string:', scheduleStr);
      
      // Extract class time from schedule string
      let classTimeInMinutes = null;
      const timeMatch = scheduleStr.match(/(\d{1,2}):(\d{2})\s*(AM|PM)/i);
      if (timeMatch) {
        let hours = parseInt(timeMatch[1]);
        const minutes = parseInt(timeMatch[2]);
        const meridiem = timeMatch[3].toUpperCase();
        
        // Convert to 24-hour format
        if (meridiem === 'PM' && hours !== 12) hours += 12;
        if (meridiem === 'AM' && hours === 12) hours = 0;
        
        classTimeInMinutes = hours * 60 + minutes;
        debugDebug(`⏰ Class time extracted: ${timeMatch[0]} = ${hours}:${String(minutes).padStart(2, '0')} (${classTimeInMinutes} minutes)`);
      } else {
        debugDebug('⚠️ No class time found in schedule, will count all past dates as unpaid');
      }
      
      // Extract day names from schedule string
      const dayNames = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
      const fullDayMap = {
        'Mon': 'Monday', 'Tue': 'Tuesday', 'Wed': 'Wednesday',
        'Thu': 'Thursday', 'Fri': 'Friday', 'Sat': 'Saturday', 'Sun': 'Sunday'
      };
      
      dayNames.forEach(dayName => {
        if (scheduleStr.includes(dayName)) {
          const fullDay = fullDayMap[dayName] || dayName;
          if (!scheduleActiveDays.includes(fullDay)) {
            scheduleActiveDays.push(fullDay);
          }
        }
      });
      
      debugDebug('📅 Active schedule days:', scheduleActiveDays);
      
      if (scheduleActiveDays.length === 0) {
        debugDebug('⚠️ No active days found in schedule');
        return { unpaidAmount: 0, unpaidClasses: [] };
      }
      
      // Generate all past class dates based on schedule
      const scheduledDates = [];
      
      // 🔴 START FROM DECEMBER 1, 2025 (as requested)
      const dec1_2025 = new Date(2025, 11, 1); // December 1, 2025 (month is 0-indexed)
      
      // ALWAYS use the LATER of: Dec 1 2025 or student start date
      // This ensures we never count unpaid before Dec 1, even if student started earlier
      const startDate = new Date(Math.max(dec1_2025.getTime(), studentStartDate ? studentStartDate.getTime() : dec1_2025.getTime()));
      
      debugDebug(`📅 Calculating unpaid classes from ${startDate.toISOString().split('T')[0]} to today`);
      
      // Get current time in minutes for today's class comparison
      const currentTimeInMinutes = nowLA.getHours() * 60 + nowLA.getMinutes();
      const todayDateStr = `${nowLA.getFullYear()}-${String(nowLA.getMonth() + 1).padStart(2, '0')}-${String(nowLA.getDate()).padStart(2, '0')}`;
      
      // Generate all scheduled class dates until today
      for (let d = new Date(startDate); d <= todayLA; d.setDate(d.getDate() + 1)) {
        const dayName = daysOfWeek[d.getDay()];
        // Use local date format instead of UTC to avoid timezone shift
        const year = d.getFullYear();
        const month = String(d.getMonth() + 1).padStart(2, '0');
        const day = String(d.getDate()).padStart(2, '0');
        const dateStr = `${year}-${month}-${day}`;
        debugDebug(`🔍 Checking ${dateStr} (${dayName}, day#${d.getDay()}) - in schedule? ${scheduleActiveDays.includes(dayName)}`);
        if (scheduleActiveDays.includes(dayName)) {
          // Skip if this class was cancelled/skipped in the Calendar
          if (!skippedClassDates.includes(dateStr)) {
            // 🔴 NEW LOGIC: Skip today's class if it hasn't started yet
            if (dateStr === todayDateStr && classTimeInMinutes !== null && currentTimeInMinutes < classTimeInMinutes) {
              debugDebug(`⏭️ ${dateStr}: Today's class hasn't started yet (current: ${currentTimeInMinutes}min, class: ${classTimeInMinutes}min) - not counting as unpaid`);
              continue;
            }
            scheduledDates.push(dateStr);
            debugDebug(`✅ Added ${dateStr} as scheduled class`);
          } else {
            debugDebug(`⏭️ ${dateStr}: Class was skipped/cancelled in Calendar`);
          }
        }
      }
      
      debugDebug(`📅 Generated ${scheduledDates.length} scheduled class dates (after excluding ${skippedClassDates.length} skipped classes)`);
      
      // 🔥 ADD ONE-TIME SCHEDULED CLASSES (e.g., makeup classes, rescheduled classes)
      // These are stored in groups.one_time_schedules as JSON array of objects with date/time/description
      if (groupScheduleData.one_time_schedules && Array.isArray(groupScheduleData.one_time_schedules)) {
        groupScheduleData.one_time_schedules.forEach(oneTime => {
          const oneTimeDate = oneTime.date ? oneTime.date.substring(0, 10) : null;
          if (!oneTimeDate) return;
          
          // Parse the date to compare with today
          const parts = oneTimeDate.split('-');
          if (parts.length !== 3) return;
          
          const oneTimeClassDate = new Date(parseInt(parts[0]), parseInt(parts[1]) - 1, parseInt(parts[2]));
          
          // Only include if it's in the past or today (and class has started)
          if (oneTimeClassDate <= todayLA) {
            // Check if today and class hasn't started yet
            if (oneTimeDate === todayDateStr) {
              // Extract time from one-time schedule
              const oneTimeMatch = oneTime.time ? oneTime.time.match(/(\d{1,2}):(\d{2})\s*(AM|PM)/i) : null;
              if (oneTimeMatch) {
                let hours = parseInt(oneTimeMatch[1]);
                const minutes = parseInt(oneTimeMatch[2]);
                const meridiem = oneTimeMatch[3].toUpperCase();
                if (meridiem === 'PM' && hours !== 12) hours += 12;
                if (meridiem === 'AM' && hours === 12) hours = 0;
                const oneTimeInMinutes = hours * 60 + minutes;
                
                if (currentTimeInMinutes < oneTimeInMinutes) {
                  debugDebug(`⏭️ One-time class ${oneTimeDate} hasn't started yet - skipping`);
                  return;
                }
              }
            }
            
            // Add to scheduled dates if not already present and not skipped
            if (!scheduledDates.includes(oneTimeDate) && !skippedClassDates.includes(oneTimeDate)) {
              scheduledDates.push(oneTimeDate);
              debugDebug(`✅ Added one-time scheduled class: ${oneTimeDate} (${oneTime.description || 'Makeup class'})`);
            }
          }
        });
        
        // Sort all dates chronologically
        scheduledDates.sort();
        debugDebug(`📅 Total scheduled dates (including ${groupScheduleData.one_time_schedules.length} one-time classes): ${scheduledDates.length}`);
      }
      
      // Check each scheduled date for payment status
      const unpaidClasses = [];
      const absentClasses = []; // Track absent classes for display
      for (const dateStr of scheduledDates) {
        debugDebug(`🔍 Checking date ${dateStr} against absences:`, absences, `includes? ${absences.includes(dateStr)}`);
        // Mark if absent (show in payment history but don't count as unpaid)
        if (absences.includes(dateStr)) {
          debugDebug(`⚪ ${dateStr}: Student was absent (no payment expected)`);
          absentClasses.push({
            date: dateStr,
            amount: 0, // No payment expected for absences
            status: 'absent'
          });
          continue;
        }
        
        // Skip if paid via credit
        if (creditPayments.includes(dateStr)) {
          debugDebug(`🔵 ${dateStr}: Paid via credit`);
          continue;
        }
        
        // Check if there's a payment covering this class
        // 🔧 FIX: Use dateString property directly (no timezone conversion!)
        const hasPaidPayment = payments.some(p => {
          // 🔥 CRITICAL FIX: Include BOTH paid and credit payments
          if (p.status !== 'paid' && p.status !== 'credit') return false;
          
          // Use pre-extracted dateString to avoid timezone conversion issues
          const paymentDateStr = p.dateString || (p.date instanceof Date 
            ? p.date.toISOString().split('T')[0] 
            : (p.date || '').substring(0, 10));
          
          debugDebug(`  🔍 Comparing payment date "${paymentDateStr}" with class date "${dateStr}"`);
          
          // Payment matches if it's for the SAME date (exact match)
          // or if it's within 7 days after class (Calendar logic: payment applies to nearest past class)
          if (paymentDateStr === dateStr) {
            console.log(`  ✅ EXACT MATCH: Payment ${paymentDateStr} (status=${p.status}, source=${p.source}) matches class ${dateStr}`);
            debugDebug(`  ✅ EXACT MATCH: Payment ${paymentDateStr} matches class ${dateStr}`);
            return true; // Exact date match
          }
          
          const classDate = new Date(dateStr + 'T00:00:00');
          const paymentDate = new Date(paymentDateStr + 'T00:00:00');
          const daysDiff = Math.floor((paymentDate - classDate) / (1000 * 60 * 60 * 24));
          const withinWeek = daysDiff >= 0 && daysDiff <= 7;
          if (withinWeek) {
            console.log(`  ✅ WITHIN 7 DAYS: Payment ${paymentDateStr} (status=${p.status}, source=${p.source}) is ${daysDiff} days after class ${dateStr}`);
            debugDebug(`  ✅ WITHIN 7 DAYS: Payment ${paymentDateStr} is ${daysDiff} days after class ${dateStr}`);
          }
          return withinWeek; // Within a week after class
        });
        
        if (!hasPaidPayment) {
          unpaidClasses.push({
            date: dateStr,
            amount: pricePerClass
          });
          console.log(`🔴 ${dateStr}: UNPAID (no payment found)`);
          debugDebug(`🔴 ${dateStr}: UNPAID (no payment found)`);
        } else {
          console.log(`🟢 ${dateStr}: PAID`);
          debugDebug(`🟢 ${dateStr}: PAID`);
        }
      }
      
      const unpaidAmount = unpaidClasses.length * pricePerClass;
      console.log(`💰 FINAL UNPAID CALCULATION: $${unpaidAmount} (${unpaidClasses.length} unpaid classes × $${pricePerClass})`);
      if (unpaidClasses.length > 0) {
        console.log(`📋 Unpaid class dates:`, unpaidClasses.map(c => c.date));
      }
      debugDebug(`💰 Total unpaid: $${unpaidAmount} (${unpaidClasses.length} classes × $${pricePerClass})`);
      debugDebug(`⚪ Total absent: ${absentClasses.length} classes`);
      
      return { unpaidAmount, unpaidClasses, absentClasses };
    }
    
    // Load student payment UI only when needed (with DOM caching)
    async function updatePaymentUI(payments = [], student = null, groupSchedule = null) {
      let totalUnpaid = 0; // Value from ledger/balance calculations
      let lastPaidAmount = 0;
      let lastPaidDate = null;
      let unpaidClasses = []; // Track individual unpaid class dates
      let absentClasses = []; // Track absent class dates
      let scheduleUnpaidAmount = 0; // Amount derived from schedule analysis
      
      // Cache frequently accessed DOM elements
      let lastPaidEl = getCachedDOM('lastPaid') || document.getElementById('lastPaid');
      let lastPaidDateEl = getCachedDOM('lastPaidDate') || document.getElementById('lastPaidDate');
      let totalUnpaidEl = getCachedDOM('totalUnpaid') || document.getElementById('totalUnpaid');
      
      if (lastPaidEl) setCachedDOM('lastPaid', lastPaidEl);
      if (lastPaidDateEl) setCachedDOM('lastPaidDate', lastPaidDateEl);
      if (totalUnpaidEl) setCachedDOM('totalUnpaid', totalUnpaidEl);
      
      const studentMarkedAbsent = (() => {
        if (!student) return false;
        const normalizeStatus = (value) => typeof value === 'string' ? value.trim().toLowerCase() : '';
        const normalizeBooleanLike = (value) => {
          if (value === true) return true;
          if (typeof value === 'string') {
            const normalized = value.trim().toLowerCase();
            return ['true', 'absent', 'yes', 'on'].includes(normalized);
          }
          return false;
        };
        return (
          normalizeBooleanLike(student.absent) ||
          normalizeStatus(student.status) === 'absent' ||
          normalizeStatus(student.attendance_status) === 'absent' ||
          normalizeStatus(student.lifecycle_status) === 'absent' ||
          normalizeStatus(student.current_status) === 'absent'
        );
      })();

      const numericBalance = student ? Number(student.balance) : NaN;
      const pricePerClassValue = student ? (parseFloat(student.price_per_class) || 50) : 50;
      
      // ✅ USE DATABASE BALANCE AS SOURCE OF TRUTH
      // The `students.balance` field is managed by admin and is authoritative for ledger tracking.
      // SIGN CONVENTION: Positive = Credit (overpayment), Negative = Debt (unpaid)
      // We still surface schedule-detected unpaid classes so nothing slips through, but we keep
      // the ledger amount for exports/profile modals.
      if (Number.isFinite(numericBalance)) {
        // 🔧 FIX: Only treat NEGATIVE balance as unpaid debt
        // Positive balance is CREDIT (overpayment), not unpaid
        totalUnpaid = numericBalance < 0 ? Math.abs(numericBalance) : 0;
        debugDebug(`✅ Using database balance as source of truth: $${numericBalance} (unpaid: $${totalUnpaid})`);
        
        // Still calculate unpaid classes for display purposes (e.g., showing which classes are unpaid)
        // but DON'T use this to override the balance
        if (student && groupSchedule) {
          const result = await calculateUnpaidFromSchedule(student, payments, groupSchedule);
          unpaidClasses = result.unpaidClasses; // Track which classes are unpaid
          absentClasses = result.absentClasses || []; // Track absent classes
          scheduleUnpaidAmount = result.unpaidAmount || 0;
          debugDebug(`📊 Calculated ${unpaidClasses.length} unpaid classes for reference (not affecting balance)`);
        }
      } else {
        // Fallback if balance is not set in database: calculate from schedule
        debugDebug('⚠️ No database balance found - falling back to schedule calculation');
        if (student && groupSchedule) {
          const result = await calculateUnpaidFromSchedule(student, payments, groupSchedule);
          totalUnpaid = result.unpaidAmount;
          unpaidClasses = result.unpaidClasses;
          absentClasses = result.absentClasses || [];
          scheduleUnpaidAmount = result.unpaidAmount || 0;
        } else {
          // Last resort: Calculate from payment_records table only
          debugDebug('⚠️ Using fallback payment_records calculation (no schedule data)');
          payments.forEach(payment => {
            const amount = parseFloat(payment.amount) || 0;
            if (payment.status === 'unpaid' || payment.status === 'pending') {
              totalUnpaid += amount;
            }
          });
        }
      }

      let displayUnpaidAmount = totalUnpaid;
      let unpaidSource = 'none';
      const ledgerAmount = Number.isFinite(numericBalance) ? numericBalance : null;

      // Use schedule calculation if it's higher than ledger
      if (!Number.isFinite(numericBalance) && scheduleUnpaidAmount > 0) {
        displayUnpaidAmount = scheduleUnpaidAmount;
        unpaidSource = 'schedule';
      } else if (scheduleUnpaidAmount > totalUnpaid) {
        displayUnpaidAmount = scheduleUnpaidAmount;
        unpaidSource = 'schedule';
      } else if (totalUnpaid > 0) {
        unpaidSource = 'ledger';
      }

      if (studentMarkedAbsent && (displayUnpaidAmount > 0 || unpaidClasses.length > 0)) {
        debugDebug('🚫 Student marked absent — clearing unpaid totals from portal view.');
        displayUnpaidAmount = 0;
        unpaidClasses = [];
        unpaidSource = 'none';
      }
      
      // Store globally for profile modal
      currentTotalUnpaid = displayUnpaidAmount;
      window.currentTotalUnpaid = displayUnpaidAmount;
      
      // Calculate last paid
      payments.forEach(payment => {
        const amount = parseFloat(payment.amount) || 0;
        // 🔥 CRITICAL FIX: Include BOTH paid and credit payments
        if (payment.status === 'paid' || payment.status === 'credit') {
          if (!lastPaidDate || payment.date > lastPaidDate) {
            lastPaidDate = payment.date;
            lastPaidAmount = amount;
          }
        }
      });
      
      let lastPaidDateText = '-';
      if (lastPaidDate) {
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        const yesterday = new Date(today);
        yesterday.setDate(yesterday.getDate() - 1);
        const paymentDate = new Date(lastPaidDate);
        paymentDate.setHours(0, 0, 0, 0);
        
        if (paymentDate.getTime() === today.getTime()) {
          lastPaidDateText = 'Today';
        } else if (paymentDate.getTime() === yesterday.getTime()) {
          lastPaidDateText = 'Yesterday';
        } else {
          const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
          lastPaidDateText = `${monthNames[lastPaidDate.getMonth()]} ${lastPaidDate.getDate()}`;
        }
      }
      
      document.getElementById('lastPaid').textContent = `$${lastPaidAmount.toFixed(0)}`;
      document.getElementById('lastPaidDate').textContent = lastPaidDateText;
      document.getElementById('totalUnpaid').textContent = `$${displayUnpaidAmount.toFixed(0)}`;

      const unpaidSourceNoteEl = document.getElementById('unpaidSourceNote');
      if (unpaidSourceNoteEl) {
        if (displayUnpaidAmount <= 0) {
          // Hide the note completely - no need to show admin messages to students
          unpaidSourceNoteEl.style.display = 'none';
          // But still log it for admins viewing console
          if (unpaidSource === 'schedule-override' && ledgerAmount > 0) {
            console.log(`✅ Overriding stale database balance of $${ledgerAmount} for ${student?.name} - schedule shows all classes are paid`);
          }
        } else if (unpaidSource === 'schedule' && unpaidClasses.length > 0) {
          const label = unpaidClasses.length === 1 ? 'class' : 'classes';
          unpaidSourceNoteEl.textContent = `${unpaidClasses.length} ${label} flagged from schedule`;
          unpaidSourceNoteEl.style.display = 'block';
          unpaidSourceNoteEl.style.color = ''; // Reset color
        } else if (unpaidSource === 'ledger') {
          unpaidSourceNoteEl.textContent = 'Balance from admin ledger';
          unpaidSourceNoteEl.style.display = 'block';
          unpaidSourceNoteEl.style.color = ''; // Reset color
        } else if (ledgerAmount !== null && ledgerAmount > 0) {
          unpaidSourceNoteEl.textContent = 'Balance from admin ledger';
          unpaidSourceNoteEl.style.display = 'block';
          unpaidSourceNoteEl.style.color = ''; // Reset color
        } else {
          unpaidSourceNoteEl.style.display = 'none';
        }
      }

      const creditCardEl = document.getElementById('creditCard');
      const creditValueEl = document.getElementById('creditBalance');
      const creditNoteEl = document.getElementById('creditNote');
      if (creditCardEl && creditValueEl) {
        if (Number.isFinite(numericBalance) && numericBalance > 0) {
          creditValueEl.textContent = `$${numericBalance.toFixed(0)}`;
          if (creditNoteEl) {
            const classesCovered = pricePerClassValue > 0 ? numericBalance / pricePerClassValue : 0;
            if (classesCovered >= 1) {
              const rounded = classesCovered >= 2 ? Math.round(classesCovered) : Math.round(classesCovered * 10) / 10;
              const label = rounded === 1 ? 'class' : 'classes';
              creditNoteEl.textContent = `${rounded} ${label} covered`;
            } else {
              creditNoteEl.textContent = 'Extra payment available';
            }
          }
          creditCardEl.style.display = 'flex';
          creditCardEl.classList.add('credit-active');
        } else {
          creditCardEl.style.display = 'none';
          creditCardEl.classList.remove('credit-active');
        }
      }
      
      // Update absences card
      const absencesCardEl = document.getElementById('absencesCard');
      const absencesCountEl = document.getElementById('absencesCount');
      const absencesNoteEl = document.getElementById('absencesNote');
      if (absencesCardEl && absencesCountEl) {
        const totalAbsences = (absentClasses && absentClasses.length) || 0;
        if (totalAbsences > 0) {
          absencesCountEl.textContent = totalAbsences.toString();
          if (absencesNoteEl && absentClasses && absentClasses.length > 0) {
            // Get the most recent absence to show the month
            const latestAbsence = absentClasses[absentClasses.length - 1];
            const absenceDate = new Date(latestAbsence.date + 'T00:00:00');
            const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            const month = monthNames[absenceDate.getMonth()];
            const label = totalAbsences === 1 ? `class missed in ${month}` : `classes missed in ${month}`;
            absencesNoteEl.textContent = label;
          }
          absencesCardEl.style.display = 'flex';
        } else {
          absencesCardEl.style.display = 'none';
        }
      }
      
      const unpaidCard = document.querySelector('.stat-card[style*="#ef4444"]');
      if (unpaidCard) {
        unpaidCard.classList.toggle('has-unpaid', displayUnpaidAmount > 0);
      }
      
      const paymentList = document.getElementById('paymentList');
      if (!paymentList) return;
      paymentList.innerHTML = '';
      
      // � COMBINE ALL ENTRIES: unpaid, absent, and paid into single array
  const allEntries = [];
  const absenceDisplayDates = new Set();
      
      // Add unpaid class entries
      if (unpaidClasses && unpaidClasses.length > 0) {
        unpaidClasses.forEach(unpaidClass => {
          const dateOnlyStr = unpaidClass.date ? unpaidClass.date.substring(0, 10) : unpaidClass.date;
          const parts = dateOnlyStr.split('-');
          const classDate = new Date(parseInt(parts[0]), parseInt(parts[1]) - 1, parseInt(parts[2]));
          
          allEntries.push({
            date: classDate,
            type: 'unpaid',
            amount: unpaidClass.amount,
            statusText: 'Not Paid',
            statusClass: 'unpaid'
          });
        });
      }
      
      // Add absent class entries
      if (absentClasses && absentClasses.length > 0) {
        absentClasses.forEach(absentClass => {
          const dateOnlyStr = absentClass.date ? absentClass.date.substring(0, 10) : absentClass.date;
          const parts = dateOnlyStr.split('-');
          const classDate = new Date(parseInt(parts[0]), parseInt(parts[1]) - 1, parseInt(parts[2]));
          const dateKey = dateOnlyStr;
          absenceDisplayDates.add(dateKey);
          
          allEntries.push({
            date: classDate,
            type: 'absent',
            amount: 0,
            statusText: 'Absent',
            statusClass: 'absent'
          });
        });
      }
      
      // Add paid payment entries
      if (payments && payments.length > 0) {
        // Month names for breakdown note formatting
        const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
        
        // First, build a map of original receipt dates to see which payments were split
        const receiptDateMap = new Map(); // receiptDate -> [{amount, forClass}, ...]
        payments.forEach(payment => {
          if (payment.receiptDate && payment.forClass && payment.receiptDate !== payment.forClass) {
            // This payment was reassigned from receiptDate to forClass
            if (!receiptDateMap.has(payment.receiptDate)) {
              receiptDateMap.set(payment.receiptDate, []);
            }
            receiptDateMap.get(payment.receiptDate).push({
              amount: parseFloat(payment.amount) || 0,
              forClass: payment.forClass
            });
          }
        });
        
        payments.forEach(payment => {
          const isCreditPayment = payment.source === 'credit';
          let statusText = 'Unknown';
          let statusClass = payment.status || 'unknown';
          
          if (isCreditPayment) {
            statusText = 'Paid from Credit';
            statusClass = 'credit';
          } else {
            switch (payment.status) {
              case 'paid':
                statusText = 'Paid';
                break;
              case 'unpaid':
                statusText = 'Not Paid';
                break;
              case 'pending':
                statusText = 'Pending';
                statusClass = 'unpaid';
                break;
              case 'absent':
                statusText = 'Absent';
                break;
              case 'cancelled':
                statusText = 'Cancelled';
                break;
              default:
                statusText = payment.status || 'Unknown';
            }
          }
          
          // FIX: Use for_class date (payment.dateString) instead of email_date (payment.date)
          // This shows when the payment was allocated to, not when it was received
          let displayDate;
          let breakdownNote = null;
          let isOneTimeClass = false;
          
          if (payment.dateString) {
            // payment.dateString is the for_class date (YYYY-MM-DD string)
            const parts = payment.dateString.split('-');
            displayDate = new Date(parseInt(parts[0]), parseInt(parts[1]) - 1, parseInt(parts[2]));
            console.log(`[Payment Display] Using for_class date: ${payment.dateString}, amount: $${payment.amount}, method: ${payment.payment_method}`);
            
            // Check if this date matches a one-time class
            if (groupSchedule && groupSchedule.one_time_schedules && Array.isArray(groupSchedule.one_time_schedules)) {
              isOneTimeClass = groupSchedule.one_time_schedules.some(oneTime => oneTime.date === payment.dateString);
              if (isOneTimeClass) {
                console.log(`[Payment Display] ✨ Payment for ONE-TIME CLASS: ${payment.dateString}`);
              }
            }
            
            // Check if this payment was split from a larger payment
            if (payment.receiptDate && receiptDateMap.has(payment.receiptDate)) {
              const splits = receiptDateMap.get(payment.receiptDate);
              if (splits.length > 1) {
                // This payment was split - add a breakdown note
                const totalAmount = splits.reduce((sum, s) => sum + s.amount, 0);
                const classesText = splits.map(s => {
                  const date = new Date(s.forClass + 'T00:00:00');
                  return `${monthNames[date.getMonth()]} ${date.getDate()}`;
                }).join(', ');
                breakdownNote = `Received $${totalAmount} on ${payment.receiptDate} for classes: ${classesText}`;
              }
            }
          } else if (payment.date) {
            // Fallback to payment.date if dateString not available
            displayDate = payment.date;
            console.log(`[Payment Display] No dateString, using payment.date: ${payment.date}, amount: $${payment.amount}`);
          } else {
            displayDate = new Date(); // Last resort fallback
            console.log(`[Payment Display] No date available, using today`);
          }
          
          const dateKey = payment.dateString || (payment.date ? payment.date.toISOString().split('T')[0] : null);
          if ((payment.status === 'absent' || statusClass === 'absent') && dateKey) {
            if (absenceDisplayDates.has(dateKey)) {
              debugDebug(`⚠️ Skipping duplicate displayed absence entry for ${dateKey}`);
              return;
            }
            absenceDisplayDates.add(dateKey);
          }
          
          allEntries.push({
            date: displayDate,  // Now uses for_class date instead of email_date
            type: isCreditPayment ? 'credit' : payment.status,
            amount: parseFloat(payment.amount) || 0,
            statusText: statusText,
            statusClass: statusClass,
            paymentMethod: payment.payment_method && !isCreditPayment ? ` (${payment.payment_method})` : '',
            breakdownNote: breakdownNote,  // Add breakdown note if payment was split
            isOneTimeClass: isOneTimeClass  // Flag for one-time class payment
          });
        });
      }
      
      // 🔁 FINAL SAFETY: Deduplicate by date + status to prevent duplicates from any source
      const uniqueEntryMap = new Map();
      const toDateKey = (dateObj) => {
        if (!(dateObj instanceof Date) || isNaN(dateObj)) return 'invalid-date';
        return `${dateObj.getFullYear()}-${String(dateObj.getMonth() + 1).padStart(2, '0')}-${String(dateObj.getDate()).padStart(2, '0')}`;
      };
      allEntries.forEach(entry => {
        const dateKey = toDateKey(entry.date);
        const statusKey = entry.statusClass || entry.statusText || entry.type || 'unknown';
        const dedupeKey = `${dateKey}__${statusKey.toLowerCase()}`;
        if (!uniqueEntryMap.has(dedupeKey)) {
          uniqueEntryMap.set(dedupeKey, entry);
        } else {
          debugDebug('⚠️ Dropping duplicate payment entry', { dedupeKey, dropped: entry, kept: uniqueEntryMap.get(dedupeKey) });
        }
      });
      const uniqueEntries = Array.from(uniqueEntryMap.values());
      debugDebug(`🧮 Payment entries: ${allEntries.length} raw → ${uniqueEntries.length} unique after dedupe`);
      
      // Check if we have any entries
      if (uniqueEntries.length === 0) {
        paymentList.innerHTML = '<div style="text-align: center; color: #64748b; padding: 40px;">No payment records found.</div>';
        return;
      }
      
      // 🔄 SORT ALL ENTRIES BY DATE (NEWEST FIRST)
      uniqueEntries.sort((a, b) => b.date - a.date);
      
      debugDebug(`📋 Displaying ${uniqueEntries.length} total payment entries sorted by date (newest first)`);
      
      // Render all entries in chronological order
      const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
      
  uniqueEntries.forEach(entry => {
        const item = document.createElement('div');
        item.className = `payment-item ${entry.statusClass}`;
        
        const dateStr = `${monthNames[entry.date.getMonth()]} ${entry.date.getDate()}, ${entry.date.getFullYear()}`;
        
        // Build payment method string with one-time class label if applicable
        let paymentMethodStr = entry.paymentMethod || '';
        let oneTimeClassLabel = '';
        if (entry.isOneTimeClass) {
          // Add one-time class label as separate line
          oneTimeClassLabel = '<div style="font-size: 11px; opacity: 0.8; margin-top: 2px;">(One time class)</div>';
        }
        
        item.innerHTML = `
          <div class="payment-date">${dateStr}</div>
          <div class="payment-status">
            <span class="status-badge ${entry.statusClass}">
              ${entry.statusText}${paymentMethodStr}
              ${oneTimeClassLabel}
            </span>
            ${entry.amount > 0 ? `<span class="payment-amount">$${entry.amount.toFixed(0)}</span>` : (entry.type === 'absent' ? '<span class="payment-amount">-</span>' : '')}
          </div>
          ${entry.breakdownNote ? `<div class="payment-breakdown-note">${entry.breakdownNote}</div>` : ''}
        `;
        
        paymentList.appendChild(item);
      });
    }

    // ==========================================================================
    // PAYMENT-LOCKED NOTES ENGINE
    // Automatically unlocks group notes based on paid calendar classes
    // ==========================================================================

    /**
     * Computes all class dates for a student in a given month based on their schedule
     * @param {Object} scheduleData - Schedule object with weekly recurring and one-time schedules
     * @param {number} year - Year (e.g., 2025)
     * @param {number} month - Month (1-12)
     * @returns {Array<string>} Array of date strings in YYYY-MM-DD format
     */
    function computeClassDatesForMonth(scheduleData, year, month) {
      const classDates = [];
      
      if (!scheduleData || !scheduleData.schedule) {
        console.warn('⚠️ No schedule data available for class date computation');
        return classDates;
      }
      
      // Day name mapping
      const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
      
      // Parse recurring schedule to get class days of week
      const classDaysOfWeek = new Set();
      Object.entries(scheduleData.schedule).forEach(([day, times]) => {
        if (times && times.length > 0) {
          const dayIndex = dayNames.indexOf(day);
          if (dayIndex !== -1) {
            classDaysOfWeek.add(dayIndex);
          }
        }
      });
      
      // Generate all dates in the month that match class days
      const firstDay = new Date(year, month - 1, 1);
      const lastDay = new Date(year, month, 0);
      
      for (let date = new Date(firstDay); date <= lastDay; date.setDate(date.getDate() + 1)) {
        const dayOfWeek = date.getDay();
        if (classDaysOfWeek.has(dayOfWeek)) {
          // Use local date string to avoid timezone issues
          const year = date.getFullYear();
          const month = String(date.getMonth() + 1).padStart(2, '0');
          const day = String(date.getDate()).padStart(2, '0');
          const dateStr = `${year}-${month}-${day}`;
          classDates.push(dateStr);
        }
      }
      
      // Add one-time scheduled classes for this month
      if (scheduleData.one_time_schedules && Array.isArray(scheduleData.one_time_schedules)) {
        scheduleData.one_time_schedules.forEach(schedule => {
          if (schedule.date) {
            const scheduleDate = new Date(schedule.date);
            if (scheduleDate.getFullYear() === year && scheduleDate.getMonth() === month - 1) {
              // Use local date string to avoid timezone issues
              const y = scheduleDate.getFullYear();
              const m = String(scheduleDate.getMonth() + 1).padStart(2, '0');
              const d = String(scheduleDate.getDate()).padStart(2, '0');
              const dateStr = `${y}-${m}-${d}`;
              if (!classDates.includes(dateStr)) {
                classDates.push(dateStr);
              }
            }
          }
        });
      }
      
      return classDates.sort();
    }

    /**
     * Maps a note to its corresponding class date based on posted_at timestamp
     * @param {Date} notePostedAt - When the note was posted
     * @param {Array<string>} classDates - Sorted array of class dates (YYYY-MM-DD)
     * @returns {string|null} The class date this note belongs to (YYYY-MM-DD) or null
     */
    function mapNoteToClassDate(notePostedAt, classDates) {
      if (!notePostedAt || !classDates || classDates.length === 0) {
        return null;
      }
      
      const noteDateStr = notePostedAt.toISOString().split('T')[0];
      
      // Find the most recent class date on or before the note's posted date
      let matchedClassDate = null;
      
      for (let i = 0; i < classDates.length; i++) {
        const classDate = classDates[i];
        
        if (classDate <= noteDateStr) {
          // This class date is on or before the note date
          matchedClassDate = classDate;
        } else {
          // We've passed the note date, stop searching
          break;
        }
      }
      
      // If note is posted before the first class, map it to the first class
      if (!matchedClassDate && classDates.length > 0) {
        matchedClassDate = classDates[0];
      }
      
      return matchedClassDate;
    }

    /**
     * Checks if a specific class date is paid for a student
     * @param {string} classDate - Class date in YYYY-MM-DD format
     * @param {Set<string>} paidDatesSet - Set of paid dates
     * @returns {boolean} True if class is paid
     */

    /**
     * Determines if a note should be unlocked for a student
     * @param {Object} note - Note object with posted_at, requires_payment, etc.
     * @param {Object} student - Student object with schedule data
     * @param {Set<string>} paidDatesSet - Set of dates (for_class) the student has paid for
     * @param {Set<string>} absentDatesSet - Set of dates student was marked absent
     * @param {Object} scheduleData - Student's schedule data
     * @param {string} perGroupClassDate - Per-group posting date from notePostDateMap (overrides note.class_date)
     * @returns {boolean} True if note should be unlocked
     * 
     * CRITICAL LOGIC:
     * - Notes are unlocked if student has payment with for_class matching the PER-GROUP posting date
     * - Per-group date comes from student_note_permissions.class_date or note_free_access.class_date
     * - Falls back to note.class_date only if no per-group date available
     * - **ABSENCES LOCK NOTES**: If student was absent, notes STAY LOCKED regardless of payment
     */
    function shouldUnlockNote(note, student, paidDatesSet, absentDatesSet, scheduleData, allNotesWithDates, paymentRecords, freeNoteIds, perGroupClassDate = null) {
      // If note doesn't require payment, unlock it
      if (!note.requires_payment) {
        debugDebug(`🔓 Note ${note.id} unlocked: No payment required`);
        return true;
      }
      
      // 🎁 FREE ACCESS BYPASS: If note has free access, unlock it UNCONDITIONALLY
      // Free access means admin granted access regardless of payment, absence, or class schedule
      const hasFreeAccess = freeNoteIds && freeNoteIds.has(note.id);
      if (hasFreeAccess) {
        debugDebug(`🎁 Note ${note.id} unlocked: Has FREE ACCESS (bypasses all checks)`);
        return true;
      }
      
      // � FIX: Use per-group class date if available, otherwise fall back to note.class_date
      const effectiveClassDate = perGroupClassDate || (note.class_date ? note.class_date.split('T')[0] : null);
      
      // 🚫 CRITICAL: Check absence FIRST (blocks paid notes but not free access notes)
      if (effectiveClassDate) {
        // If student was absent on this date, LOCK the note (unless it has free access)
        if (absentDatesSet && absentDatesSet.has(effectiveClassDate)) {
          debugDebug(`🔒 Note ${note.id} (${effectiveClassDate}) LOCKED: Student was ABSENT on this date`);
          return false;
        }
      }
      
      // If note has a specific class_date, check payment status
      if (effectiveClassDate) {
        // ✅ ROBUST CHECK: Does student have payment with for_class = effectiveClassDate?
        // This works even if payment was made late and admin reassigned for_class
        const hasMatchingPayment = paidDatesSet.has(effectiveClassDate);
        
        // DEBUG: Log payment check
        console.log(`[shouldUnlockNote] Payment check for note ${note.id}:`, {
          effectiveDate: effectiveClassDate,
          hasPayment: hasMatchingPayment,
          paidDates: Array.from(paidDatesSet)
        });
        
        if (hasMatchingPayment) {
          console.log(`[shouldUnlockNote] UNLOCKED Note ${note.id} (${effectiveClassDate}): Payment found`);
          return true;
        } else {
          console.log(`[shouldUnlockNote] LOCKED Note ${note.id} (${effectiveClassDate}): No payment. Paid dates: ${Array.from(paidDatesSet).join(', ')}`);
          return false;
        }
      }
      
      // For notes without class_date but requires payment:
      // If student has ANY paid dates, unlock (they're a paying student)
      if (paidDatesSet.size > 0) {
        debugDebug(`🔓 Note ${note.id} (no class_date) unlocked: Student has ${paidDatesSet.size} payment(s)`);
        return true;
      }
      
      // No payments found - lock the note
      debugDebug(`🔒 Note ${note.id} LOCKED: No payments found`);
      return false;
    }

    /**
     * Computes payment status for all notes based on class dates and payments
     * 
     * ROBUST LOGIC:
     * 1. Builds set of dates student has paid for (using payment.for_class from database)
     * 2. Builds set of dates student was marked absent (from payment_records status='absent')
     * 3. For each note with class_date, checks if student has payment.for_class matching that date
     * 4. **ABSENCES LOCK NOTES**: If student was absent, notes STAY LOCKED regardless of payment
     * 5. **FREE ACCESS UNLOCKS NOTES**: If note has free access for student's group, notes UNLOCK (unless absent)
     * 6. Admin reassignments work perfectly: Payment received Dec 16 → reassigned to Dec 18 → unlocks Dec 18 note
     * 7. **PER-GROUP DATES**: Uses notePostDateMap to check per-group posting dates instead of global note.class_date
     * 
     * @param {Array<Object>} notes - Array of notes
     * @param {Object} student - Student object
     * @param {Array<Object>} paymentRecords - Array of payment records (with for_class dates)
     * @param {Object} scheduleData - Student's schedule data
     * @param {Set<number>} freeNoteIds - Set of note IDs that have free access for student's group
     * @param {Map<number, string>} notePostDateMap - Map of noteId → per-group posting date (from permissions/free_access)
     * @returns {Map<number, boolean>} Map of noteId -> isPaid status
     */
    function computeNotePaymentStatus(notes, student, paymentRecords, scheduleData, freeNoteIds, notePostDateMap = null) {
      const notePaymentStatus = new Map();
      
      // Build set of paid dates using payment.for_class (allocated class dates)
      // This includes both 'paid' and 'credit' statuses
      // Excludes 'absent', 'unpaid', 'cancelled'
      const paidDatesSet = buildPaidDatesSet(paymentRecords);
      
      debugDebug(`📊 Computing note payment status for ${notes.length} notes. Student has payments for: ${Array.from(paidDatesSet).sort().join(', ')}`);
      
      // Build set of absence dates (for reference, though absences don't block paid access)
      const absentDatesSet = new Set(
        (paymentRecords || [])
          .filter(p => p.status === 'absent')
          .map(p => {
            if (p.dateString) return p.dateString;
            if (typeof p.date === 'string') return p.date.split('T')[0];
            if (p.date instanceof Date) return p.date.toISOString().split('T')[0];
            return null;
          })
          .filter(d => d !== null)
      );
      
      // Check each note
      notes.forEach(note => {
        // 🔥 FIX: Get per-group posting date if available
        // notePostDateMap stores objects like {dateString: "2025-12-21", source: "..."}
        // Extract just the dateString
        const perGroupDateObj = notePostDateMap ? notePostDateMap.get(note.id) : null;
        const perGroupDate = perGroupDateObj ? perGroupDateObj.dateString : null;
        
        const isPaid = shouldUnlockNote(
          note, 
          student, 
          paidDatesSet, 
          absentDatesSet, 
          scheduleData, 
          notes, 
          paymentRecords, 
          freeNoteIds,
          perGroupDate  // 🔥 Pass per-group date STRING (not object)
        );
        notePaymentStatus.set(note.id, isPaid);
        
        if (note.class_date) {
          const noteDate = note.class_date.split('T')[0];
          const wasAbsent = absentDatesSet.has(noteDate);
          debugDebug(`  Note ${note.id} (${noteDate}): ${isPaid ? '🔓 UNLOCKED' : '🔒 LOCKED'}${wasAbsent ? ' [ABSENT]' : ''}`);
        }
      });
      
      return notePaymentStatus;
    }

    async function loadScheduleForStudent(student) {
      currentGroupScheduleData = null;
      currentGroupScheduleSummary = null;
      setProfileScheduleText('Loading latest schedule...');
      const groupName = getStudentGroup(student);
      
      // COMPREHENSIVE DEBUG: Log all student group fields
      console.log('🔍 SCHEDULE LOAD DEBUG for student:', student.name);
      console.log('📋 Student group fields:', {
        group_name: student.group_name,
        group_letter: student.group_letter,
        group: student.group,
        computed_groupName: groupName
      });
      
      debugDebug('📅 About to load schedule for groupName:', groupName);
      
      if (!groupName) {
        console.warn('⚠️ No group assigned to student:', student.name);
        currentGroupScheduleSummary = 'No group assigned';
        setProfileScheduleText(currentGroupScheduleSummary);
        document.getElementById('groupScheduleDisplay').innerHTML = 
          '<div class="schedule-empty">No group assigned</div>';
        document.getElementById('nextClassTimer').innerHTML = 
          '<div class="schedule-empty" style="padding: 20px; margin: 0;">No group assigned</div>';
        document.getElementById('announcementsFeed').innerHTML = 
          '<div class="announcement-empty">No announcements available</div>';
        return;
      }
      
      try {
        const scheduleData = await getGroupSchedule(groupName);
        console.log('📦 getGroupSchedule returned for group', groupName, ':', scheduleData);
        debugDebug('📦 getGroupSchedule returned:', scheduleData);
        
        if (scheduleData) {
          currentGroupScheduleData = scheduleData;
          currentGroupScheduleSummary = buildScheduleSummary(scheduleData.schedule, scheduleData.one_time_schedules);
          setProfileScheduleText(currentGroupScheduleSummary);
          
          const groupNameEl = document.getElementById('scheduleGroupName');
          if (groupNameEl) {
            groupNameEl.textContent = ` - Group ${groupName}`;
          }
          
          const scheduleHtml = formatSchedule(scheduleData.schedule, scheduleData.one_time_schedules);
          document.getElementById('groupScheduleDisplay').innerHTML = scheduleHtml;
          
          if (scheduleData.updated_at) {
            const daysSinceUpdate = Math.floor((new Date() - scheduleData.updated_at) / (1000 * 60 * 60 * 24));
            const badge = document.getElementById('scheduleUpdatedBadge');
            if (badge) {
              badge.style.display = daysSinceUpdate <= 7 ? 'inline-block' : 'none';
            }
          }
          
          const nextClass = computeNextClass(scheduleData);
          if (nextClass) {
            const dateOptions = { weekday: 'long', month: 'short', day: 'numeric' };
            const dateStr = nextClass.date.toLocaleDateString('en-US', dateOptions);
            document.getElementById('nextClassDate').textContent = `${dateStr} — ${nextClass.time}`;
            
            const now = getNowLA();
            const timerEl = document.getElementById('nextClassTimer');
            if (timerEl) {
              timerEl.classList.toggle('today', nextClass.date.toDateString() === now.toDateString());
            }
            startCountdown(nextClass.date);
          } else {
            document.getElementById('nextClassTimer').innerHTML = `
              <div class="schedule-empty" style="padding: 20px; margin: 0;">
                No upcoming classes at this time.<br>
                Please check for schedule updates.
              </div>
            `;
          }
        } else {
          console.warn('⚠️ Schedule not available for student:', student.name);
          console.log('🔍 Reason: No matching group found in groups table');
          console.log('💡 SOLUTION: Admin needs to create group', groupName, 'in Group-Manager.html with a schedule');
          currentGroupScheduleSummary = 'Schedule not available';
          setProfileScheduleText(currentGroupScheduleSummary);
          document.getElementById('groupScheduleDisplay').innerHTML = 
            '<div class="schedule-empty">Schedule not available</div>';
          document.getElementById('nextClassTimer').innerHTML = 
            '<div class="schedule-empty" style="padding: 20px; margin: 0;">Schedule not available</div>';
        }
      } catch (err) {
        console.error('Error loading schedule:', err);
        currentGroupScheduleSummary = 'Error loading schedule';
        setProfileScheduleText(currentGroupScheduleSummary);
        document.getElementById('groupScheduleDisplay').innerHTML = 
          '<div class="schedule-empty">Error loading schedule</div>';
      }
      
      // PERFORMANCE FIX: Removed loadChangeNotes() call - now lazy-loaded in Materials section
    }
    
    // Toggle account dropdown (with DOM caching)
    function toggleAccountDropdown() {
      const dropdown = getCachedDOM('account-dropdown') || document.querySelector('.account-dropdown');
      if (dropdown) {
        setCachedDOM('account-dropdown', dropdown);
        dropdown.classList.toggle('open');
      }
    }
    
    // Close dropdown when clicking outside (with cached selector)
    document.addEventListener('click', (e) => {
      const dropdown = getCachedDOM('account-dropdown') || document.querySelector('.account-dropdown');
      if (dropdown) {
        setCachedDOM('account-dropdown', dropdown);
        if (!dropdown.contains(e.target)) {
          dropdown.classList.remove('open');
        }
      }
    });
    
    // Logout function
    async function logout() {
      try {
        // End session tracking
        await endSession();
        
        // Clear countdown timer
        if (countdownInterval) {
          clearInterval(countdownInterval);
          countdownInterval = null;
        }
        
        await supabaseClient.auth.signOut();
        currentStudent = null;
        window.currentStudent = null; // Also clear window property
        currentEmail = null;
        window.location.href = 'index.html';
      } catch (error) {
        console.error('Logout error:', error);
        window.location.href = 'index.html';
      }
    }
    
    // ==========================================================================
    // FORUM FUNCTIONALITY
    // ==========================================================================
    
    let forumMessages = [];
    
    // Toggle Forum Modal
    function toggleForum() {
      const modal = document.getElementById('forumModal');
      const isActive = modal.classList.contains('active');
      
      if (isActive) {
        modal.classList.remove('active');
        intervalManager.clear('forum');
      } else {
        modal.classList.add('active');
        loadForumMessages();
        loadStudentsForMentions(); // Load students for @ mentions
        setupMentionAutocomplete(); // Setup autocomplete
        
        // Scroll to first new message after a short delay to let DOM render
        setTimeout(() => {
          const firstNewMessage = document.querySelector('.forum-message.new-message');
          if (firstNewMessage) {
            firstNewMessage.scrollIntoView({ behavior: 'smooth', block: 'center' });
          }
        }, 300);
        
        // Mark as viewed after scrolling to new messages
        setTimeout(() => {
          markForumViewed();
        }, 1500);
        
        // PERFORMANCE FIX: Refresh every 30 seconds instead of 10 seconds
        // Reduces database load by 67%
        // Only refresh if modal is open and tab is visible
        intervalManager.set('forum', async () => {
          const modal = document.getElementById('forumModal');
          if (!modal.classList.contains('active') || document.hidden) return;
          
          try {
            await loadForumMessages();
          } catch (error) {
            console.warn('Failed to auto-refresh forum:', error);
          }
        }, 30000); // 30 seconds
      }
    }
    
    // ==========================================================================
    // UI MODAL FUNCTIONS
    // ==========================================================================
    
    // ---------- Profile Modal ----------
    // Open Profile Modal
    function openProfileModal() {
      const modal = document.getElementById('profileModal');
      
      // Use window.currentStudent to ensure it's accessible
      const student = window.currentStudent || currentStudent;
      
      console.log('🔍 Opening profile modal, full student object:', student);
      console.log('💰 Price per class:', student?.price_per_class);
      console.log('💳 Balance:', student?.balance);
      console.log('📊 All student keys:', student ? Object.keys(student) : 'no student');
      
      // Populate modal with current student data
      if (student) {
        // Name
        document.getElementById('modalStudentName').textContent = student.name || '-';
        
        // Email - handle both string and array formats
        let emailText = '-';
        if (student.email) {
          if (typeof student.email === 'string') {
            emailText = student.email;
          } else if (Array.isArray(student.email)) {
            emailText = student.email[0] || '-';
          }
        }
        document.getElementById('modalStudentEmail').textContent = emailText;
        
        // Group - try multiple possible field names
        const groupText = student.group_letter || student.group || student.group_name || '-';
        document.getElementById('modalStudentGroup').textContent = groupText;
        
        // Schedule - use the formatted summary if available
        const scheduleText = currentGroupScheduleSummary || student.schedule || 'Not scheduled';
        setProfileScheduleText(scheduleText);
        
        // Class Fee - check multiple possible field names and handle null/undefined/0
        let feeText = '-';
        const priceValue = student.price_per_class || student.price || student.fee || student.class_fee;
        console.log('💵 Fee value found:', priceValue, 'Type:', typeof priceValue);
        if (priceValue != null && priceValue !== 0 && priceValue !== '0') {
          feeText = `$${Number(priceValue).toFixed(0)}/class`;
        }
        document.getElementById('modalStudentFee').textContent = feeText;
        
        // Account Balance - use the calculated unpaid amount from payment history
        // This matches the "Unpaid" amount shown in the Payment History section
        let balanceText = '$0.00';
        const unpaidAmount = window.currentTotalUnpaid || currentTotalUnpaid || 0;
        console.log('💳 Using calculated unpaid amount:', unpaidAmount);
        
        if (unpaidAmount > 0) {
          balanceText = `$${unpaidAmount.toFixed(2)}`;
        } else {
          balanceText = '$0.00';
        }
        document.getElementById('modalStudentBalance').textContent = balanceText;
        
        // Aliases - handle multiple formats
        let aliasesText = 'None';
        if (student.aliases) {
          try {
            let aliasArray = [];
            
            if (typeof student.aliases === 'string') {
              // Try parsing as JSON first
              try {
                aliasArray = JSON.parse(student.aliases);
              } catch {
                // If not JSON, split by comma
                aliasArray = student.aliases.split(',').map(a => a.trim()).filter(a => a);
              }
            } else if (Array.isArray(student.aliases)) {
              aliasArray = student.aliases;
            }
            
            if (aliasArray.length > 0) {
              aliasesText = aliasArray.join(', ');
            }
          } catch (e) {
            console.warn('Error parsing aliases:', e);
          }
        }
        document.getElementById('modalStudentAliases').textContent = aliasesText;
        
        console.log('✅ Profile modal populated:', {
          name: student.name,
          email: emailText,
          group: groupText,
          schedule: scheduleText,
          fee: student.price_per_class,
          balance: student.balance,
          aliases: aliasesText
        });
      } else {
        // No student data - show placeholder
        console.warn('⚠️ No student data available for profile modal');
        document.getElementById('modalStudentName').textContent = 'Not available';
        document.getElementById('modalStudentEmail').textContent = 'Not available';
        document.getElementById('modalStudentGroup').textContent = 'Not available';
        setProfileScheduleText('Not available');
        document.getElementById('modalStudentFee').textContent = 'Not available';
        document.getElementById('modalStudentBalance').textContent = 'Not available';
        document.getElementById('modalStudentAliases').textContent = 'Not available';
      }
      
      modal.showModal();
      
      // Close account dropdown when opening profile modal
      const accountDropdown = document.querySelector('.account-dropdown');
      if (accountDropdown) {
        accountDropdown.classList.remove('open');
      }
    }
    
    // ---------- Game Modal ----------
    // Close Profile Modal
    function closeProfileModal() {
      const modal = document.getElementById('profileModal');
      modal.close();
    }
    
    // Open Game Modal
    function openGameModal(gameUrl) {
      const modal = document.getElementById('gameModal');
      const iframe = document.getElementById('gameIframe');
      
      iframe.src = gameUrl;
      modal.classList.add('active');
      
      // Prevent body scroll when modal is open
      document.body.style.overflow = 'hidden';
    }
    
    // Close Game Modal
    function closeGameModal() {
      const modal = document.getElementById('gameModal');
      const iframe = document.getElementById('gameIframe');
      
      modal.classList.remove('active');
      iframe.src = ''; // Clear iframe to stop game
      
      // Restore body scroll
      document.body.style.overflow = '';
    }
    
    function setupModalAccessibility() {
      const profileModal = document.getElementById('profileModal');
      const gameModal = document.getElementById('gameModal');

      if (profileModal) {
        profileModal.addEventListener('click', (event) => {
          if (event.target === profileModal) {
            closeProfileModal();
          }
        });
        profileModal.addEventListener('keydown', (event) => {
          if (event.key === 'Escape' || event.key === 'Enter') {
            closeProfileModal();
          }
        });
      }

      if (gameModal) {
        gameModal.addEventListener('click', (event) => {
          if (event.target === gameModal) {
            closeGameModal();
          }
        });
        gameModal.addEventListener('keydown', (event) => {
          if (event.key === 'Escape' || event.key === 'Enter') {
            closeGameModal();
          }
        });
      }
    }

    // Initialize section tabs for lazy loading
    function initSectionTabs() {
      const tabs = document.querySelectorAll('.section-tab');
      if (!tabs.length) return;
      tabs.forEach(tab => {
        tab.addEventListener('click', () => {
          const section = tab.dataset.section;
          if (!section || section === activeSection) return;
          if (!currentStudent) {
            console.warn('Student data not ready yet. Please wait a moment.');
            return;
          }
          // INSTANT SWITCH - no await, no blocking
          setActiveSection(section);
        });
      });
      setActiveSection(activeSection);
    }

    function setActiveSection(section) {
      activeSection = section;
      
      // INSTANT UI UPDATE - Show panel immediately
      document.querySelectorAll('.section-tab').forEach(tab => {
        tab.classList.toggle('active', tab.dataset.section === section);
      });
      document.querySelectorAll('.section-panel').forEach(panel => {
        panel.classList.toggle('active', panel.dataset.section === section);
      });
      
      // Load data in background (non-blocking)
      ensureSectionData(section).catch(err => {
        console.error(`Background load failed for ${section}:`, err);
      });
    }

    async function ensureSectionData(section) {
      // Check if already loaded
      if (sectionLoadedState[section]) return;
      if (!currentStudent) {
        console.warn('Section requested before student data is ready.');
        return;
      }
      
      try {
        switch (section) {
          case 'overview':
            if (!currentGroupScheduleData) {
              await loadScheduleForStudent(currentStudent);
            }
            break;
          case 'payments':
            await loadPaymentsSection();
            break;
          case 'progress':
            await loadProgressSection();
            break;
          case 'materials':
            await loadMaterialsSection();
            break;
          default:
            break;
        }
        sectionLoadedState[section] = true;
      } catch (error) {
        console.error(`Error loading section ${section}:`, error);
      }
    }

    // Force reload payments data (clears cache)
    async function refreshPaymentsData() {
      // Clear payment cache to force fresh data
      clearDataCache('payments-');
      
      paymentsLoaded = false;
      currentPayments = [];
      paymentsLoadingPromise = null;
  window.paymentHistory = null;
  window.allPayments = [];
      const payments = await ensurePaymentsData();
      await updatePaymentUI(payments, currentStudent, currentGroupScheduleData);
      debugLog('💰 Payments refreshed (cache cleared)');
      return payments;
    }

    async function ensurePaymentsData() {
      if (paymentsLoaded && currentPayments.length) {
        return currentPayments;
      }
      if (paymentsLoadingPromise) {
        return paymentsLoadingPromise;
      }
      paymentsLoadingPromise = loadPaymentHistory(currentStudent)
        .then(payments => {
          currentPayments = payments;
          window.allPayments = payments;
          window.paymentHistory = {
            payments,
            paidDatesSet: buildPaidDatesSet(payments),
            lastUpdated: Date.now()
          };
          paymentsLoaded = true;
          paymentsLoadingPromise = null;
          return payments;
        })
        .catch(error => {
          paymentsLoadingPromise = null;
          window.paymentHistory = null;
          throw error;
        });
      return paymentsLoadingPromise;
    }

    async function loadPaymentsSection() {
      // 🚀 INSTANT: Remove loading message immediately
      const lazyMessage = document.getElementById('paymentLazyMessage');
      if (lazyMessage) {
        lazyMessage.remove();
      }
      
      // � Load payments in background (don't block)
      ensurePaymentsData().then(payments => {
        // Update UI after data arrives
        return updatePaymentUI(payments, currentStudent, currentGroupScheduleData);
      }).catch(error => {
        console.error('Failed to load payments:', error);
      });
    }

    async function loadProgressSection() {
      if (progressLoaded) return;
      await loadSystemsProgress();
      progressLoaded = true;
    }

    async function loadMaterialsSection() {
      if (materialsLoaded) return;
      
      // 🚀 INSTANT: Remove loading message first (instant feedback)
      const notesMessage = getCachedDOM('notesLazyMessage') || document.getElementById('notesLazyMessage');
      if (notesMessage) {
        setCachedDOM('notesLazyMessage', notesMessage);
        notesMessage.remove();
      }
      
      // 🚀 Load payments in background (don't block)
      ensurePaymentsData().then(payments => {
        // Load both notes AND announcements in parallel
        Promise.allSettled([
          loadClassroomUpdates(payments),
          loadChangeNotes(currentStudent?.group || currentStudent?.group_name)
        ]).then(results => {
          // Log any failures but continue
          if (results[0].status === 'rejected') {
            console.warn('Failed to load classroom updates:', results[0].reason);
          }
          if (results[1].status === 'rejected') {
            console.warn('Failed to load announcements:', results[1].reason);
          }
        });
      }).catch(err => {
        console.error('Materials section payment fetch failed:', err);
      });
      
      materialsLoaded = true;
    }

    document.addEventListener('DOMContentLoaded', () => {
      setupModalAccessibility();
      setupNoteCardEventDelegation(); // Performance: Single event listener for all note cards
      // initSectionTabs(); // DISABLED - showing all sections in one page
    });

    // Close modal on ESC key
    document.addEventListener('keydown', function(e) {
      if (e.key === 'Escape') {
        closeGameModal();
        closeProfileModal();
      }
    });
    
    /**
     * Loads forum messages and replies from Supabase database.
     * 
     * @async
     * @returns {Promise<void>}
     * 
     * @description
     * Queries the forum_messages table with nested replies join:
     * - Fetches up to 50 messages sorted by newest first
     * - Includes all replies via forum_replies relationship
     * - Updates global forumMessages array
     * - Calls renderForumMessages() to update UI
     * - Displays setup message if tables don't exist
     * 
     * Expected schema:
     * - forum_messages: { id, student_name, message, created_at }
     * - forum_replies: { id, message_id, student_name, reply, created_at }
     * 
     * @throws {Error} Logs to console but doesn't throw - shows setup UI on error
     */
    async function loadForumMessages() {
      try {
        const { data, error } = await supabaseClient
          .from('forum_messages')
          .select(`
            *,
            replies:forum_replies(*)
          `)
          .order('created_at', { ascending: false })
          .limit(50);
        
        if (error) {
          console.error('Error loading forum messages:', error);
          // Show message about creating table if it doesn't exist
          if (error.code === 'PGRST116' || error.code === 'PGRST204' || error.code === 'PGRST205' || error.message?.includes('does not exist')) {
            displayForumSetupMessage();
          }
          return;
        }
        
        // Sort messages: pinned first, then by date
        forumMessages = data || [];
        forumMessages.sort((a, b) => {
          // Pinned messages come first
          if (a.is_pinned && !b.is_pinned) return -1;
          if (!a.is_pinned && b.is_pinned) return 1;
          // Then sort by date (newest first)
          return new Date(b.created_at) - new Date(a.created_at);
        });
        
        renderForumMessages();
        updateForumBadge();
        updateForumInputVisibility(); // Hide/show private message button based on user role
        
      } catch (error) {
        console.error('Forum loading error:', error);
        displayForumSetupMessage();
      }
    }
    
    // Display setup message if table doesn't exist
    function displayForumSetupMessage() {
      const container = document.getElementById('forumMessages');
      container.innerHTML = `
        <div style="text-align: center; padding: 40px; color: rgba(255,255,255,0.6);">
          <p style="font-size: 48px; margin-bottom: 16px;">💬</p>
          <p style="font-size: 16px; margin-bottom: 8px;">Forum is being set up...</p>
          <p style="font-size: 13px;">Database tables need to be created. Contact admin.</p>
        </div>
      `;
    }
    
    // ---------- Forum Message Rendering ----------
    // Format message with markdown-style formatting and safe HTML
    function formatMessageText(text) {
      if (!text) return '';
      
      // First, protect safe HTML tags by temporarily replacing them
      let formatted = text;
      const safeSpans = [];
      
      // Extract and protect <span style="font-size: Xpx">...</span> tags
      formatted = formatted.replace(/<span style="font-size: (\d+)px">(.+?)<\/span>/g, (match, size, content) => {
        const index = safeSpans.length;
        safeSpans.push({ size, content });
        return `__SAFE_SPAN_${index}__`;
      });
      
      // NOW escape HTML to prevent XSS (but our safe spans are protected)
      formatted = escapeHtml(formatted);
      
      // Convert **text** to <strong>text</strong>
      formatted = formatted.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
      
      // Convert *text* to <em>text</em> (but not *** or **)
      formatted = formatted.replace(/(?<!\*)\*([^*]+)\*(?!\*)/g, '<em>$1</em>');
      
      // Restore safe span tags
      formatted = formatted.replace(/__SAFE_SPAN_(\d+)__/g, (match, index) => {
        const span = safeSpans[parseInt(index)];
        return `<span style="font-size: ${span.size}px">${span.content}</span>`;
      });
      
      return formatted;
    }
    
    /**
     * Renders forum messages with privacy filtering and reply box preservation.
     * 
     * BUG FIXES (Dec 17, 2024):
     * 1. Reply boxes no longer close after 30-second auto-refresh
     *    - Stores open reply boxes before re-render
     *    - Restores them after DOM update
     * 
     * 2. Private admin-student conversations are now truly private
     *    - Students only see messages relevant to them
     *    - Admin sees everything
     *    - Privacy rules:
     *      a) Students see their own messages
     *      b) Students see admin messages directed at them (with their replies)
     *      c) Students see public student messages (no admin involvement)
     *      d) Students DO NOT see other students' private conversations with admin
     * 
     * @function renderForumMessages
     * @returns {void}
     */
    function renderForumMessages() {
      const container = document.getElementById('forumMessages');
      
      // Check if current user is admin
      const isAdmin = currentStudent && (currentStudent.isAdminChatMode || currentStudent.role === 'admin' || currentStudent.id === 0);
      debugLog('🔍 Rendering forum - isAdmin:', isAdmin, 'currentStudent:', currentStudent);
      
      // FIX #1: PRESERVE OPEN REPLY BOXES - Store which reply boxes are currently open
      // This prevents the 30-second auto-refresh from closing reply boxes
      const openReplyBoxes = new Set();
      document.querySelectorAll('.reply-input-container.active').forEach(el => {
        const messageId = el.id.replace('replyInput', '');
        openReplyBoxes.add(messageId);
      });
      
      if (!forumMessages || forumMessages.length === 0) {
        container.innerHTML = `
          <div style="text-align: center; padding: 40px; color: rgba(255,255,255,0.6);">
            <p style="font-size: 48px; margin-bottom: 16px;">💬</p>
            <p style="font-size: 16px;">No messages yet. Be the first to post!</p>
          </div>
        `;
        return;
      }
      
      // FIX #2: PRIVACY FILTER - Filter messages based on user type
      // Students only see messages relevant to them, admin sees everything
      let filteredMessages = forumMessages;
      
      if (!isAdmin && currentStudent && currentStudent.id) {
        // Regular student: Only show messages they can see
        filteredMessages = forumMessages.filter(msg => {
          const isAdminMessage = msg.student_name === 'Administrator' || msg.student_id === 0;
          const isOwnMessage = msg.student_id === currentStudent.id;
          const isPrivateMessage = msg.is_private === true;
          
          // Show if it's their own message (including private ones)
          if (isOwnMessage) return true;
          
          // Hide private messages from other students
          if (isPrivateMessage && !isOwnMessage) return false;
          
          // Show if it's an admin message directed to them (check replies)
          if (isAdminMessage && msg.replies && msg.replies.length > 0) {
            // If admin message has a reply from this student, show it
            const hasOwnReply = msg.replies.some(r => r.student_id === currentStudent.id);
            if (hasOwnReply) return true;
          }
          
          // Show if it's a public message (not from admin, not a private conversation)
          // A message is public if it's not from admin
          if (!isAdminMessage) {
            // But hide if it has admin replies and the student is not part of that conversation
            if (msg.replies && msg.replies.length > 0) {
              const hasAdminReply = msg.replies.some(r => r.student_name === 'Administrator' || r.student_id === 0);
              const hasOwnReply = msg.replies.some(r => r.student_id === currentStudent.id);
              
              // If there's an admin reply but no reply from this student, it's a private conversation
              if (hasAdminReply && !hasOwnReply && msg.student_id !== currentStudent.id) {
                return false; // Hide private admin-student conversations
              }
            }
            return true; // Show public student messages
          }
          
          return false; // Hide admin messages not relevant to this student
        });
      }
      // Admin sees everything (no filtering)
      
      container.innerHTML = filteredMessages.map((msg, index) => {
        const isAdminMessage = msg.student_name === 'Administrator' || msg.student_id === 0;
        const isPinned = msg.is_pinned === true;
        
        // Check if this is a private conversation (admin has replied to this message)
        const hasAdminReply = msg.replies && msg.replies.some(r => r.student_name === 'Administrator' || r.student_id === 0);
        const isOwnMessage = currentStudent && msg.student_id === currentStudent.id;
        const isPrivateConversation = !isAdmin && hasAdminReply && isOwnMessage;
        const isStudentInitiatedPrivate = !isAdmin && msg.is_private === true && isOwnMessage;
        
        debugLog('🔒 Privacy check:', {
          msgId: msg.id,
          studentName: msg.student_name,
          hasAdminReply,
          isOwnMessage,
          isPrivateConversation,
          isStudentInitiatedPrivate,
          isPrivate: msg.is_private,
          currentStudentId: currentStudent?.id,
          msgStudentId: msg.student_id
        });
        
        // Check if message is new (after last forum view)
        const lastViewed = localStorage.getItem('lastForumView');
        const msgDate = new Date(msg.created_at);
        const isNew = !lastViewed || msgDate > new Date(lastViewed);
        
        return `
        <div class="forum-message ${isNew ? 'new-message' : ''}" style="animation-delay: ${index * 0.1}s; ${isPinned ? 'border: 2px solid rgba(251, 191, 36, 0.3); background: linear-gradient(145deg, rgba(251, 191, 36, 0.05), rgba(245, 158, 11, 0.05));' : ''}">
          ${isNew && !isPinned ? '<div class="new-message-tag">✨ NEW</div>' : ''}
          ${isPinned ? '<div style="position: absolute; top: 12px; right: 12px; font-size: 20px;" title="Pinned message">📌</div>' : ''}
          <div class="message-header">
            <div style="display: flex; flex-direction: column; gap: 2px;">
              <span class="message-author" style="${isAdminMessage ? 'color: #ef4444; font-weight: 600;' : ''}">👤 ${escapeHtml(msg.student_name || 'Student')}</span>
              <div style="font-size: 11px; color: rgba(255,255,255,0.5); padding-left: 24px;">
                ${msg.student_group ? `<span>Group ${escapeHtml(msg.student_group)}</span>` : ''}${msg.student_group && msg.student_college ? '  ' : ''}${msg.student_college ? `<span>🎓 ${escapeHtml(msg.student_college)}</span>` : ''}
              </div>
            </div>
            <div style="display: flex; align-items: center; gap: 8px;">
              <span class="message-time">${formatMessageTime(msg.created_at)}</span>
              ${isAdmin ? `<button class="delete-message-btn" onclick="deleteForumMessage(${msg.id})" title="Delete message">🗑️</button>` : ''}
            </div>
          </div>
          <div class="message-text" id="messageText${msg.id}" style="${isAdminMessage ? 'color: #ef4444;' : ''}" data-original="${escapeHtml(msg.message).replace(/"/g, '&quot;')}">${formatMessageText(msg.message)}</div>
          
          ${isPrivateConversation || isStudentInitiatedPrivate ? `
            <div style="
              margin-top: 8px;
              padding: 8px 12px;
              background: linear-gradient(135deg, rgba(139, 92, 246, 0.15), rgba(109, 40, 217, 0.15));
              border-left: 3px solid rgba(139, 92, 246, 0.5);
              border-radius: 8px;
              display: flex;
              align-items: center;
              gap: 8px;
            ">
              <span style="font-size: 16px;">🔒</span>
              <span style="
                font-size: 11px;
                color: rgba(196, 181, 253, 0.9);
                font-weight: 500;
                letter-spacing: 0.3px;
              ">${isStudentInitiatedPrivate ? 'Private message to Administrator' : 'Private conversation - Only you and the administrator can see this'}</span>
            </div>
          ` : ''}
          
          ${msg.attachment_url ? `
            <div style="margin-top: 12px;">
              ${(() => {
                const fileName = msg.attachment_name || 'attachment';
                const fileType = msg.attachment_type || '';
                const isImage = fileType.startsWith('image/') || /\.(jpg|jpeg|png|gif|webp|bmp)$/i.test(fileName);
                const isPDF = fileType === 'application/pdf' || fileName.toLowerCase().endsWith('.pdf');
                
                if (isImage) {
                  // Show image preview
                  return `
                    <div style="position: relative; border-radius: 10px; overflow: hidden; max-width: 280px; border: 1px solid rgba(96, 165, 250, 0.3); background: rgba(0,0,0,0.3);">
                      <img 
                        src="${msg.attachment_url}" 
                        alt="Image" 
                        style="width: 100%; height: auto; max-height: 200px; object-fit: cover; display: block; cursor: pointer;"
                        onclick="window.open('${msg.attachment_url}', '_blank')"
                        loading="lazy"
                      />
                      <div style="position: absolute; bottom: 6px; right: 6px;">
                        <a href="${msg.attachment_url}" download style="padding: 6px 10px; background: rgba(59, 130, 246, 0.95); border-radius: 6px; color: white; text-decoration: none; font-size: 14px; font-weight: 500; display: inline-block; box-shadow: 0 2px 8px rgba(0,0,0,0.3); cursor: pointer;" onclick="event.stopPropagation();">⬇️</a>
                      </div>
                    </div>
                  `;
                } else if (isPDF) {
                  // Show PDF preview with thumbnail
                  return `
                    <div style="padding: 12px; background: rgba(96, 165, 250, 0.1); border: 1px solid rgba(96, 165, 250, 0.3); border-radius: 10px;">
                      <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 12px;">
                        <div style="width: 48px; height: 48px; background: linear-gradient(135deg, #ef4444, #dc2626); border-radius: 8px; display: flex; align-items: center; justify-content: center; font-size: 20px; font-weight: bold; color: white; box-shadow: 0 2px 8px rgba(239, 68, 68, 0.3);">
                          PDF
                        </div>
                        <div style="flex: 1;">
                          <div style="font-size: 13px; font-weight: 500; color: rgba(255,255,255,0.9);">${escapeHtml(fileName)}</div>
                          <div style="font-size: 11px; color: rgba(255,255,255,0.5); margin-top: 2px;">PDF Document</div>
                        </div>
                      </div>
                      <div style="display: flex; gap: 8px;">
                        <a href="${msg.attachment_url}" target="_blank" style="flex: 1; padding: 8px 16px; background: linear-gradient(135deg, #3b82f6, #2563eb); border-radius: 8px; color: white; text-decoration: none; font-size: 12px; font-weight: 500; text-align: center; transition: transform 0.2s ease;" onmouseover="this.style.transform='translateY(-2px)'" onmouseout="this.style.transform='translateY(0)'">👁️ View PDF</a>
                        <a href="${msg.attachment_url}" download style="padding: 8px 16px; background: rgba(96, 165, 250, 0.2); border: 1px solid rgba(96, 165, 250, 0.4); border-radius: 8px; color: white; text-decoration: none; font-size: 12px; font-weight: 500; transition: transform 0.2s ease; cursor: pointer;" onmouseover="this.style.transform='translateY(-2px)'" onmouseout="this.style.transform='translateY(0)'">⬇️</a>
                      </div>
                    </div>
                  `;
                } else {
                  // Show generic file preview
                  const getFileIcon = () => {
                    if (fileName.match(/\.(doc|docx)$/i)) return '📝';
                    if (fileName.match(/\.(xls|xlsx)$/i)) return '📊';
                    if (fileName.match(/\.(txt)$/i)) return '📄';
                    if (fileName.match(/\.(zip|rar|7z)$/i)) return '🗜️';
                    return '📎';
                  };
                  
                  return `
                    <div style="padding: 12px; background: rgba(96, 165, 250, 0.1); border: 1px solid rgba(96, 165, 250, 0.3); border-radius: 10px; display: flex; align-items: center; gap: 12px;">
                      <span style="font-size: 32px;">${getFileIcon()}</span>
                      <div style="flex: 1;">
                        <div style="font-size: 13px; font-weight: 500; color: rgba(255,255,255,0.9);">${escapeHtml(fileName)}</div>
                        <div style="font-size: 11px; color: rgba(255,255,255,0.5); margin-top: 2px;">${fileType || 'File'}</div>
                      </div>
                      <a href="${msg.attachment_url}" download style="padding: 8px 16px; background: linear-gradient(135deg, #3b82f6, #2563eb); border-radius: 8px; color: white; text-decoration: none; font-size: 12px; font-weight: 500; transition: transform 0.2s ease; cursor: pointer;" onmouseover="this.style.transform='translateY(-2px)'" onmouseout="this.style.transform='translateY(0)'">Download</a>
                    </div>
                  `;
                }
              })()}
            </div>
          ` : ''}
          
          <div style="display: flex; gap: 8px; margin-top: 8px;">
            <button class="reply-btn" onclick="toggleReplyInput(${msg.id})">Reply</button>
            ${isAdminMessage && isAdmin ? `
              <button class="reply-btn" onclick="togglePinMessage(${msg.id})" title="${isPinned ? 'Unpin message' : 'Pin message'}">${isPinned ? '📍 Unpin' : '📌 Pin'}</button>
              <button class="reply-btn" onclick="editMessage(${msg.id})" title="Edit message">✏️ Edit</button>
            ` : ''}
          </div>
          
          <div class="reply-input-container" id="replyInput${msg.id}">
            <input 
              type="text" 
              class="reply-input" 
              id="replyText${msg.id}" 
              placeholder="Write a reply..." 
              onkeypress="if(event.key==='Enter') sendReply(${msg.id})">
            <button class="send-reply-btn" onclick="sendReply(${msg.id})">Send</button>
          </div>
          
          ${msg.replies && msg.replies.length > 0 ? `
            <div class="message-replies">
              ${msg.replies.filter(reply => {
                // Admin sees all replies
                if (isAdmin) return true;
                
                // Students see:
                // 1. Their own replies
                // 2. Admin replies (in their conversations)
                // 3. Other student replies ONLY in public threads (no admin involvement)
                const isOwnReply = reply.student_id === currentStudent.id;
                const isAdminReply = reply.student_name === 'Administrator' || reply.student_id === 0;
                const isOwnMessage = msg.student_id === currentStudent.id;
                
                if (isOwnReply || isAdminReply) return true;
                
                // For other students' replies, only show if it's a public thread
                // (message author is a student AND no admin has replied)
                const messageIsFromStudent = msg.student_id !== 0 && msg.student_name !== 'Administrator';
                const hasAdminReply = msg.replies.some(r => r.student_name === 'Administrator' || r.student_id === 0);
                
                // Show other student replies only in public threads (no admin involvement)
                return messageIsFromStudent && !hasAdminReply;
              }).map(reply => {
                const isAdminReply = reply.student_name === 'Administrator' || reply.student_id === 0;
                return `
                <div class="message-reply">
                  <div class="message-header">
                    <div style="display: flex; flex-direction: column; gap: 2px;">
                      <span class="message-author" style="${isAdminReply ? 'color: #ef4444; font-weight: 600;' : ''}">👤 ${escapeHtml(reply.student_name || 'Student')}</span>
                      <div style="font-size: 10px; color: rgba(255,255,255,0.4); padding-left: 24px;">
                        ${reply.student_group ? `<span>Group ${escapeHtml(reply.student_group)}</span>` : ''}${reply.student_group && reply.student_college ? '  ' : ''}${reply.student_college ? `<span>🎓 ${escapeHtml(reply.student_college)}</span>` : ''}
                      </div>
                    </div>
                    <div style="display: flex; align-items: center; gap: 8px;">
                      <span class="message-time">${formatMessageTime(reply.created_at)}</span>
                      ${isAdmin ? `<button class="delete-message-btn" onclick="deleteForumReply(${reply.id})" title="Delete reply">🗑️</button>` : ''}
                    </div>
                  </div>
                  <div class="message-text" style="${isAdminReply ? 'color: #ef4444;' : ''}">${formatMessageText(reply.message)}</div>
                  ${isAdminReply && !isAdmin ? `
                    <div style="
                      margin-top: 6px;
                      padding: 6px 10px;
                      background: linear-gradient(135deg, rgba(139, 92, 246, 0.12), rgba(109, 40, 217, 0.12));
                      border-left: 2px solid rgba(139, 92, 246, 0.4);
                      border-radius: 6px;
                      display: flex;
                      align-items: center;
                      gap: 6px;
                    ">
                      <span style="font-size: 13px;">🔒</span>
                      <span style="
                        font-size: 10px;
                        color: rgba(196, 181, 253, 0.85);
                        font-weight: 500;
                        letter-spacing: 0.2px;
                      ">Private - Only you and admin see this</span>
                    </div>
                  ` : ''}
                </div>
              `;
              }).join('')}
            </div>
          ` : ''}
        </div>
      `;
      }).join('');
      
      // FIX #1: RESTORE OPEN REPLY BOXES - Re-open any reply boxes that were open before re-render
      // This ensures the 30-second auto-refresh doesn't interrupt users typing replies
      setTimeout(() => {
        openReplyBoxes.forEach(messageId => {
          const container = document.getElementById(`replyInput${messageId}`);
          if (container) {
            container.classList.add('active');
            // Also restore focus if the user was typing
            const input = document.getElementById(`replyText${messageId}`);
            if (input && document.activeElement.tagName !== 'INPUT' && document.activeElement.tagName !== 'TEXTAREA') {
              input.focus();
            }
          }
        });
      }, 0);
    }
    
    /**
     * Handles file selection for forum message attachments
     */
    function handleFileSelection() {
      const fileInput = document.getElementById('forumFileInput');
      const preview = document.getElementById('fileAttachmentPreview');
      
      if (fileInput.files && fileInput.files[0]) {
        const file = fileInput.files[0];
        const maxSize = 10 * 1024 * 1024; // 10MB limit
        
        if (file.size > maxSize) {
          showCustomAlert('File size must be less than 10MB', 'error');
          fileInput.value = '';
          return;
        }
        
        preview.style.display = 'flex';
      }
    }
    
    /**
     * Clears the selected file attachment
     */
    function clearFileAttachment() {
      const fileInput = document.getElementById('forumFileInput');
      const preview = document.getElementById('fileAttachmentPreview');
      
      fileInput.value = '';
      preview.style.display = 'none';
    }

    // Private message mode tracking
    let isPrivateMode = false;
    
    /**
     * Toggles private message mode for student messages to administrator.
     * When enabled, shows indicator and sends message as private (admin-only visible).
     * 
     * @param {boolean} enable - True to enable private mode, false to disable
     */
    function togglePrivateMode(enable) {
      isPrivateMode = enable;
      const indicator = document.getElementById('privateMessageIndicator');
      const privateBtn = document.getElementById('privateMessageBtn');
      
      if (enable) {
        indicator.style.display = 'flex';
        privateBtn.style.opacity = '1';
        privateBtn.style.background = 'linear-gradient(135deg, rgba(139, 92, 246, 0.5), rgba(109, 40, 217, 0.5))';
      } else {
        indicator.style.display = 'none';
        privateBtn.style.opacity = '1';
        privateBtn.style.background = 'linear-gradient(135deg, rgba(139, 92, 246, 0.3), rgba(109, 40, 217, 0.3))';
      }
    }
    
    /**
     * Updates forum input visibility based on user role.
     * Hides private message button for admin users.
     */
    function updateForumInputVisibility() {
      const privateBtn = document.getElementById('privateMessageBtn');
      if (!privateBtn) return;
      
      const isAdmin = currentStudent && (currentStudent.isAdminChatMode || currentStudent.role === 'admin' || currentStudent.id === 0);
      
      if (isAdmin) {
        privateBtn.style.display = 'none'; // Hide for admin
      } else {
        privateBtn.style.display = 'flex'; // Show for students
      }
    }

    // Prevent duplicate sends
    let isSendingMessage = false;

    /**
     * Sends a new message to the student forum.
     * 
     * @async
     * @returns {Promise<void>}
     * 
     * @description
     * Workflow:
     * 1. Validates message input is not empty
     * 2. Checks currentStudent is authenticated
     * 3. Inserts new message into forum_messages table
     * 4. Reloads all messages to update UI
     * 5. Clears input field on success
     * 6. Shows error alert if insert fails
     * 
     * Message data saved:
     * - student_id: currentStudent.id
     * - student_name: currentStudent.name
     * - student_email: currentStudent.email or currentEmail
     * - message: sanitized text from input
     * - created_at: ISO timestamp
     * 
     * @example
     * <textarea id="forumMessageInput" onkeypress="if(event.key==='Enter') sendForumMessage()"></textarea>
     */
    async function sendForumMessage() {
      // Prevent duplicate sends
      if (isSendingMessage) return;
      
      const input = document.getElementById('forumInput');
      const fileInput = document.getElementById('forumFileInput');
      let message = input.value.trim();
      let attachmentUrl = null;
      let attachmentName = null;
      let attachmentType = null;
      
      // Check if there's a message or file attachment
      if (!message && (!fileInput.files || !fileInput.files[0])) return;
      
      // Allow admin (id: 0) or regular students (id > 0)
      if (!currentStudent || (currentStudent.id === undefined || currentStudent.id === null)) {
        showCustomAlert('Please log in to post messages', 'error');
        return;
      }
      
      // Remove @ symbols from the message before sending
      if (message) {
        message = message.replace(/@/g, '');
      }
      
      // Set sending flag
      isSendingMessage = true;
      
      try {
        // Upload file if present
        if (fileInput.files && fileInput.files[0]) {
          const file = fileInput.files[0];
          const fileExt = file.name.split('.').pop();
          const fileName = `${Date.now()}_${Math.random().toString(36).substring(7)}.${fileExt}`;
          const filePath = `chat-attachments/${fileName}`;
          
          // Upload to Supabase storage
          const { data: uploadData, error: uploadError } = await supabaseClient.storage
            .from('student-notes')
            .upload(filePath, file, {
              cacheControl: '3600',
              upsert: false
            });
          
          if (uploadError) {
            console.error('Error uploading file:', uploadError);
            showCustomAlert('Failed to upload file. Please try again.', 'error');
            return;
          }
          
          // Get public URL
          const { data: { publicUrl } } = supabaseClient.storage
            .from('student-notes')
            .getPublicUrl(filePath);
          
          attachmentUrl = publicUrl;
          attachmentName = file.name;
          attachmentType = file.type;
        }
        
        // Check if admin is posting
        const isAdminPosting = currentStudent.isAdminChatMode || currentStudent.role === 'admin';
        
        const messageData = {
          student_id: isAdminPosting ? 0 : currentStudent.id,
          student_name: isAdminPosting ? 'Administrator' : (currentStudent.name || 'Student'),
          student_email: currentStudent.email || currentEmail,
          student_group: isAdminPosting ? null : (currentStudent.group_code || null),
          student_college: isAdminPosting ? null : (currentStudent.college || null),
          message: message || '',
          is_private: !isAdminPosting && isPrivateMode, // Only students can send private messages
          created_at: new Date().toISOString()
        };
        
        // Add attachment fields if file was uploaded
        if (attachmentUrl) {
          messageData.attachment_url = attachmentUrl;
          messageData.attachment_name = attachmentName;
          messageData.attachment_type = attachmentType;
        }
        
        const { data, error } = await supabaseClient
          .from('forum_messages')
          .insert([messageData])
          .select();
        
        if (error) {
          console.error('Error sending message:', error);
          showCustomAlert('Failed to send message. Please try again.', 'error');
          isSendingMessage = false;
          return;
        }
        
        input.value = '';
        clearFileAttachment();
        togglePrivateMode(false); // Reset private mode after sending
        await loadForumMessages();
        
      } catch (error) {
        console.error('Send message error:', error);
        showCustomAlert('Failed to send message. Please try again.', 'error');
        clearFileAttachment(); // Clear file even on error
      } finally {
        // Always reset sending flag
        isSendingMessage = false;
      }
    }
    
    // Toggle Reply Input
    function toggleReplyInput(messageId) {
      const container = document.getElementById(`replyInput${messageId}`);
      const isActive = container.classList.contains('active');
      
      // Close all other reply inputs
      document.querySelectorAll('.reply-input-container.active').forEach(el => {
        el.classList.remove('active');
      });
      
      if (!isActive) {
        container.classList.add('active');
        document.getElementById(`replyText${messageId}`).focus();
      }
    }
    
    // Send Reply
    async function sendReply(messageId) {
      const input = document.getElementById(`replyText${messageId}`);
      let message = input.value.trim();
      
      if (!message) return;
      
      // Allow admin (id: 0) or regular students (id > 0)
      if (!currentStudent || (currentStudent.id === undefined || currentStudent.id === null)) {
        showCustomAlert('Please log in to reply', 'error');
        return;
      }
      
      // Remove @ symbols from the message before sending
      message = message.replace(/@/g, '');
      
      try {
        // Check if admin is replying
        const isAdminReplying = currentStudent.isAdminChatMode || currentStudent.role === 'admin';
        
        const { data, error } = await supabaseClient
          .from('forum_replies')
          .insert([{
            message_id: messageId,
            student_id: isAdminReplying ? 0 : currentStudent.id,
            student_name: isAdminReplying ? 'Administrator' : (currentStudent.name || 'Student'),
            student_group: isAdminReplying ? null : (currentStudent.group_code || null),
            student_college: isAdminReplying ? null : (currentStudent.college || null),
            message: message,
            created_at: new Date().toISOString()
          }])
          .select();
        
        if (error) {
          console.error('Error sending reply:', error);
          showCustomAlert('Failed to send reply. Please try again.', 'error');
          return;
        }
        
        input.value = '';
        document.getElementById(`replyInput${messageId}`).classList.remove('active');
        await loadForumMessages();
        
      } catch (error) {
        console.error('Send reply error:', error);
        showCustomAlert('Failed to send reply. Please try again.', 'error');
      }
    }
    
    // ---------- Admin Delete Functions ----------
    async function deleteForumMessage(messageId) {
      if (!isAdmin) {
        showCustomAlert('Only admins can delete messages', 'error');
        return;
      }
      
      const confirmed = await showCustomConfirm('Are you sure you want to delete this message? This will also delete all replies.');
      if (!confirmed) {
        return;
      }
      
      try {
        // First delete all replies
        const { error: repliesError } = await supabaseClient
          .from('forum_replies')
          .delete()
          .eq('message_id', messageId);
        
        if (repliesError) {
          console.error('Error deleting replies:', repliesError);
        }
        
        // Then delete the message
        const { error: messageError } = await supabaseClient
          .from('forum_messages')
          .delete()
          .eq('id', messageId);
        
        if (messageError) {
          console.error('Error deleting message:', messageError);
          showCustomAlert('Failed to delete message. Please try again.', 'error');
          return;
        }
        
        showCustomAlert('Message deleted successfully', 'success');
        await loadForumMessages();
        
      } catch (error) {
        console.error('Delete message error:', error);
        showCustomAlert('Failed to delete message. Please try again.', 'error');
      }
    }
    
    async function deleteForumReply(replyId) {
      if (!isAdmin) {
        showCustomAlert('Only admins can delete replies', 'error');
        return;
      }
      
      const confirmed = await showCustomConfirm('Are you sure you want to delete this reply?');
      if (!confirmed) {
        return;
      }
      
      try {
        const { error } = await supabaseClient
          .from('forum_replies')
          .delete()
          .eq('id', replyId);
        
        if (error) {
          console.error('Error deleting reply:', error);
          showCustomAlert('Failed to delete reply. Please try again.', 'error');
          return;
        }
        
        showCustomAlert('Reply deleted successfully', 'success');
        await loadForumMessages();
        
      } catch (error) {
        console.error('Delete reply error:', error);
        showCustomAlert('Failed to delete reply. Please try again.', 'error');
      }
    }
    
    // ---------- Admin Message Actions ----------
    async function togglePinMessage(messageId) {
      try {
        // Get current pin status
        const { data: currentMessage, error: fetchError } = await supabaseClient
          .from('forum_messages')
          .select('is_pinned')
          .eq('id', messageId)
          .single();
        
        if (fetchError) {
          console.error('Error fetching message:', fetchError);
          // If column doesn't exist, show helpful message
          if (fetchError.code === 'PGRST116' || fetchError.code === 'PGRST204') {
            showCustomAlert('Pin feature requires database update. Please run add-is-pinned-to-forum.sql', 'error');
            return;
          }
          showCustomAlert('Failed to fetch message status', 'error');
          return;
        }
        
        // Toggle the pin status
        const newPinStatus = !currentMessage.is_pinned;
        
        const { error: updateError } = await supabaseClient
          .from('forum_messages')
          .update({ is_pinned: newPinStatus })
          .eq('id', messageId);
        
        if (updateError) {
          console.error('Error updating pin status:', updateError);
          showCustomAlert('Failed to pin/unpin message', 'error');
          return;
        }
        
        showCustomAlert(newPinStatus ? '📌 Message pinned!' : 'Message unpinned', 'success');
        await loadForumMessages();
        
      } catch (error) {
        console.error('Toggle pin error:', error);
        showCustomAlert('Failed to toggle pin. Please try again.', 'error');
      }
    }
    
    async function editMessage(messageId) {
      const messageTextEl = document.getElementById(`messageText${messageId}`);
      const originalText = messageTextEl.getAttribute('data-original');
      
      // Show formatting toolbar and edit mode
      const modal = document.createElement('div');
      modal.className = 'custom-alert-overlay';
      modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.6);
        backdrop-filter: blur(8px);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 999999;
      `;
      
      modal.innerHTML = `
        <div style="
          background: linear-gradient(145deg, rgba(59, 130, 246, 0.15), rgba(37, 99, 235, 0.1));
          border: 1px solid rgba(59, 130, 246, 0.3);
          border-radius: 16px;
          padding: 24px;
          max-width: 600px;
          width: 90%;
          backdrop-filter: blur(12px);
          box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        ">
          <h3 style="color: white; margin-bottom: 16px;">✏️ Edit Message</h3>
          
          <div style="margin-bottom: 12px; display: flex; gap: 8px; flex-wrap: wrap;">
            <button onclick="formatText('bold')" style="padding: 8px 12px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); border-radius: 6px; color: white; cursor: pointer;"><strong>B</strong></button>
            <button onclick="formatText('italic')" style="padding: 8px 12px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); border-radius: 6px; color: white; cursor: pointer;"><em>I</em></button>
            <select id="fontSize" onchange="formatText('fontSize')" style="padding: 8px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); border-radius: 6px; color: white;">
              <option value="14">Normal</option>
              <option value="18">Large</option>
              <option value="24">Extra Large</option>
            </select>
          </div>
          
          <textarea id="editMessageText" style="
            width: 100%;
            min-height: 120px;
            padding: 12px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            color: white;
            font-size: 14px;
            resize: vertical;
            margin-bottom: 16px;
          ">${originalText.replace(/&quot;/g, '"').replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&amp;/g, '&')}</textarea>
          
          <div style="display: flex; gap: 12px;">
            <button onclick="this.closest('.custom-alert-overlay').remove()" style="
              flex: 1;
              padding: 12px;
              background: rgba(255, 255, 255, 0.1);
              border: 1px solid rgba(255, 255, 255, 0.2);
              border-radius: 8px;
              color: white;
              cursor: pointer;
            ">Cancel</button>
            <button onclick="saveEditedMessage(${messageId})" style="
              flex: 1;
              padding: 12px;
              background: linear-gradient(135deg, rgba(59, 130, 246, 0.9), rgba(37, 99, 235, 0.9));
              border: none;
              border-radius: 8px;
              color: white;
              font-weight: 600;
              cursor: pointer;
            ">Save</button>
          </div>
        </div>
      `;
      
      document.body.appendChild(modal);
    }
    
    function formatText(command) {
      const textarea = document.getElementById('editMessageText');
      const start = textarea.selectionStart;
      const end = textarea.selectionEnd;
      const selectedText = textarea.value.substring(start, end);
      
      if (!selectedText) {
        showCustomAlert('Please select text to format', 'info');
        return;
      }
      
      let formattedText = '';
      if (command === 'bold') {
        formattedText = `**${selectedText}**`;
      } else if (command === 'italic') {
        formattedText = `*${selectedText}*`;
      } else if (command === 'fontSize') {
        const size = document.getElementById('fontSize').value;
        formattedText = `<span style="font-size: ${size}px">${selectedText}</span>`;
      }
      
      textarea.value = textarea.value.substring(0, start) + formattedText + textarea.value.substring(end);
      textarea.focus();
      textarea.setSelectionRange(start, start + formattedText.length);
    }
    
    async function saveEditedMessage(messageId) {
      const newText = document.getElementById('editMessageText').value.trim();
      
      if (!newText) {
        showCustomAlert('Message cannot be empty', 'error');
        return;
      }
      
      try {
        // First try with edited_at column
        let updateData = { 
          message: newText,
          edited_at: new Date().toISOString()
        };
        
        let { error } = await supabaseClient
          .from('forum_messages')
          .update(updateData)
          .eq('id', messageId);
        
        // If column doesn't exist, try without edited_at
        if (error && error.code === 'PGRST204') {
          debugLog('⚠️ edited_at column not found, updating without it');
          updateData = { message: newText };
          const result = await supabaseClient
            .from('forum_messages')
            .update(updateData)
            .eq('id', messageId);
          error = result.error;
        }
        
        if (error) {
          console.error('Error updating message:', error);
          showCustomAlert('Failed to update message. Please try again.', 'error');
          return;
        }
        
        showCustomAlert('Message updated successfully', 'success');
        document.querySelector('.custom-alert-overlay').remove();
        await loadForumMessages();
        
      } catch (error) {
        console.error('Save message error:', error);
        showCustomAlert('Failed to save message', 'error');
      }
    }
    
    // ---------- @ Mention Autocomplete ----------
    let allStudents = [];
    let mentionSuggestions = null;
    
    async function loadStudentsForMentions() {
      try {
        const { data, error } = await supabaseClient
          .from('students')
          .select('id, name')
          .order('name');
        
        if (!error && data) {
          allStudents = data;
        }
      } catch (error) {
        console.error('Error loading students for mentions:', error);
      }
    }
    
    function setupMentionAutocomplete() {
      const input = document.getElementById('forumInput');
      if (!input) return;
      
      // Create suggestion dropdown
      mentionSuggestions = document.createElement('div');
      mentionSuggestions.style.cssText = `
        position: absolute;
        bottom: 100%;
        left: 0;
        right: 0;
        max-height: 200px;
        overflow-y: auto;
        background: rgba(30, 41, 59, 0.95);
        backdrop-filter: blur(12px);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 8px;
        margin-bottom: 8px;
        display: none;
        z-index: 1000;
      `;
      input.parentElement.style.position = 'relative';
      input.parentElement.appendChild(mentionSuggestions);
      
      // PERFORMANCE: Debounced @ mention search
      const debouncedMentionSearch = debounce(function(text, cursorPos) {
        const textBeforeCursor = text.substring(0, cursorPos);
        const atIndex = textBeforeCursor.lastIndexOf('@');
        
        if (atIndex !== -1 && cursorPos - atIndex <= 20) {
          const searchTerm = textBeforeCursor.substring(atIndex + 1).toLowerCase();
          const matches = allStudents.filter(s => 
            s.name.toLowerCase().includes(searchTerm)
          ).slice(0, 5);
          
          if (matches.length > 0 && searchTerm) {
            showMentionSuggestions(matches, atIndex, cursorPos);
          } else {
            mentionSuggestions.style.display = 'none';
          }
        } else {
          mentionSuggestions.style.display = 'none';
        }
      }, 200);
      
      input.addEventListener('input', function(e) {
        debouncedMentionSearch(this.value, this.selectionStart);
      });
    }
    
    function showMentionSuggestions(matches, atIndex, cursorPos) {
      mentionSuggestions.innerHTML = matches.map(student => `
        <div onclick="insertMention('${student.name.replace(/'/g, "\\'")}', ${atIndex}, ${cursorPos})" style="
          padding: 10px 12px;
          cursor: pointer;
          color: white;
          border-bottom: 1px solid rgba(255,255,255,0.05);
        " onmouseover="this.style.background='rgba(59, 130, 246, 0.2)'" onmouseout="this.style.background=''">
          👤 ${student.name}
        </div>
      `).join('');
      mentionSuggestions.style.display = 'block';
    }
    
    function insertMention(name, atIndex, cursorPos) {
      const input = document.getElementById('forumInput');
      const text = input.value;
      const beforeAt = text.substring(0, atIndex);
      const afterCursor = text.substring(cursorPos);
      input.value = beforeAt + `@${name} ` + afterCursor;
      mentionSuggestions.style.display = 'none';
      input.focus();
    }
    
    // Update Forum Badge (unread count)
    function updateForumBadge() {
      const badge = document.getElementById('forumBadge');
      const newMessages = forumMessages.filter(msg => {
        const msgDate = new Date(msg.created_at);
        const lastViewed = localStorage.getItem('lastForumView');
        return !lastViewed || msgDate > new Date(lastViewed);
      }).length;
      
      if (newMessages > 0) {
        badge.textContent = newMessages;
        badge.style.display = 'block';
      } else {
        badge.style.display = 'none';
      }
    }
    
    // Mark forum as viewed
    function markForumViewed() {
      localStorage.setItem('lastForumView', new Date().toISOString());
      updateForumBadge();
    }
    
    // Format message time
    function formatMessageTime(timestamp) {
      const date = new Date(timestamp);
      const now = new Date();
      const diff = now - date;
      const minutes = Math.floor(diff / 60000);
      const hours = Math.floor(diff / 3600000);
      const days = Math.floor(diff / 86400000);
      
      if (minutes < 1) return 'Just now';
      if (minutes < 60) return `${minutes}m ago`;
      if (hours < 24) return `${hours}h ago`;
      if (days < 7) return `${days}d ago`;
      return date.toLocaleDateString();
    }
    
    // ==========================================================================
    // UTILITY FUNCTIONS
    // ==========================================================================
    
    // ---------- Security & Sanitization ----------
    // Escape HTML to prevent XSS
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }
    
    // ---------- Forum Notification Checker ----------
    // PERFORMANCE FIX: Check for new messages periodically (when forum is closed) - using interval manager
    // Only check every 60 seconds to reduce Supabase load
    intervalManager.set('forumNotification', () => {
      if (!document.getElementById('forumModal').classList.contains('active')) {
        // Silently check for new messages
        supabaseClient
          .from('forum_messages')
          .select('id, created_at')
          .order('created_at', { ascending: false })
          .limit(1)
          .then(({ data }) => {
            if (data && data.length > 0) {
              const lastViewed = localStorage.getItem('lastForumView');
              if (!lastViewed || new Date(data[0].created_at) > new Date(lastViewed)) {
                document.getElementById('forumBadge').style.display = 'block';
              }
            }
          });
      }
    }, 60000); // Check every 60 seconds (reduced from 30)
    
    // Custom Alert Dialog
    function showCustomAlert(message, type = 'info') {
      // Remove existing alert if any
      const existing = document.querySelector('.custom-alert-overlay');
      if (existing) existing.remove();
      
      const overlay = document.createElement('div');
      overlay.className = 'custom-alert-overlay';
      overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.6);
        backdrop-filter: blur(8px);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 999999;
        animation: fadeIn 0.2s ease;
      `;
      
      const icon = type === 'error' ? '❌' : type === 'success' ? '✅' : 'ℹ️';
      const bgColor = type === 'error' ? 'linear-gradient(145deg, rgba(239, 68, 68, 0.15), rgba(220, 38, 38, 0.1))' : 
                      type === 'success' ? 'linear-gradient(145deg, rgba(34, 197, 94, 0.15), rgba(22, 163, 74, 0.1))' : 
                      'linear-gradient(145deg, rgba(59, 130, 246, 0.15), rgba(37, 99, 235, 0.1))';
      
      overlay.innerHTML = `
        <div class="custom-alert-box" style="
          background: ${bgColor};
          border: 1px solid ${type === 'error' ? 'rgba(239, 68, 68, 0.3)' : type === 'success' ? 'rgba(34, 197, 94, 0.3)' : 'rgba(59, 130, 246, 0.3)'};
          border-radius: 16px;
          padding: 32px;
          max-width: 400px;
          width: 90%;
          backdrop-filter: blur(12px);
          box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
          animation: slideUp 0.3s ease;
        ">
          <div style="font-size: 48px; text-align: center; margin-bottom: 16px;">${icon}</div>
          <div style="color: white; font-size: 16px; text-align: center; margin-bottom: 24px; line-height: 1.5;">${message}</div>
          <button onclick="this.closest('.custom-alert-overlay').remove()" style="
            width: 100%;
            padding: 12px;
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.9), rgba(37, 99, 235, 0.9));
            border: none;
            border-radius: 8px;
            color: white;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
          " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 8px 16px rgba(59, 130, 246, 0.3)'" onmouseout="this.style.transform=''; this.style.boxShadow=''">
            OK
          </button>
        </div>
      `;
      
      document.body.appendChild(overlay);
      
      // Auto-remove after 5 seconds
      setTimeout(() => {
        if (overlay.parentElement) overlay.remove();
      }, 5000);
    }
    
    function showCustomConfirm(message) {
      return new Promise((resolve) => {
        // Remove existing overlay if any
        const existing = document.querySelector('.custom-confirm-overlay');
        if (existing) existing.remove();
        
        const overlay = document.createElement('div');
        overlay.className = 'custom-confirm-overlay';
        overlay.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background: rgba(0, 0, 0, 0.6);
          backdrop-filter: blur(8px);
          display: flex;
          align-items: center;
          justify-content: center;
          z-index: 999999;
          animation: fadeIn 0.2s ease;
        `;
        
        overlay.innerHTML = `
          <div class="custom-confirm-box" style="
            background: linear-gradient(145deg, rgba(239, 68, 68, 0.15), rgba(220, 38, 38, 0.1));
            border: 1px solid rgba(239, 68, 68, 0.3);
            border-radius: 16px;
            padding: 32px;
            max-width: 400px;
            width: 90%;
            backdrop-filter: blur(12px);
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            animation: slideUp 0.3s ease;
          ">
            <div style="font-size: 48px; text-align: center; margin-bottom: 16px;">⚠️</div>
            <div style="color: white; font-size: 16px; text-align: center; margin-bottom: 24px; line-height: 1.5;">${message}</div>
            <div style="display: flex; gap: 12px;">
              <button class="confirm-cancel-btn" style="
                flex: 1;
                padding: 12px;
                background: rgba(255, 255, 255, 0.1);
                border: 1px solid rgba(255, 255, 255, 0.2);
                border-radius: 8px;
                color: white;
                font-size: 14px;
                font-weight: 600;
                cursor: pointer;
                transition: all 0.2s ease;
              " onmouseover="this.style.background='rgba(255, 255, 255, 0.15)'" onmouseout="this.style.background='rgba(255, 255, 255, 0.1)'">
                Cancel
              </button>
              <button class="confirm-ok-btn" style="
                flex: 1;
                padding: 12px;
                background: linear-gradient(135deg, rgba(239, 68, 68, 0.9), rgba(220, 38, 38, 0.9));
                border: none;
                border-radius: 8px;
                color: white;
                font-size: 14px;
                font-weight: 600;
                cursor: pointer;
                transition: all 0.2s ease;
              " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 8px 16px rgba(239, 68, 68, 0.3)'" onmouseout="this.style.transform=''; this.style.boxShadow=''">
                OK
              </button>
            </div>
          </div>
        `;
        
        document.body.appendChild(overlay);
        
        // Handle button clicks
        overlay.querySelector('.confirm-cancel-btn').onclick = () => {
          overlay.remove();
          resolve(false);
        };
        
        overlay.querySelector('.confirm-ok-btn').onclick = () => {
          overlay.remove();
          resolve(true);
        };
        
        // Handle overlay click (cancel)
        overlay.onclick = (e) => {
          if (e.target === overlay) {
            overlay.remove();
            resolve(false);
          }
        };
      });
    }
    
    /**
     * Loads classroom notes/assignments filtered by student's group and payment status.
     * 
     * @async
     * @param {Array<Object>} payments - Array of payment objects with status and date
     * @returns {Promise<Array<Object>>} Array of accessible note assignments
     * 
     * @description
     * Complex note loading with payment-based access control:
     * 
     * 1. **Group Filtering**: Normalizes student.group (handles "Group C", "C", etc.)
     * 2. **Note Query**: Fetches from note_assignments table with:
     *    - Group match (A-F)
     *    - Active status (deleted = false)
     *    - Joined with note_templates for metadata
     * 
     * 3. **Payment Locking**: For each note:
     *    - If note.requires_payment = true → checks payment history
     *    - Locked if no matching paid status for note's date
     *    - Unlocked if payment found OR note doesn't require payment
     * 
     * 4. **UI Rendering**: Creates cards showing:
     *    - Lock icon (🔒) for payment-locked notes
     *    - System icon + name
     *    - PDF download link (if unlocked)
     *    - Payment prompt (if locked)
     * 
     * 5. **Global State Updates**:
     *    - Sets allSystemNotes array
     *    - Calls refreshSystemAssignmentStats()
     *    - Updates notification badges
     * 
     * @example
     * const payments = await loadPaymentHistory(student);
     * await loadClassroomUpdates(payments);
     */
    async function loadClassroomUpdates(payments) {
      // Use passed payments or fall back to global currentPayments
      const paymentData = payments || currentPayments || [];
      
      const classroomList = document.getElementById('classroomList');
      classroomList.innerHTML = '<div style="text-align: center; color: rgba(255,255,255,0.7); padding: 40px;">Loading your notes...</div>';
      
      debugDebug('💰 Payment data for notes:', {
        passedPayments: !!payments,
        globalPayments: !!currentPayments,
        usingPayments: paymentData.length,
        firstPayment: paymentData[0]
      });
      
      try {
        const studentId = currentStudent?.id;
        let studentGroup = currentStudent?.group || currentStudent?.group_name;
        
        if (!studentId) {
          console.warn('⚠️ No student ID found');
          classroomList.innerHTML = '<div style="text-align: center; color: rgba(255,255,255,0.7); padding: 40px;">No student found.</div>';
          allSystemNotes = [];
          refreshSystemAssignmentStats();
          updateSystemNotifications();
          return [];
        }
        
        // Normalize group to format "Group X"
        if (studentGroup && !studentGroup.toLowerCase().startsWith('group')) {
          studentGroup = `Group ${studentGroup}`;
        }
        
        if (DEBUG_MODE) debugLog('📚 Loading notes for Student ID:', studentId, 'Group:', studentGroup);
        
        // Fetch permissions for this student (both group and individual access)
        // 🔥 FIX: Also fetch class_date and granted_at for per-group posting dates
        const { data: permissions, error: permError} = await supabaseClient
          .from('student_note_permissions')
          .select('note_id, is_accessible, class_date, granted_at')
          .or(`student_id.eq.${studentId},and(group_name.eq.${studentGroup},student_id.is.null)`)
          .eq('is_accessible', true);
        
        if (permError) {
          console.error('❌ Error loading permissions:', permError);
        }
        
        const permissionNoteIds = permissions?.map(p => p.note_id) || [];
        
        if (DEBUG_MODE) debugLog(`✅ Found ${permissionNoteIds.length} notes via permissions`);
        
        // Fetch FREE access grants for this student (BEFORE loading notes)
        const studentGroupLetter = currentStudent.group_letter || currentStudent.group || currentStudent.group_name;
        const normalizedGroupLetter = studentGroupLetter ? studentGroupLetter.toString().replace(/Group\s*/i, '').trim().toUpperCase() : null;
        
        console.log('🚨 [CRITICAL DEBUG - FREE ACCESS]');
        console.log('📊 Student ID:', studentId);
        console.log('👤 Student Name:', currentStudent.name);
        console.log('🏫 Raw Group:', studentGroupLetter);
        console.log('🔤 Normalized Group Letter:', normalizedGroupLetter);
        
        if (!normalizedGroupLetter) {
          console.error('❌ CRITICAL: Student has no group assigned! This will show ALL group notes!');
        }
        
        // Query for individual student access OR group access
        let freeAccessQuery = supabaseClient
          .from('note_free_access')
          .select('note_id, access_type, group_letter, student_id, created_at, class_date'); // Include per-group class_date when available
        
        // Build OR condition: individual access for this student OR group access for their group
        if (normalizedGroupLetter) {
          freeAccessQuery = freeAccessQuery.or(`student_id.eq.${studentId},and(access_type.eq.group,group_letter.eq.${normalizedGroupLetter})`);
          console.log('✅ Applied group filter:', `student_id.eq.${studentId},and(access_type.eq.group,group_letter.eq.${normalizedGroupLetter})`);
        } else {
          freeAccessQuery = freeAccessQuery.eq('student_id', studentId);
          console.warn('⚠️ No group - only showing individual access');
        }
        
        const { data: freeAccessGrants, error: freeAccessError } = await freeAccessQuery;
        
        console.log('📦 Free Access Query Result:', freeAccessGrants);
        console.log('📊 Total free access grants:', freeAccessGrants?.length || 0);
        if (freeAccessGrants && freeAccessGrants.length > 0) {
          console.log('📋 Sample grants:', freeAccessGrants.slice(0, 5));
          console.log('🏫 Unique group letters in grants:', [...new Set(freeAccessGrants.map(g => g.group_letter))]);
        }
        
        if (freeAccessError) {
          console.error('❌ Error loading free access grants:', freeAccessError);
        }
        
        const freeAccessNoteIds = freeAccessGrants?.map(fa => fa.note_id) || [];
        
        // 🔥 FIX: Create map of note_id -> class_date from BOTH free_access AND permissions tables
        // This gives us the ACTUAL date each note was posted to THIS group
        const notePostDateMap = new Map();
        
        // 1. Add dates from FREE ACCESS grants
        if (freeAccessGrants) {
          const normalizeDateString = (value) => {
            if (!value) return null;
            return value.includes('T') ? value.split('T')[0] : value;
          };

          freeAccessGrants.forEach(grant => {
            const classDateString = normalizeDateString(grant.class_date);
            const createdDateString = normalizeDateString(grant.created_at);

            if (classDateString) {
              // Prefer explicit class_date recorded when admin posted for this group
              notePostDateMap.set(grant.note_id, {
                dateString: classDateString,
                source: 'free_access_class_date'
              });
            } else if (!notePostDateMap.has(grant.note_id) && createdDateString) {
              // Fallback: use created_at only if no class_date captured yet
              notePostDateMap.set(grant.note_id, {
                dateString: createdDateString,
                source: 'free_access_created_at'
              });
            }
          });
        }
        
        // 2. Add dates from PERMISSION-BASED PAID ACCESS (student_note_permissions)
        // CRITICAL: This ensures paid notes show the correct per-group posting date
        if (permissions) {
          const normalizeDateString = (value) => {
            if (!value) return null;
            return value.includes('T') ? value.split('T')[0] : value;
          };

          permissions.forEach(permission => {
            const classDateString = normalizeDateString(permission.class_date);
            const grantedAtString = normalizeDateString(permission.granted_at);

            // Only set if not already set by free_access (free_access takes priority)
            if (!notePostDateMap.has(permission.note_id)) {
              if (classDateString) {
                // Use the class_date field from student_note_permissions (set when admin posts notes)
                notePostDateMap.set(permission.note_id, {
                  dateString: classDateString,
                  source: 'permission_class_date'
                });
              } else if (grantedAtString) {
                // Fallback: use granted_at timestamp
                notePostDateMap.set(permission.note_id, {
                  dateString: grantedAtString,
                  source: 'permission_granted_at'
                });
              }
            }
          });
        }
        
        console.log('📅 Note post dates loaded:', notePostDateMap.size, 'notes with specific post dates');
        console.log('   Sources:', Array.from(notePostDateMap.values()).reduce((acc, v) => {
          acc[v.source] = (acc[v.source] || 0) + 1;
          return acc;
        }, {}));
        
        // Combine permission-based access AND free access
        const allAccessibleNoteIds = [...new Set([...permissionNoteIds, ...freeAccessNoteIds])];
        
        if (DEBUG_MODE) {
          debugLog('🔓 Total Accessible Notes:', allAccessibleNoteIds.length, '(Permissions:', permissionNoteIds.length, '+ Free:', freeAccessNoteIds.length, ')');
        }
        
        if (allAccessibleNoteIds.length === 0) {
          classroomList.innerHTML = '<div style="text-align: center; color: rgba(255,255,255,0.7); padding: 40px;">No notes available yet.</div>';
          allSystemNotes = [];
          refreshSystemAssignmentStats();
          updateSystemNotifications();
          return [];
        }
        
        // Fetch the actual notes (using combined permissions + free access)
        const { data: notes, error: notesError } = await supabaseClient
          .from('student_notes')
          .select('*')
          .in('id', allAccessibleNoteIds)
          .order('updated_at', { ascending: false }); // Use updated_at (when note was last modified/posted)
        
        if (notesError) {
          console.error('❌ Error loading notes:', notesError);
          classroomList.innerHTML = '<div style="text-align: center; color: rgba(255,255,255,0.7); padding: 40px;">Error loading notes.</div>';
          allSystemNotes = [];
          refreshSystemAssignmentStats();
          updateSystemNotifications();
          return [];
        }
        
        if (DEBUG_MODE) debugLog(`✅ Loaded ${notes?.length || 0} notes`);
        
        // USE THE PASSED PAYMENT DATA (already loaded by loadPaymentHistory)
        const mergedPaymentRecords = paymentData;
        
        // Create a Set of note IDs that have free access (using data from earlier query)
        const freeNoteIds = new Set(freeAccessNoteIds || []);
        
        if (DEBUG_MODE) debugLog(`✨ FREE access notes: ${freeNoteIds.size} notes`);
        
        // Build set of absence dates for checking if student was absent on note dates
        const absentDatesSet = new Set(
          (mergedPaymentRecords || [])
            .filter(p => p.status === 'absent')
            .map(p => {
              if (p.dateString) return p.dateString;
              if (typeof p.date === 'string') return p.date.split('T')[0];
              if (p.date instanceof Date) return p.date.toISOString().split('T')[0];
              return null;
            })
            .filter(d => d !== null)
        );
        
        if (DEBUG_MODE) debugLog(`🚫 Absent dates: ${absentDatesSet.size} dates (${Array.from(absentDatesSet).join(', ')})`);
        
        // 🔐 PAYMENT-LOCKED NOTES ENGINE: Compute payment status for all notes
        // This uses the student's schedule and payment history to determine which notes are unlocked
        const notePaymentStatus = computeNotePaymentStatus(
          notes,
          currentStudent,
          mergedPaymentRecords,
          currentGroupScheduleData,  // Student's schedule data loaded earlier
          freeNoteIds,  // Pass free access note IDs to unlock notes (unless absent)
          notePostDateMap  // 🔥 FIX: Pass per-group posting dates for payment checking
        );
        
        if (DEBUG_MODE) {
          console.log(`   - Unlocked by payment: ${Array.from(notePaymentStatus.values()).filter(v => v).length}`);
          console.log(`   - Locked: ${Array.from(notePaymentStatus.values()).filter(v => !v).length}`);
        }
        
        // Transform notes to match expected format
        const transformedNotes = notes.map(note => {
          // 🔥 FIX: Use the ACTUAL post date for this group from note_free_access.created_at
          // This shows when the note was posted to THIS specific group, not the global class_date
          let displayDate;
          const groupPostMeta = notePostDateMap.get(note.id);
          
          if (groupPostMeta?.dateString) {
            // Use the per-group class_date (or fallback) captured from note_free_access
            const dateParts = groupPostMeta.dateString.split('-');
            displayDate = new Date(dateParts[0], dateParts[1] - 1, dateParts[2]);
            console.log(`📅 Note ${note.id} "${note.title}" posted to this group on: ${groupPostMeta.dateString} (source: ${groupPostMeta.source})`);
          } else if (note.class_date) {
            // Fallback to class_date if no free access date (shouldn't happen for free notes)
            const dateParts = note.class_date.split('T')[0].split('-');
            displayDate = new Date(dateParts[0], dateParts[1] - 1, dateParts[2]);
          } else if (note.updated_at) {
            // Parse updated_at in local timezone
            const dateStr = note.updated_at.split('T')[0];
            const dateParts = dateStr.split('-');
            displayDate = new Date(dateParts[0], dateParts[1] - 1, dateParts[2]);
          } else {
            // Parse created_at in local timezone
            const dateStr = note.created_at.split('T')[0];
            const dateParts = dateStr.split('-');
            displayDate = new Date(dateParts[0], dateParts[1] - 1, dateParts[2]);
          }
          
          // Check if this specific note requires payment
          const noteRequiresPayment = note.requires_payment === true;
          
          // Check if student has FREE access to this note
          const hasFreeAccess = freeNoteIds.has(note.id);
          
          // 🚫 Check if student was ABSENT on this note's date
          // 🔥 FIX: Use group-specific post date (from note_free_access), NOT global class_date
          const noteClassDate = groupPostMeta?.dateString || 
                                (note.class_date ? note.class_date.split('T')[0] : null);
          const isAbsent = noteClassDate ? absentDatesSet.has(noteClassDate) : false;
          
          // 🔐 Use payment-locked notes engine result
          const studentHasPaidForThisNote = notePaymentStatus.get(note.id) || false;
          
          // 🔥 FIX: Free access notes STILL require payment for the specific date
          // Free access just means they CAN see it's there, not that it's unlocked
          // Student can access if: note doesn't require payment OR has paid for this date
          const isPaid = !noteRequiresPayment || studentHasPaidForThisNote;
          
          if (DEBUG_MODE && noteRequiresPayment && !isPaid && !hasFreeAccess) {
            const classDate = note.class_date ? note.class_date.split('T')[0] : 'unknown';
            debugLog(`🔒 Note "${note.title}" (${classDate}) is LOCKED - payment required`);
          }
          
          if (DEBUG_MODE && isAbsent) {
            debugLog(`🚫 Note "${note.title}" (${noteClassDate}) - Student was ABSENT`);
          }
          
          // CONSISTENT: Use helper function to get system name
          const systemName = getSystemNameFromNote(note);
          
          const transformedNote = {
            id: note.id,
            date: displayDate, // Use posted_at for display
            title: note.title || 'Untitled Note',
            text: note.description || note.title || 'Note', 
            isPaid: isPaid,
            isAbsent: isAbsent, // Flag to show if student was absent
            hasFreeAccess: hasFreeAccess, // Pass FREE access flag to card
            course: systemName,
            folderIcon: '📚',
            type: 'material',
            isTemplateMissing: false,
            system: systemName,
            read: isNoteOpened(note.id), // Track which notes have been opened
            attachments: (note.file_path || note.pdf_url) ? [{
              title: (note.title || 'Note') + '.pdf',
              url: note.file_path || note.pdf_url, // Storage path for Protected-PDF-Viewer
              noteId: note.id,
              type: 'pdf'
            }] : []
          };
          
          // Debug log to see what we're working with
          if (DEBUG_MODE && transformedNote.attachments.length > 0) {
            debugLog('📄 Note attachment URL:', transformedNote.attachments[0].url);
          }
          
          return transformedNote;
        });
        
        allSystemNotes = transformedNotes;
        refreshSystemAssignmentStats();
        
        // 🔄 Refresh the progress carousel with new note data
        await loadSystemsProgress();
        
        // Sort notes by date - NEWEST FIRST
        const sortedNotes = [...transformedNotes].sort((a, b) => b.date - a.date);
        
        displayNotes(sortedNotes);
        updateSystemNotifications();
        
        return transformedNotes;
        
      } catch (error) {
        console.error('❌ Error in loadClassroomUpdates:', error);
        classroomList.innerHTML = '<div style="text-align: center; color: rgba(255,255,255,0.7); padding: 40px;">Error loading notes.</div>';
        allSystemNotes = [];
        refreshSystemAssignmentStats();
        updateSystemNotifications();
        return [];
      }
    }
    
    // Filter notes by system and update UI
  function filterNotesBySystem(systemName) {
      selectedSystem = systemName;
      
      // Normalize system names for comparison (handle "Cardiovascular" vs "Cardiovascular System")
      const normalizeSystemName = (name) => {
        if (!name) return '';
        // Remove " System" suffix for comparison
        return name.replace(/\s+System$/i, '').trim().toLowerCase();
      };
      
      const normalizedSearchName = normalizeSystemName(systemName);
      
      let filteredNotes = allSystemNotes.filter(note => {
        const systemNameFromNote = getSystemNameFromNote(note);
        const normalizedNoteName = normalizeSystemName(systemNameFromNote);
        return normalizedNoteName === normalizedSearchName;
      });
      
      // Apply locked filter if active
      if (showLockedOnly) {
        filteredNotes = filteredNotes.filter(note => !note.isPaid && note.type !== 'warning');
      }

      document.querySelectorAll('.system-card').forEach(card => {
        if (card.dataset.systemName === systemName) {
          card.classList.add('selected');
        } else {
          card.classList.remove('selected');
        }
      });

      const escapedName = typeof CSS !== 'undefined' && CSS.escape
        ? CSS.escape(systemName)
        : systemName;
      const targetCard = document.querySelector(`.system-card[data-system-name="${escapedName}"]`);
      if (targetCard) {
        centerSystemCard(targetCard);
      }

      updateNotesHeader(systemName);
      
      // Sort filtered notes by date - NEWEST FIRST
      const sortedNotes = [...filteredNotes].sort((a, b) => b.date - a.date);
      displayNotes(sortedNotes);

      filteredNotes.forEach(note => {
        note.read = true;
      });

      updateSystemNotifications();

      const classroomList = document.getElementById('classroomList');
      if (classroomList) {
        classroomList.scrollIntoView({ behavior: 'smooth', block: 'start' });
      }
    }
    
    // Toggle locked notes filter
    let showLockedOnly = false;
    function toggleLockedFilter() {
      const toggleBtn = document.getElementById('lockedFilterToggle');
      showLockedOnly = !showLockedOnly;
      
      if (showLockedOnly) {
        // Active state
        toggleBtn.classList.add('active');
        toggleBtn.style.background = 'linear-gradient(135deg, rgba(239, 68, 68, 0.3), rgba(220, 38, 38, 0.2))';
        toggleBtn.style.borderColor = 'rgba(239, 68, 68, 0.5)';
        toggleBtn.style.color = 'rgba(255, 255, 255, 0.95)';
        toggleBtn.style.boxShadow = '0 0 20px rgba(239, 68, 68, 0.4)';
      } else {
        // Inactive state
        toggleBtn.classList.remove('active');
        toggleBtn.style.background = 'rgba(255, 255, 255, 0.05)';
        toggleBtn.style.borderColor = 'rgba(255, 255, 255, 0.1)';
        toggleBtn.style.color = 'rgba(255, 255, 255, 0.7)';
        toggleBtn.style.boxShadow = 'none';
      }
      
      // Re-apply current view (search or filter)
      const searchInput = document.getElementById('notesSearchInput');
      const searchTerm = searchInput?.value?.trim() || '';
      
      if (searchTerm) {
        searchNotes(searchTerm);
      } else if (selectedSystem) {
        filterNotesBySystem(selectedSystem);
      } else {
        showAllNotes();
      }
    }
    
    // Show all notes (clear filter)
    function showAllNotes() {
      selectedSystem = null;
      
      updateNotesHeader(null);
      document.querySelectorAll('.system-card').forEach(c => c.classList.remove('selected'));
      
      // Sort all notes by date - NEWEST FIRST
      let notesToShow = [...allSystemNotes];
      
      // Apply locked filter if active
      if (showLockedOnly) {
        notesToShow = notesToShow.filter(note => !note.isPaid && note.type !== 'warning');
      }
      
      const sortedNotes = notesToShow.sort((a, b) => b.date - a.date);
      displayNotes(sortedNotes);
      updateSystemNotifications();
    }
    
    // Search notes by title, date, or system
    function searchNotes(searchTerm) {
      const term = searchTerm.toLowerCase().trim();
      
      // If search is empty, show all notes (or filtered by system if one is selected)
      if (!term) {
        if (selectedSystem) {
          filterNotesBySystem(selectedSystem);
        } else {
          showAllNotes();
        }
        return;
      }
      
      // Filter notes based on search term
      let searchResults = allSystemNotes.filter(note => {
        // Search in title
        const titleMatch = (note.title || '').toLowerCase().includes(term);
        
        // Search in system name (CONSISTENT: use helper function)
        const systemName = getSystemNameFromNote(note);
        const systemMatch = (systemName || '').toLowerCase().includes(term);
        
        // Search in date (formatted)
        const dateMatch = note.date.toLocaleDateString().toLowerCase().includes(term);
        
        // Search in course/badge text
        const courseMatch = (note.course || '').toLowerCase().includes(term);
        
        return titleMatch || systemMatch || dateMatch || courseMatch;
      });
      
      // Apply locked filter if active
      if (showLockedOnly) {
        searchResults = searchResults.filter(note => !note.isPaid && note.type !== 'warning');
      }
      
      // Update header to show search results
      const notesHeader = document.querySelector('.card-title-left');
      if (notesHeader) {
        notesHeader.innerHTML = `
          <span>🔍</span>
          Search Results
          <button 
            onclick="document.getElementById('notesSearchInput').value=''; searchNotes('');" 
            style="
              margin-left: 12px;
              padding: 6px 12px;
              border-radius: 8px;
              background: rgba(239, 68, 68, 0.2);
              border: 1px solid rgba(239, 68, 68, 0.4);
              color: rgba(255, 255, 255, 0.9);
              font-size: 13px;
              font-weight: 600;
              cursor: pointer;
              transition: all 0.3s ease;
            "
            onmouseover="this.style.background='rgba(239, 68, 68, 0.3)'"
            onmouseout="this.style.background='rgba(239, 68, 68, 0.2)'"
          >
            Clear Search
          </button>
        `;
      }
      
      // Clear system selection
      document.querySelectorAll('.system-card').forEach(c => c.classList.remove('selected'));
      selectedSystem = null;
      
      // Sort search results by date - NEWEST FIRST
      const sortedResults = [...searchResults].sort((a, b) => b.date - a.date);
      
      // Display search results
      displayNotes(sortedResults);
      
      // Show message if no results
      if (searchResults.length === 0) {
        const classroomList = document.getElementById('classroomList');
        if (classroomList) {
          classroomList.innerHTML = `
            <div class="announcement-empty" style="padding: 40px; text-align: center;">
              <div style="font-size: 48px; margin-bottom: 16px;">🔍</div>
              <div style="font-size: 18px; font-weight: 600; margin-bottom: 8px;">No notes found</div>
              <div style="font-size: 14px; color: rgba(255, 255, 255, 0.6);">
                Try a different search term or 
                <a href="#" onclick="document.getElementById('notesSearchInput').value=''; searchNotes(''); return false;" 
                   style="color: rgba(102, 126, 234, 0.9); text-decoration: underline;">
                  clear your search
                </a>
              </div>
            </div>
          `;
        }
      }
    }
    
    // Debounced version of searchNotes for performance (prevents lag on typing)
    const debouncedSearchNotes = debounce(searchNotes, 200);
    
    /**
     * Handles the notes search input event and updates clear button visibility
     */
    function handleNotesSearchInput(value) {
      const clearBtn = document.getElementById('notesSearchClear');
      if (clearBtn) {
        clearBtn.style.display = value.length > 0 ? 'block' : 'none';
      }
      debouncedSearchNotes(value);
    }
    
    /**
     * Clears the notes search input
     */
    function clearNotesSearch() {
      const searchInput = document.getElementById('notesSearchInput');
      const clearBtn = document.getElementById('notesSearchClear');
      
      if (searchInput) {
        searchInput.value = '';
        searchInput.focus();
        searchNotes(''); // Immediately clear the search
      }
      
      if (clearBtn) {
        clearBtn.style.display = 'none';
      }
    }
    
        function updateNotesHeader(systemName) {
      const titleElement = document.getElementById('notesCardTitle');
      if (!titleElement) return;

      const left = titleElement.querySelector('.card-title-left');
      const backBtn = document.getElementById('backToAllNotesBtn');

      if (systemName) {
        const systemEmoji = nclexSystems.find(s => s.name === systemName)?.icon || '📚';
        left.innerHTML = `<span>${systemEmoji}</span>${systemName} - Notes`;
        
        // Show the back button
        if (backBtn) {
          backBtn.style.display = 'flex';
        }
      } else {
        left.innerHTML = `<span>📚</span>Class Materials & Notes`;
        
        // Hide the back button
        if (backBtn) {
          backBtn.style.display = 'none';
        }
      }
    }

    function updateSystemNotifications() {
      refreshSystemAssignmentStats();
      document.querySelectorAll('.system-card').forEach(card => {
        const systemName = card.dataset.systemName;
        if (!systemName) return;
        const stats = systemAssignmentStats.get(systemName);
        const totalNotes = stats?.totalNotes || 0;

        card.querySelectorAll('.system-notification').forEach(notification => notification.remove());

        let badgeMarkup = '';
        if (totalNotes > 0) {
          badgeMarkup = `
            <div class="system-notification unlocked">
              <span class="notification-count">${totalNotes}</span>
              <div class="notification-pulse"></div>
            </div>
          `;
        }

        if (badgeMarkup) {
          card.insertAdjacentHTML('afterbegin', badgeMarkup);
        }
      });
    }
    
    // Fetch data from Google Classroom API
    async function fetchGoogleClassroomData(type, accessToken, studentEmail) {
      let endpoint = '';
      let allResults = [];
      
      try {
        if (type === 'courses') {
          // Fetch courses where this specific student email is enrolled
          endpoint = `https://classroom.googleapis.com/v1/courses?studentId=${encodeURIComponent(studentEmail)}&courseStates=ACTIVE`;
          const response = await fetch(endpoint, {
            headers: { 'Authorization': `Bearer ${accessToken}` }
          });
          
          if (!response.ok) throw new Error(`${response.status}`);
          const data = await response.json();
          return data.courses || [];
          
        } else if (type === 'announcements') {
          // First get courses for this student
          const courses = await fetchGoogleClassroomData('courses', accessToken, studentEmail);
          
          // Fetch announcements from their courses
          for (const course of courses) {
            endpoint = `https://classroom.googleapis.com/v1/courses/${course.id}/announcements?orderBy=updateTime%20desc`;
            const response = await fetch(endpoint, {
              headers: { 'Authorization': `Bearer ${accessToken}` }
            });
            
            if (response.ok) {
              const data = await response.json();
              if (data.announcements) {
                allResults.push(...data.announcements.map(a => ({ ...a, courseId: course.id })));
              }
            }
          }
          
          return allResults;
          
        } else if (type === 'coursework') {
          // First get courses for this student
          const courses = await fetchGoogleClassroomData('courses', accessToken, studentEmail);
          
          // Fetch coursework from their courses
          for (const course of courses) {
            endpoint = `https://classroom.googleapis.com/v1/courses/${course.id}/courseWork?orderBy=updateTime%20desc`;
            const response = await fetch(endpoint, {
              headers: { 'Authorization': `Bearer ${accessToken}` }
            });
            
            if (response.ok) {
              const data = await response.json();
              if (data.courseWork) {
                allResults.push(...data.courseWork.map(w => ({ ...w, courseId: course.id })));
              }
            }
          }
          
          return allResults;
        }
        
      } catch (error) {
        console.error(`Error fetching ${type}:`, error);
        throw error;
      }
      
      return allResults;
    }
    
    // ==========================================================================
    // NCLEX SYSTEMS PROGRESS
    // ==========================================================================
    // NCLEX Systems Data - All 24 Body Systems
    const DEFAULT_SYSTEMS = [
      // Core Systems (10)
      { name: 'Cardiovascular', icon: '❤️', status: 'not-started', progress: 0 },
      { name: 'Respiratory', icon: '�', status: 'not-started', progress: 0 },
      { name: 'Neurological', icon: '🧠', status: 'not-started', progress: 0 },
      { name: 'Gastrointestinal', icon: '🍽️', status: 'not-started', progress: 0 },
      { name: 'Renal', icon: '💧', status: 'not-started', progress: 0 },
      { name: 'Endocrine', icon: '�', status: 'not-started', progress: 0 },
      { name: 'Musculoskeletal', icon: '�', status: 'not-started', progress: 0 },
      { name: 'Integumentary', icon: '📄', status: 'not-started', progress: 0 },
      { name: 'Immune', icon: '�️', status: 'not-started', progress: 0 },
      { name: 'Hematologic', icon: '🩸', status: 'not-started', progress: 0 },
      
      // Specialized Systems (14)
      { name: 'Reproductive', icon: '�', status: 'not-started', progress: 0 },
      { name: 'Sensory (Eyes/Ears)', icon: '�️', status: 'not-started', progress: 0 },
      { name: 'Mental Health', icon: '�', status: 'not-started', progress: 0 },
      { name: 'Maternal Health', icon: '🤰', status: 'not-started', progress: 0 },
      { name: 'Pediatrics', icon: '🧸', status: 'not-started', progress: 0 },
      { name: 'Oncology', icon: '🎗️', status: 'not-started', progress: 0 },
      { name: 'Infectious Diseases', icon: '�', status: 'not-started', progress: 0 },
      { name: 'Autoimmune Disorders', icon: '🔬', status: 'not-started', progress: 0 },
      { name: 'Pain Management', icon: '💊', status: 'not-started', progress: 0 },
      { name: 'Gerontology', icon: '👴', status: 'not-started', progress: 0 },
      { name: 'Emergency Care', icon: '🚨', status: 'not-started', progress: 0 },
      { name: 'Critical Care', icon: '⚡', status: 'not-started', progress: 0 },
      { name: 'Pharmacology', icon: '💉', status: 'not-started', progress: 0 },
      { name: 'Nursing Fundamentals', icon: '�', status: 'not-started', progress: 0 }
    ];

        let nclexSystems = DEFAULT_SYSTEMS.map(system => ({ ...system }));
    
        // Global variable to store all notes
        let allSystemNotes = [];
        let selectedSystem = null;
        let isInitialCarouselRender = true; // Track first render to prevent animation jump
        let systemAssignmentStats = new Map();

        // ============================================================================
        // UNIVERSAL HELPER: Extract system name from note object
        // Handles all possible column name variations across the entire codebase
        // PRIORITY: category (new standard column) > legacy fallbacks
        // ============================================================================
        function getSystemNameFromNote(note) {
          return note.category || note.system_category || note.system || note.group_name || 'General';
        }

        // Track opened notes in localStorage
        function getOpenedNotes() {
          const studentId = currentStudent?.id;
          if (!studentId) return new Set();
          
          const key = `arnoma-opened-notes-student-${studentId}`;
          const stored = localStorage.getItem(key);
          return new Set(stored ? JSON.parse(stored) : []);
        }

        function markNoteAsOpened(noteId) {
          const studentId = currentStudent?.id;
          if (!studentId) return;
          
          const openedNotes = getOpenedNotes();
          openedNotes.add(noteId);
          
          const key = `arnoma-opened-notes-student-${studentId}`;
          localStorage.setItem(key, JSON.stringify([...openedNotes]));
        }

        function isNoteOpened(noteId) {
          return getOpenedNotes().has(noteId);
        }

        // Helper function to normalize system names for matching
        function normalizeSystemName(name) {
          if (!name) return '';
          // Remove " System" suffix, normalize case, and trim whitespace
          return name.replace(/\s+System$/i, '').trim().toLowerCase();
        }

        function buildSystemAssignmentStats() {
          const stats = new Map();
          allSystemNotes.forEach(note => {
            const systemName = getSystemNameFromNote(note);
            if (!systemName) return;
            
            // Normalize the system name (remove " System" suffix)
            const normalizedName = normalizeSystemName(systemName);
            
            if (!stats.has(normalizedName)) {
              stats.set(normalizedName, {
                totalNotes: 0,
                viewedNotes: 0,
                assignedTemplates: new Set(),
                lockedUnread: 0,
                unlockedUnread: 0,
                lockedNotes: 0,
                unlockedNotes: 0
              });
            }
            const entry = stats.get(normalizedName);
            
            // Count total notes
            entry.totalNotes += 1;
            
            // Count viewed notes (opened PDFs)
            if (note.read) {
              entry.viewedNotes += 1;
            }
            
            // Count locked vs unlocked (paid) notes
            if (note.isPaid) {
              entry.unlockedNotes += 1;
            } else {
              entry.lockedNotes += 1;
            }
            
            const templateKey = note.templateId || note.id;
            if (templateKey) {
              entry.assignedTemplates.add(templateKey);
            }
            if (!note.read) {
              if (note.isPaid) {
                entry.unlockedUnread += 1;
              } else {
                entry.lockedUnread += 1;
              }
            }
          });
          stats.forEach(entry => {
            entry.assignedCount = entry.assignedTemplates.size;
          });
          
          return stats;
        }

        // Cache for system assignment stats to avoid recalculating on every render
        let systemStatsCache = null;
        let systemStatsCacheKey = null;

        function refreshSystemAssignmentStats() {
          // Generate cache key from note IDs and read status
          const cacheKey = allSystemNotes.map(n => `${n.id}:${n.read ? '1' : '0'}`).sort().join(',');
          
          // Return cached stats if data hasn't changed
          if (systemStatsCacheKey === cacheKey && systemStatsCache) {
            systemAssignmentStats = systemStatsCache;
            return;
          }
          
          // Rebuild stats and update cache
          systemAssignmentStats = buildSystemAssignmentStats();
          systemStatsCache = systemAssignmentStats;
          systemStatsCacheKey = cacheKey;
        }

        function determineSystemStatus(progress) {
          // 100% = Completed (Green)
          if (progress === 100) return 'completed';
          
          // 90%+ = In Progress (Blue)
          if (progress >= 90) return 'in-progress';
          
          // 1-89% = Will be set to 'current' for lowest progress (Yellow)
          if (progress > 0) return 'in-progress';
          
          // 0% = Not Started (Red)
          return 'not-started';
        }

        function getSystemStatusLabel(status) {
          switch (status) {
            case 'completed':
              return 'Completed';
            case 'current':
              return 'Ongoing';
            case 'in-progress':
              return 'In Progress';
            default:
              return 'Not Started';
          }
        }
    
    /**
     * Loads NCLEX body systems progress carousel from note folders.
     * 
     * @async
     * @returns {Promise<void>}
     * 
     * @description
     * Displays student progress across NCLEX body systems:
     * 1. Queries note_folders table for all active systems
     * 2. Counts total note_templates per folder
     * 3. Counts completed assignments via note_assignments table
     * 4. Calculates progress percentage per system
     * 5. Renders carousel cards with progress bars
     * 6. Highlights current system (is_current = true)
     * 
     * Each card shows:
     * - System icon and name
     * - Completed/Total count (e.g., "3/10")
     * - Visual progress bar
     * - "Current" badge if applicable
     * 
     * Sorted by sort_order from database.
     * 
     * @example
     * await loadSystemsProgress();
     * // Renders: [🫀 Cardiovascular 7/15] [🧠 Neurological 2/12] [🫁 Respiratory 0/8]
     */
    
    // Performance: Cache database queries (30 second TTL)
    let systemsDataCache = {
      allNotes: null,
      folders: null,
      timestamp: 0,
      ttl: 30000 // 30 seconds
    };
    
    function isCacheValid() {
      return systemsDataCache.timestamp && (Date.now() - systemsDataCache.timestamp) < systemsDataCache.ttl;
    }
    
    async function loadSystemsProgress() {
      const loadStartTime = Date.now(); // Track when loading started
      
      const carousel = document.getElementById('systemsCarousel');
      if (!carousel) {
        console.error('❌ Carousel element not found');
        return;
      }

      refreshSystemAssignmentStats();

      try {
        // Get student's group letter for filtering folders
        const studentGroupLetter = (currentStudent?.group || currentStudent?.group_name || 'A').replace('Group ', '');
        
        // Use cached data if valid, otherwise fetch fresh
        let allNotes, folders;
        
        if (isCacheValid()) {
          allNotes = systemsDataCache.allNotes;
          folders = systemsDataCache.folders;
        } else {
          // Fetch ALL notes to count per system (not filtered by student access)
          // Note: student_notes table might not have 'system' column, so we select all possible variants
          const { data: fetchedNotes, error: notesError } = await supabaseClient
            .from('student_notes')
            .select('*'); // Select all columns since we don't know which system field exists
          
          if (notesError) {
            console.error('❌ Error fetching total notes:', notesError);
            // Continue anyway - we'll use stats from allSystemNotes instead
          }
          
          allNotes = fetchedNotes;
          
          // Fetch note folders from database - BOTH group-specific AND global folders
          const { data: fetchedFolders, error } = await supabaseClient
            .from('note_folders')
            .select('id, folder_name, icon, sort_order, is_current, group_letter, note_templates (id)')
            .or(`group_letter.eq.${studentGroupLetter},group_letter.is.null`)  // Group-specific OR global
            .is('deleted_at', null)
            .order('sort_order', { ascending: true });

          if (error) {
            console.error('❌ Error fetching folders:', error);
            throw error;
          }
          
          folders = fetchedFolders;
          
          // Cache the fetched data
          systemsDataCache.allNotes = allNotes;
          systemsDataCache.folders = folders;
          systemsDataCache.timestamp = Date.now();
        }
        
        // Build map of total notes per system
        const totalNotesPerSystem = new Map();
        if (allNotes && allNotes.length > 0) {
          allNotes.forEach(note => {
            // CONSISTENT: Use helper function to get system name
            const systemName = getSystemNameFromNote(note);
            totalNotesPerSystem.set(systemName, (totalNotesPerSystem.get(systemName) || 0) + 1);
          });
        } else {
          // Fallback: Use allSystemNotes if we couldn't fetch all notes
          console.warn('⚠️ Could not fetch all notes, using accessible notes for totals');
          if (allSystemNotes && allSystemNotes.length > 0) {
            allSystemNotes.forEach(note => {
              const systemName = getSystemNameFromNote(note);
              totalNotesPerSystem.set(systemName, (totalNotesPerSystem.get(systemName) || 0) + 1);
            });
          }
        }

        const assignmentStats = systemAssignmentStats || new Map();
        
        // Build systems array from folders or use defaults
        if (folders && folders.length) {
          // CRITICAL: Deduplicate folders by NORMALIZED name (case-insensitive, handle variations)
          const folderMap = new Map();
          folders.forEach(folder => {
            // Normalize the folder name for robust matching
            const normalizedKey = normalizeSystemName(folder.folder_name);
            const existing = folderMap.get(normalizedKey);
            
            // Keep this folder if: no existing, OR existing is global (null) but this is group-specific
            if (!existing || (existing.group_letter === null && folder.group_letter !== null)) {
              folderMap.set(normalizedKey, folder);
            }
          });
          // Now map unique folders to system objects
          const mappedSystems = Array.from(folderMap.values()).map(folder => {
            const totalTemplates = folder.note_templates?.length || 0;
            
            // Normalize folder name for stats lookup (remove " System" suffix)
            const normalizedFolderName = normalizeSystemName(folder.folder_name);
            
            // Try normalized name first
            let stats = assignmentStats.get(normalizedFolderName);
            
            // Try exact match with full name
            if (!stats) {
              stats = assignmentStats.get(folder.folder_name);
            }
            
            if (!stats) {
              // Try fuzzy matching: find stats key that contains or is contained by folder name
              const folderNameLower = folder.folder_name.toLowerCase();
              const normalizedLower = normalizedFolderName.toLowerCase();
              for (const [key, value] of assignmentStats.entries()) {
                const keyLower = key.toLowerCase();
                // Match if: exact, key contains folder name, folder name contains key, OR normalized names match
                if (keyLower === folderNameLower || 
                    keyLower === normalizedLower ||
                    keyLower.includes(folderNameLower) || 
                    keyLower.includes(normalizedLower) ||
                    folderNameLower.includes(keyLower) ||
                    normalizedLower.includes(keyLower)) {
                  stats = value;
                  break;
                }
              }
            }
            
            const systemNotes = stats?.totalNotes || 0;
            const lockedNotes = stats?.lockedNotes || 0;
            const unlockedNotes = stats?.unlockedNotes || 0;
            
            // Get total notes for this system (using fuzzy matching like we do for stats)
            let totalNotesInSystem = 0;
            
            // Try exact match first
            if (totalNotesPerSystem.has(folder.folder_name)) {
              totalNotesInSystem = totalNotesPerSystem.get(folder.folder_name);
            } else {
              // Try fuzzy matching
              const folderNameLower = folder.folder_name.toLowerCase();
              for (const [key, value] of totalNotesPerSystem.entries()) {
                const keyLower = key.toLowerCase();
                if (keyLower === folderNameLower || 
                    keyLower.includes(folderNameLower) || 
                    folderNameLower.includes(keyLower)) {
                  totalNotesInSystem = value;
                  break;
                }
              }
            }
            
            // SIMPLIFIED PROGRESS CALCULATION:
            // Progress = (posted notes to this group / total notes in system) * 100
            // - If no notes posted yet → 0% (NOT STARTED)
            // - If 25 out of 100 notes posted → 25% (IN PROGRESS)
            // - If all notes posted → 100% (COMPLETED)
            let progress = 0;
            
            if (totalNotesInSystem > 0 && systemNotes > 0) {
              // Calculate percentage: posted / total
              progress = Math.min(100, Math.round((systemNotes / totalNotesInSystem) * 100));
            } else if (systemNotes > 0) {
              // Notes exist but we don't know total - mark as in progress
              progress = 50;
            } else {
              // No notes posted yet
              progress = 0;
            }
            
            return {
              id: folder.id,
              name: folder.folder_name,
              icon: folder.icon || '📚',
              totalTemplates: totalNotesInSystem, // Use actual total instead of template count
              assignedCount: systemNotes,
              progress,
              status: folder.is_current ? 'current' : determineSystemStatus(progress)
            };
          });
          
          // CRITICAL FILTER: Only show systems that have notes OR are marked as ongoing
          // This prevents empty/unused systems from cluttering the carousel
          const filteredSystems = mappedSystems.filter(sys => {
            const hasNotes = sys.assignedCount > 0 || sys.totalTemplates > 0;
            const isOngoing = sys.status === 'current';
            const shouldShow = hasNotes || isOngoing;
            
            return shouldShow;
          });
          
          nclexSystems = filteredSystems;
        } else {
          nclexSystems = DEFAULT_SYSTEMS.map(system => ({
            ...system,
            totalTemplates: 0,
            assignedCount: 0,
            progress: 0,
            status: 'not-started'
          }));
        }
        // Database is_current flag is the source of truth (set by Group-Notes.html)
        // Just ensure only ONE system has 'current' status (in case of data issues)
        let foundCurrent = false;
        nclexSystems.forEach(sys => {
          if (sys.status === 'current') {
            if (foundCurrent) {
              // Already found one - reset this to normal status
              sys.status = determineSystemStatus(sys.progress);
            } else {
              foundCurrent = true;
            }
          }
        });

        // Sort systems by completion status
        // Order: Completed → Ongoing/Current → In Progress → Not Started
        nclexSystems.sort((a, b) => {
          const statusOrder = {
            'completed': 1,
            'current': 2,      // Ongoing system
            'in-progress': 3,
            'not-started': 4
          };
          
          const aOrder = statusOrder[a.status] || 4;
          const bOrder = statusOrder[b.status] || 4;
          
          if (aOrder !== bOrder) {
            return aOrder - bOrder;
          }
          
          // Within same status, sort by progress (higher first)
          return b.progress - a.progress;
        });

        // Calculate elapsed time and ensure minimum loading with render buffer
        const elapsedTime = Date.now() - loadStartTime;
        const minLoadingTime = 800; // Reduced from 3200ms to 800ms for faster load
        const remainingTime = Math.max(0, minLoadingTime - elapsedTime);
        // Wait for remaining time before rendering
        await new Promise(resolve => setTimeout(resolve, remainingTime));
        
        // Render carousel once
        renderSystemsCarousel();
        updateSystemNotifications();
        
      } catch (error) {
        console.error('❌ Error loading systems:', error);
        
        // Even on error, use faster minimum loading time
        const elapsedTime = Date.now() - loadStartTime;
        const minLoadingTime = 800;
        const remainingTime = Math.max(0, minLoadingTime - elapsedTime);
        
        await new Promise(resolve => setTimeout(resolve, remainingTime));
        
        carousel.innerHTML = '<div class="system-card" style="min-height:140px;justify-content:center;align-items:center;">Failed to load systems</div>';
        // CRITICAL: Show carousel even on error (otherwise it stays hidden forever)
        carousel.setAttribute('data-ready', 'true');
      }
    }

    function renderSystemsCarousel() {
      const carousel = document.getElementById('systemsCarousel');
      if (!carousel) return;

      if (!nclexSystems.length) {
        carousel.innerHTML = '<div class="system-card" style="min-height:140px;justify-content:center;align-items:center;">No systems configured</div>';
        carousel.setAttribute('data-ready', 'true');
        return;
      }

      // ROBUST DUPLICATE DETECTION: Check for duplicate system names
      const systemNames = nclexSystems.map(s => s.name);
      const uniqueNames = new Set(systemNames);
      if (systemNames.length !== uniqueNames.size) {
        console.error('🚨 DUPLICATE SYSTEMS DETECTED! This should never happen!');
        console.error('Systems array:', nclexSystems.map(s => s.name));
        const duplicates = systemNames.filter((name, index) => systemNames.indexOf(name) !== index);
        console.error('Duplicate system names:', [...new Set(duplicates)]);
        
        // FORCE deduplication by name
        const deduped = [];
        const seen = new Set();
        nclexSystems.forEach(sys => {
          const normalizedName = normalizeSystemName(sys.name);
          if (!seen.has(normalizedName)) {
            seen.add(normalizedName);
            deduped.push(sys);
          }
        });
        nclexSystems = deduped;
      }

      // Hide carousel during render
      carousel.setAttribute('data-ready', 'false');
      
      const fragment = document.createDocumentFragment();
      
      nclexSystems.forEach((system, index) => {
        const card = document.createElement('div');
        card.className = `system-card ${system.status || 'not-started'}`;
        card.dataset.systemName = system.name;
        card.style.animationDelay = `${index * 0.05}s`;

        if (selectedSystem === system.name) card.classList.add('selected');

        const stats = systemAssignmentStats.get(system.name);
        const totalNotes = stats?.totalNotes || 0;
        const statusLabel = getSystemStatusLabel(system.status);
        
        // Ensure progress is a valid number
        const progressValue = Math.max(0, Math.min(100, system.progress || 0));

        let badge = '';
        if (totalNotes > 0) {
          let badgeLeft = 20;
          if (progressValue > 0) {
            const minLeft = 20;
            const maxLeft = 'calc(100% - 52px)';
            if (progressValue >= 90) {
              badgeLeft = maxLeft;
            } else {
              badgeLeft = `max(${minLeft}px, min(calc(100% - 52px), calc(${progressValue}% - 16px)))`;
            }
          }
          badge = `<div class="system-notification unlocked" style="left: ${badgeLeft};"><span class="notification-count">${totalNotes}</span><div class="notification-pulse"></div></div>`;
        }
        
        let statusPosition = '60px';
        let statusZIndex = 5;
        if (progressValue > 0) {
          if (progressValue >= 85) {
            statusPosition = 'calc(100% - 80px)';
            if (progressValue === 100) {
              statusPosition = 'calc(100% - 52px)';
              statusZIndex = 15;
            }
          } else if (progressValue <= 15) {
            statusPosition = '60px';
          } else {
            statusPosition = `${progressValue}%`;
          }
        }

        card.innerHTML = `
          ${badge}
          <div class="system-icon">${system.icon}</div>
          <div class="system-name">${system.name}</div>
          <div class="system-progress">${progressValue}% Complete</div>
          <div class="system-bar">
            <div class="system-bar-fill" data-progress="${progressValue}"></div>
          </div>
          <div class="system-status" style="left: ${statusPosition}; z-index: ${statusZIndex};">${statusLabel}</div>
        `;

        card.onclick = () => {
          centerSystemCard(card);
          filterNotesBySystem(system.name);
        };

        fragment.appendChild(card);
      });

      // Clear spinner and append cards
      carousel.innerHTML = '';
      carousel.appendChild(fragment);
      
      // Find target card and calculate scroll position BEFORE showing carousel
      const targetCard = selectedSystem 
        ? carousel.querySelector(`.system-card[data-system-name="${CSS.escape?.(selectedSystem) || selectedSystem}"]`)
        : carousel.querySelector('.system-card.current') || carousel.firstElementChild;
      
      // Set scroll position IMMEDIATELY (synchronously) before any paint
      if (targetCard) {
        const container = carousel.parentElement;
        if (container) {
          const containerWidth = container.getBoundingClientRect().width;
          const cardWidth = targetCard.getBoundingClientRect().width;
          const scrollLeft = targetCard.offsetLeft - (containerWidth / 2) + (cardWidth / 2);
          const maxScroll = carousel.scrollWidth - carousel.clientWidth;
          const clamped = Math.max(0, Math.min(scrollLeft, maxScroll));
          
          // Always use instant scroll on initial render to prevent flash
          if (isInitialCarouselRender) {
            carousel.scrollLeft = clamped;
          } else {
            carousel.scrollTo({ left: clamped, behavior: 'smooth' });
          }
        }
      }
      
      // Set progress bar widths immediately (no transition on initial render)
      nclexSystems.forEach((system) => {
        const progressValue = Math.max(0, Math.min(100, system.progress || 0));
        const card = carousel.querySelector(`.system-card[data-system-name="${system.name}"]`);
        if (!card) return;
        
        const barFill = card.querySelector('.system-bar-fill');
        if (barFill) {
          barFill.style.transition = 'none';
          
          if (progressValue === 0) {
            barFill.style.setProperty('width', '0%', 'important');
            barFill.style.setProperty('opacity', '0', 'important');
          } else {
            barFill.style.setProperty('width', `${progressValue}%`, 'important');
            barFill.style.setProperty('opacity', '1', 'important');
          }
          
          // Re-enable transitions after next frame
          requestAnimationFrame(() => {
            barFill.style.transition = 'width 0.8s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.3s ease';
          });
        }
      });

      // NOW show carousel after scroll position is set (use requestAnimationFrame to sync with paint)
      requestAnimationFrame(() => {
        carousel.setAttribute('data-ready', 'true');
        isInitialCarouselRender = false;
      });
    }

    // Scroll carousel left/right by one card width
    function scrollCarousel(direction) {
      const carousel = document.getElementById('systemsCarousel');
      if (!carousel) return;
      
      const cards = carousel.querySelectorAll('.system-card');
      if (!cards.length) return;
      
      const cardWidth = cards[0].getBoundingClientRect().width;
      const gap = 20; // Gap between cards (from CSS)
      const scrollAmount = cardWidth + gap;
      
      const currentScroll = carousel.scrollLeft;
      const newScroll = currentScroll + (scrollAmount * direction);
      
      carousel.scrollTo({
        left: newScroll,
        behavior: 'smooth'
      });
    }

    function centerSystemCard(card) {
      const carousel = document.getElementById('systemsCarousel');
      if (!carousel || !card) return;

      const container = carousel.parentElement;
      if (!container) return;

      const containerWidth = container.getBoundingClientRect().width;
      const cardWidth = card.getBoundingClientRect().width;
      const scrollLeft = card.offsetLeft - (containerWidth / 2) + (cardWidth / 2);
      const maxScroll = carousel.scrollWidth - carousel.clientWidth;
      const clamped = Math.max(0, Math.min(scrollLeft, maxScroll));

      carousel.scrollTo({ left: clamped, behavior: 'smooth' });
    }
    
    /**
     * Setup event delegation for note card clicks
     * Performance: Replaces 300+ individual listeners with ONE delegated listener
     */
    function setupNoteCardEventDelegation() {
      const classroomList = document.getElementById('classroomList');
      if (!classroomList) return;
      
      classroomList.addEventListener('click', function(e) {
        // Find the closest note card
        const noteCard = e.target.closest('.classroom-item');
        if (!noteCard) return;
        
        // Don't expand if clicking on a button
        if (e.target.tagName === 'BUTTON' || e.target.closest('button')) return;
        
        // Only handle cards that have attachments
        const attachmentsDiv = noteCard.querySelector('.note-attachments');
        if (!attachmentsDiv) return;
        
        // Toggle expand/collapse
        const isCollapsed = noteCard.classList.contains('note-collapsed');
        const indicator = noteCard.querySelector('.note-expand-indicator');
        
        if (isCollapsed) {
          noteCard.classList.remove('note-collapsed');
          noteCard.classList.add('note-expanded');
          attachmentsDiv.style.display = 'flex';
          if (indicator) indicator.innerHTML = '▲';
        } else {
          noteCard.classList.add('note-collapsed');
          noteCard.classList.remove('note-expanded');
          attachmentsDiv.style.display = 'none';
          if (indicator) indicator.innerHTML = '▼';
        }
      });
    }
    
    // Display notes with lock/unlock status
    function displayNotes(notes) {
      const classroomList = document.getElementById('classroomList');
      
      if (notes.length === 0) {
        classroomList.innerHTML = '<div style="text-align: center; color: rgba(255,255,255,0.7); padding: 40px;">No notes available yet.</div>';
        return;
      }
      
      // Performance: Use DocumentFragment for batched DOM updates
      const fragment = document.createDocumentFragment();
      const notesGrid = document.createElement('div');
      notesGrid.className = 'notes-grid';
      notesGrid.style.cssText = `
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 20px;
        padding: 0 4px;
      `;
      
      // PERFORMANCE: Batch DOM operations - create all cards in memory first
      const cardsFragment = document.createDocumentFragment();
      notes.forEach(note => {
        const card = createNoteCard(note);
        cardsFragment.appendChild(card);
      });
      
      // Append all cards at once
      notesGrid.appendChild(cardsFragment);
      
      // Single DOM update: Clear and append grid in one operation
      fragment.appendChild(notesGrid);
      classroomList.innerHTML = '';
      classroomList.appendChild(fragment);
    }
    
    // Helper function to create individual note cards
    function createNoteCard(note) {
      // System gradient colors - diagonal gradients unique to each system
      const systemGradients = {
        'Cardiovascular System': 'linear-gradient(135deg, rgba(239, 68, 68, 0.2) 0%, rgba(220, 38, 38, 0.1) 100%)',           // Red gradient
        'Respiratory System': 'linear-gradient(135deg, rgba(59, 130, 246, 0.2) 0%, rgba(37, 99, 235, 0.1) 100%)',             // Blue gradient
        'Gastrointestinal & Hepatic System': 'linear-gradient(135deg, rgba(245, 158, 11, 0.2) 0%, rgba(217, 119, 6, 0.1) 100%)', // Amber gradient
        'Endocrine System': 'linear-gradient(135deg, rgba(168, 85, 247, 0.2) 0%, rgba(147, 51, 234, 0.1) 100%)',               // Purple gradient
        'Genitourinary System': 'linear-gradient(135deg, rgba(14, 165, 233, 0.2) 0%, rgba(2, 132, 199, 0.1) 100%)',           // Sky blue gradient
        'Neurological System': 'linear-gradient(135deg, rgba(236, 72, 153, 0.2) 0%, rgba(219, 39, 119, 0.1) 100%)',            // Pink gradient
        'Musculoskeletal System': 'linear-gradient(135deg, rgba(34, 197, 94, 0.2) 0%, rgba(22, 163, 74, 0.1) 100%)',          // Green gradient
        'Hematology & Oncology': 'linear-gradient(135deg, rgba(217, 70, 239, 0.2) 0%, rgba(192, 38, 211, 0.1) 100%)',          // Fuchsia gradient
        'Immune System & Infectious Diseases': 'linear-gradient(135deg, rgba(234, 179, 8, 0.2) 0%, rgba(202, 138, 4, 0.1) 100%)', // Yellow gradient
        'Integumentary System': 'linear-gradient(135deg, rgba(249, 115, 22, 0.2) 0%, rgba(234, 88, 12, 0.1) 100%)',           // Orange gradient
        'Medical Terminology': 'linear-gradient(135deg, rgba(139, 92, 246, 0.2) 0%, rgba(124, 58, 237, 0.1) 100%)',            // Violet gradient
        'Pharmacology': 'linear-gradient(135deg, rgba(6, 182, 212, 0.2) 0%, rgba(8, 145, 178, 0.1) 100%)',                    // Cyan gradient
        'Mental Health': 'linear-gradient(135deg, rgba(124, 58, 237, 0.2) 0%, rgba(109, 40, 217, 0.1) 100%)',                  // Indigo gradient
        'Maternity & Newborn': 'linear-gradient(135deg, rgba(244, 114, 182, 0.2) 0%, rgba(236, 72, 153, 0.1) 100%)',           // Rose gradient
        'Pediatrics': 'linear-gradient(135deg, rgba(96, 165, 250, 0.2) 0%, rgba(59, 130, 246, 0.1) 100%)',                     // Light blue gradient
        'General': 'linear-gradient(135deg, rgba(156, 163, 175, 0.15) 0%, rgba(107, 114, 128, 0.08) 100%)'                    // Gray gradient (default)
      };
      
      // Get system gradient (CONSISTENT: use helper function)
      const systemName = getSystemNameFromNote(note);
      const systemGradient = systemGradients[systemName] || systemGradients['General'];
      
      const item = document.createElement('div');
      const noteTypeClass = note.type === 'warning' ? 'warning' : (note.type || 'material');
      const lockedClass = (!note.isPaid || note.isAbsent) && note.type !== 'warning' ? 'locked' : '';
      item.className = `classroom-item ${noteTypeClass} ${lockedClass} note-collapsed`;
      
      // Apply system gradient as background
      item.style.background = systemGradient;
      
      // Clean up title - remove "Bulk uploaded - " prefix
      let cleanTitle = note.title || 'Untitled Note';
      cleanTitle = cleanTitle.replace(/^Bulk uploaded\s*-\s*/i, '').trim();
      
      // Clean up description text - remove "Bulk uploaded - " prefix
      let cleanText = note.text || 'Click to view note content...';
      cleanText = cleanText.replace(/^Bulk uploaded\s*-\s*/i, '').trim();
      
      // Create unique ID for this note card
      const noteCardId = `note-card-${note.id}`;
      item.id = noteCardId;
        
      // Determine the badge icon and text
      let badgeIcon = note.folderIcon || '📄';
      let badgeText = note.course || 'Note';
      let badgeClass = '';
      
      if (note.type === 'warning' && note.isTemplateMissing) {
        badgeIcon = '⚠️';
        badgeText = 'Missing Content';
      } else if (note.isAbsent) {
        // Student was absent - show absence badge
        badgeIcon = '🚫';
        badgeText = 'Absent';
      } else if (!note.isPaid) {
        badgeIcon = '🔒';
        badgeText = 'Payment Required';
      } else if (note.hasFreeAccess) {
        // Show system name with special styling for free access (no gift icon)
        badgeIcon = '📚';
        badgeText = note.course || 'Material';
        badgeClass = 'free-access';
      } else if (note.type === 'announcement') {
        badgeIcon = '📢';
        badgeText = note.course || 'Announcement';
      } else if (note.type === 'material') {
        badgeIcon = note.folderIcon || '📚';
        badgeText = note.course || 'Material';
      }
      
      // Build attachments HTML - hidden by default, shown on click
      let attachmentsHTML = '';
      if (note.isTemplateMissing) {
        attachmentsHTML = `
          <div class="note-attachments" style="display: none; margin-top: 15px; padding: 15px; border-radius: 12px; background: rgba(255,168,0,0.1); border: 1px solid rgba(255,168,0,0.4); color: #ffb347;">
            This note template has been removed or is not available. Please contact an administrator to restore it.
          </div>
        `;
      } else if (note.attachments && note.attachments.length > 0 && note.isPaid) {
        attachmentsHTML = '<div class="note-attachments" style="display: none; margin-top: 15px; flex-direction: column; gap: 10px;">';
        note.attachments.forEach(attachment => {
          const icon = attachment.type === 'video' ? '🎥' : 
                      attachment.type === 'link' ? '🔗' : 
                      attachment.type === 'pdf' ? '📄' : '📎';
          
          // For PDF attachments from our system, use Protected-PDF-Viewer.html
          // Pass student info in URL since sessionStorage doesn't transfer to new tabs
          // CRITICAL: Also pass note ID so video_url can be loaded from database
          // 🔥 FIX: Pass group-specific post date (not global class_date)
          const cacheBuster = Date.now();
          // Format date in LOCAL timezone (YYYY-MM-DD) to avoid UTC shift
          const groupPostDate = `${note.date.getFullYear()}-${String(note.date.getMonth() + 1).padStart(2, '0')}-${String(note.date.getDate()).padStart(2, '0')}`;
          const clickHandler = attachment.type === 'pdf' 
            ? `event.stopPropagation(); markNoteAsOpened(${note.id}); window.open('Protected-PDF-Viewer.html?url=${encodeURIComponent(attachment.url)}&note=${note.id}&title=${encodeURIComponent(attachment.title)}&studentName=${encodeURIComponent(currentStudent.name)}&studentGroup=${encodeURIComponent(currentStudent.group_name || currentStudent.group || 'N/A')}&classDate=${groupPostDate}&v=${cacheBuster}', '_blank')`
            : `event.stopPropagation(); markNoteAsOpened(${note.id}); window.open('${attachment.url}', '_blank')`;
          
          attachmentsHTML += `
            <button style="
              width: 100%;
              padding: 14px 18px;
              border-radius: 12px;
              background: linear-gradient(135deg, rgba(102,126,234,0.2), rgba(59,130,246,0.1));
              border: 1px solid rgba(102,126,234,0.4);
              color: rgba(255,255,255,0.95);
              font-size: 15px;
              font-weight: 600;
              cursor: pointer;
              transition: all 0.3s ease;
              display: flex;
              align-items: center;
              gap: 12px;
            " onclick="${clickHandler}"
               onmouseover="this.style.background='linear-gradient(135deg, rgba(102,126,234,0.3), rgba(59,130,246,0.15))'; this.style.boxShadow='0 4px 20px rgba(102,126,234,0.4)'"
               onmouseout="this.style.background='linear-gradient(135deg, rgba(102,126,234,0.2), rgba(59,130,246,0.1))'; this.style.boxShadow='none'">
              <div style="width: 32px; height: 32px; border-radius: 8px; background: linear-gradient(135deg, rgba(255,255,255,0.15), rgba(255,255,255,0.05)); backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.2); display: flex; align-items: center; justify-content: center; flex-shrink: 0; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                  ${attachment.type === 'pdf' ? 
                    `<path d="M14 2H6C4.9 2 4 2.9 4 4V20C4 21.1 4.9 22 6 22H18C19.1 22 20 21.1 20 20V8L14 2Z" stroke="rgba(255,255,255,0.9)" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                     <path d="M14 2V8H20" stroke="rgba(255,255,255,0.9)" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                     <path d="M8 13H16" stroke="rgba(255,255,255,0.7)" stroke-width="2" stroke-linecap="round"/>
                     <path d="M8 17H16" stroke="rgba(255,255,255,0.7)" stroke-width="2" stroke-linecap="round"/>` 
                    : attachment.type === 'video' ?
                    `<circle cx="12" cy="12" r="10" stroke="rgba(255,255,255,0.9)" stroke-width="2"/>
                     <path d="M10 8L16 12L10 16V8Z" fill="rgba(255,255,255,0.9)"/>` 
                    : attachment.type === 'link' ?
                    `<path d="M10 13C10.4295 13.5741 10.9774 14.0492 11.6066 14.3929C12.2357 14.7367 12.9315 14.9411 13.6467 14.9923C14.3618 15.0435 15.0796 14.9403 15.7513 14.6897C16.4231 14.4392 17.0331 14.047 17.54 13.54L20.54 10.54C21.4508 9.59702 21.9548 8.33362 21.9434 7.02221C21.932 5.7108 21.4061 4.45602 20.4791 3.52902C19.5521 2.60202 18.2973 2.07607 16.9859 2.06466C15.6745 2.05325 14.4111 2.55723 13.468 3.468L11.75 5.18" stroke="rgba(255,255,255,0.9)" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                     <path d="M14 11C13.5705 10.4259 13.0226 9.95083 12.3934 9.60707C11.7642 9.26331 11.0685 9.05889 10.3533 9.00768C9.63819 8.95646 8.92037 9.05969 8.24861 9.31024C7.57685 9.56079 6.96684 9.95303 6.45996 10.46L3.45996 13.46C2.54917 14.403 2.04519 15.6664 2.05661 16.9778C2.06802 18.2892 2.59397 19.544 3.52097 20.471C4.44798 21.398 5.70275 21.9239 7.01417 21.9353C8.32558 21.9467 9.58898 21.4428 10.532 20.532L12.24 18.82" stroke="rgba(255,255,255,0.9)" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>`
                    : `<path d="M14 2H6C4.9 2 4 2.9 4 4V20C4 21.1 4.9 22 6 22H18C19.1 22 20 21.1 20 20V8L14 2Z" stroke="rgba(255,255,255,0.9)" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                     <path d="M14 2V8H20" stroke="rgba(255,255,255,0.9)" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>`
                  }
                </svg>
              </div>
              <span style="flex: 1; text-align: left;">${attachment.title}</span>
              <div style="width: 24px; height: 24px; border-radius: 6px; background: rgba(255,255,255,0.1); display: flex; align-items: center; justify-content: center; flex-shrink: 0;">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                  <path d="M5 12H19M19 12L12 5M19 12L12 19" stroke="rgba(255,255,255,0.8)" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
              </div>
            </button>
          `;
        });
        attachmentsHTML += '</div>';
      } else if (note.attachments && note.attachments.length > 0 && !note.isPaid) {
        attachmentsHTML = `
          <div class="note-attachments" style="display: none; margin-top: 18px; padding: 20px; border-radius: 16px; background: linear-gradient(135deg, rgba(234,67,53,0.15), rgba(197,34,31,0.08)); border: 1px solid rgba(234,67,53,0.35); text-align: center;">
            <div style="font-size: 48px; margin-bottom: 12px; filter: blur(8px);">🔒</div>
            <div style="font-size: 16px; font-weight: 600; color: rgba(255,255,255,0.9); margin-bottom: 6px; filter: blur(6px);">
              ${note.attachments.length} file${note.attachments.length !== 1 ? 's' : ''} locked
            </div>
            <div style="font-size: 13px; color: rgba(255,255,255,0.6); filter: blur(6px);">
              Complete payment for ${note.date.toLocaleDateString()} to unlock
            </div>
          </div>
        `;
      }
      
      // For locked notes OR absent students, blur everything except title and date
      const badgeBlur = (!note.isPaid || note.isAbsent) ? 'filter: blur(8px);' : '';
      
      // Check if note is new (not opened yet)
      const isNew = !isNoteOpened(note.id);
      const newBadge = isNew && note.isPaid && !note.isAbsent ? '<span style="position: absolute; top: 8px; right: 8px; padding: 4px 10px; background: linear-gradient(135deg, #ef4444, #dc2626); color: white; font-size: 10px; font-weight: 800; letter-spacing: 0.5px; border-radius: 12px; box-shadow: 0 0 12px rgba(239,68,68,0.6); animation: pulse 2s infinite; z-index: 10;">NEW</span>' : '';
      
      // Add blurred preview content for locked/absent notes
      const isLocked = !note.isPaid || note.isAbsent;
      const blurredPreview = isLocked ? `
        <div class="blurred-preview" style="filter: blur(6px); opacity: 0.4; padding: 12px; margin-top: 8px; user-select: none; pointer-events: none;">
          <div style="height: 8px; background: rgba(255,255,255,0.3); border-radius: 4px; margin-bottom: 6px; width: 90%;"></div>
          <div style="height: 8px; background: rgba(255,255,255,0.3); border-radius: 4px; margin-bottom: 6px; width: 75%;"></div>
          <div style="height: 8px; background: rgba(255,255,255,0.3); border-radius: 4px; margin-bottom: 6px; width: 85%;"></div>
          <div style="height: 8px; background: rgba(255,255,255,0.3); border-radius: 4px; margin-bottom: 6px; width: 60%;"></div>
        </div>
      ` : '';
      
      item.innerHTML = `
        ${newBadge}
        <div class="note-content-area">
          <div class="classroom-header">
            <div>
              <div class="classroom-title">
                ${cleanTitle}
              </div>
            </div>
            <div class="classroom-date">${note.date.toLocaleDateString()}</div>
          </div>
          ${blurredPreview}
        </div>
        
        <div class="note-footer-area">
          <div class="note-badge-container">
            <span class="classroom-badge ${badgeClass || (note.isPaid ? note.type || 'material' : 'locked')}" style="${badgeBlur}">${badgeIcon} ${badgeText}</span>
          </div>
          ${note.isPaid && !note.isAbsent && (note.attachments?.length > 0 || note.isTemplateMissing) ? '<div class="note-expand-indicator" style="text-align: center; padding-top: 8px; border-top: 1px solid rgba(255,255,255,0.1); color: rgba(255,255,255,0.5); font-size: 20px; user-select: none; cursor: pointer;">▼</div>' : '<div style="height: 29px;"></div>'}
        </div>
        
        ${attachmentsHTML}
      `;
      
      // Add click handler for locked/absent notes (expand/collapse now handled by event delegation)
      if (note.isAbsent && !note.isTemplateMissing) {
        // Absent students show absence dialog with payment option
        item.style.cursor = 'pointer';
        item.addEventListener('click', (e) => {
          e.stopPropagation(); // PERFORMANCE: Prevent delegation handler from firing
          const formattedDate = note.date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
          showLockedNoteDialog(formattedDate, item, true); // Pass isAbsent=true
        });
      } else if (!note.isPaid && !note.isTemplateMissing) {
        // Locked notes show payment dialog
        item.style.cursor = 'pointer';
        item.addEventListener('click', (e) => {
          e.stopPropagation(); // PERFORMANCE: Prevent delegation handler from firing
          const formattedDate = note.date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
          showLockedNoteDialog(formattedDate, item, false); // Pass isAbsent=false
        });
      } else if (note.isPaid && !note.isAbsent && (note.attachments?.length > 0 || note.isTemplateMissing)) {
        // Unlocked notes with attachments get pointer cursor (click handled by delegation)
        item.style.cursor = 'pointer';
      }
      
      return item;
    }
    
    // ==========================================================================
    // IMPERSONATION MODE FUNCTIONS
    // ==========================================================================
    
    // Show impersonation circle indicator
    function showImpersonationBanner(token) {
      const circle = document.getElementById('impersonationBanner');
      
      if (circle) {
        // Update tooltip with student name and expiration
        const minutes = Math.floor((token.expiresAt - Date.now()) / 1000 / 60);
        circle.title = `Viewing as: ${token.studentName} (Expires in ${minutes} min) - Click to exit`;
        circle.style.display = 'flex';
        
        // PERFORMANCE FIX: Update timer every 10 seconds instead of 1 second
        intervalManager.set('impersonation', () => {
          updateImpersonationTimer(token, circle);
        }, 10000); // 10 seconds instead of 1 second
      }
    }
    
    // Update impersonation timer in tooltip
    function updateImpersonationTimer(token, circle) {
      const remainingMs = token.expiresAt - Date.now();
      
      if (remainingMs <= 0) {
        // Session expired
        intervalManager.clear('impersonation');
        alert('Impersonation session has expired.');
        exitImpersonation();
        return;
      }
      
      const minutes = Math.floor(remainingMs / 1000 / 60);
      const seconds = Math.floor((remainingMs / 1000) % 60);
      
      if (circle) {
        circle.title = `Viewing as: ${token.studentName} (Expires in ${minutes}:${seconds.toString().padStart(2, '0')}) - Click to exit`;
      }
    }
    
    /**
     * Exits admin impersonation mode and returns to admin panel.
     * 
     * @returns {void}
     * 
     * @description
     * Cleans up impersonation session:
     * 1. Removes impersonation_token from sessionStorage
     * 2. Clears impersonation timer interval
     * 3. Clears countdown timer interval
     * 4. Redirects to Student-Portal-Admin.html
     * 
     * Critical security function - ensures admin can't accidentally remain
     * in impersonation mode. Called by "Exit Impersonation" button.
     * 
     * @example
     * <button onclick="exitImpersonation()">Exit Impersonation</button>
     */
    function exitImpersonation() {
      // Clear impersonation data from both storages
      sessionStorage.removeItem('impersonation_token');
      localStorage.removeItem('impersonation_token');
      intervalManager.clear('impersonation');
      intervalManager.clear('countdown');
      
      // Log exit
      debugLog('🚪 Exiting impersonation mode');
      
      // Redirect back to admin panel
      window.location.href = 'Student-Portal-Admin.html';
    }
    
    // ==========================================================================
    // SESSION TRACKING
    // ==========================================================================
    let sessionId = null;
    let sessionHeartbeatInterval = null;
    
    async function startSession() {
      // CRITICAL VALIDATION: Check for admin modes FIRST (before student check)
      const urlParams = new URLSearchParams(window.location.search);
      const isImpersonating = urlParams.get('impersonate');
      const impersonationToken = sessionStorage.getItem('impersonation_token') || 
                                 localStorage.getItem('impersonation_token');
      const adminChatToken = sessionStorage.getItem('admin_chat_token') || 
                            localStorage.getItem('admin_chat_token');
      
      if (isImpersonating || impersonationToken || adminChatToken) {
        debugLog('🚫 SESSION TRACKING BLOCKED: Admin mode detected');
        return;
      }
      
      // VALIDATION: Ensure we have a valid student
      if (!currentStudent || !currentStudent.id) {
        console.warn('⚠️ Cannot start session: No student data');
        return;
      }
      
      // Session tracking is now safe - proceed with real student session
      debugLog('✅ Starting REAL student session:', {
        studentId: currentStudent.id,
        studentName: currentStudent.name,
        timestamp: new Date().toISOString()
      });
      
      try {
        // Create new session
        const nowIso = new Date().toISOString();
        const { data, error } = await supabaseClient
          .from('student_sessions')
          .insert([{
            student_id: currentStudent.id,
            session_start: nowIso,
            last_activity: nowIso,
            is_active: true
          }])
          .select()
          .single();
        
        if (error) {
          // Session tracking failed - log but don't block portal
          // This can happen due to RLS policies or network issues
          if (DEBUG_MODE) console.error('Session tracking unavailable:', error.message);
          return;
        }
        
        if (DEBUG_MODE) debugLog('Session started:', data);
        sessionId = data.id;
        
        // PERFORMANCE FIX: Heartbeat every 5 minutes instead of 2 minutes
        // Reduces Supabase load by 60% while still tracking activity
        intervalManager.set('sessionHeartbeat', updateSessionActivity, 5 * 60 * 1000); // 5 minutes
        
        // Update activity on page visibility change
        document.addEventListener('visibilitychange', () => {
          if (!document.hidden) {
            updateSessionActivity();
          }
        });
        
      } catch (error) {
        console.error('Session start error:', error);
      }
    }
    
    async function updateSessionActivity() {
      if (!sessionId) return;
      
      try {
        await supabaseClient
          .from('student_sessions')
          .update({ last_activity: new Date().toISOString() })
          .eq('id', sessionId);
      } catch (error) {
        console.error('Error updating session activity:', error);
      }
    }
    
    async function endSession() {
      if (!sessionId) return;
      
      try {
        await supabaseClient
          .from('student_sessions')
          .update({
            session_end: new Date().toISOString(),
            is_active: false
          })
          .eq('id', sessionId);
        
        if (sessionHeartbeatInterval) {
          clearInterval(sessionHeartbeatInterval);
          sessionHeartbeatInterval = null;
        }
      } catch (error) {
        console.error('Error ending session:', error);
      }
    }
    
    // ==========================================================================
    // PORTAL INITIALIZATION
    // ==========================================================================
    (async function initPortal() {
      try {
        perfTimer.mark('Portal init START');
        
        // Check authentication and load student
        // NOTE: checkAuthentication() internally calls loadPortalData() after auth success
        currentStudent = await checkAuthentication();
        window.currentStudent = currentStudent; // Also set window property
        perfTimer.mark('Authentication complete');
        
        if (!currentStudent) {
          // checkAuthentication() will handle redirect
          return;
        }
        
        // Start session tracking (skip for impersonation mode)
        const urlParams = new URLSearchParams(window.location.search);
        const isImpersonating = urlParams.get('impersonate');
        
        if (!isImpersonating) {
          // Only track real student sessions, not admin impersonations
          await startSession();
          perfTimer.mark('Session tracking started');
        } else {
          if (DEBUG_MODE) debugLog('🎭 Skipping session tracking for impersonation mode');
        }
        
        // PERFORMANCE FIX: Removed duplicate loadPortalData() call
        // It's already called inside checkAuthentication() after auth verification
        
        // Check if admin chat mode - hide portal content and show only forum
        if (currentStudent && currentStudent.isAdminChatMode) {
          debugLog('💬 Admin chat mode - hiding portal content, showing only forum');
          // Hide ALL portal elements except the forum modal
          const container = document.querySelector('.container');
          const header = document.querySelector('.header');
          if (container) container.style.display = 'none';
          if (header) header.style.display = 'none';
          // Also hide body background and set to dark
          document.body.style.background = 'linear-gradient(135deg, #1e293b 0%, #0f172a 100%)';
          document.body.style.margin = '0';
          document.body.style.padding = '0';
          document.body.style.overflow = 'hidden';
          // Open forum immediately and center it
          setTimeout(() => {
            toggleForum();
            // Style the forum modal to take full screen in iframe
            const forumModal = document.getElementById('forumModal');
            if (forumModal) {
              forumModal.style.position = 'fixed';
              forumModal.style.top = '0';
              forumModal.style.left = '0';
              forumModal.style.right = '0';
              forumModal.style.bottom = '0';
              forumModal.style.margin = '0';
              forumModal.style.maxWidth = 'none';
              forumModal.style.height = '100vh';
              if (window.CSS && CSS.supports('height: 100dvh')) {
                forumModal.style.height = '100dvh';
              }
              forumModal.style.borderRadius = '0';
            }
          }, 100);
        }
        // Check if URL has #forum hash and automatically open forum
        else if (window.location.hash === '#forum') {
          debugLog('🎯 Auto-opening forum from URL hash');
          // Wait a bit for DOM to be ready
          setTimeout(() => {
            toggleForum();
          }, 500);
        }
        
      } catch (error) {
        console.error('❌ Portal initialization failed:', error);
        alert('Failed to load portal. Please try again.');
        window.location.href = 'index.html';
      }
    })();
  </script>

  <!-- ============================================================================
       CHRISTMAS TREE ANIMATION
       ============================================================================ -->
  <script>
    (function() {
      const arr = [];
      const canvas = document.getElementById('christmas-tree-canvas');
      if (!canvas) return;
      
      const ctx = canvas.getContext('2d');
      
      // Set canvas to fixed 4000x4000 like the original
      canvas.width = 4000;
      canvas.height = 4000;
      
      const cw = canvas.width;
      const ch = canvas.height;
      const T = Math.PI * 2;
      
      // Mouse influence
      const m = { x: cw / 2, y: 0 };
      const xTo = gsap.quickTo(m, "x", { duration: 1.5, ease: "expo" });
      const yTo = gsap.quickTo(m, "y", { duration: 1.5, ease: "expo" });
      
      canvas.addEventListener("pointermove", (e) => {
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        xTo(mouseX * scaleX);
        yTo(mouseY * scaleY);
      });
      
      // Reset mouse position when cursor leaves canvas
      canvas.addEventListener("pointerleave", () => {
        xTo(cw / 2);
        yTo(0);
      });
      
      // Create tree particles - EXACT ORIGINAL VALUES
      for (let i = 0; i < 999; i++) {
        arr.push({
          i,
          cx: cw / 2,
          cy: gsap.utils.mapRange(0, 999, 600, 3700, i),
          r: i < 900 ? gsap.utils.mapRange(0, 999, 3, 770, i) : 50,
          dot: 9,
          prog: 0.25,
          s: 1
        });
        
        const d = 99;
        arr[i].t = gsap.timeline({ repeat: -1 })
          .to(arr[i], { duration: d, prog: "+=1", ease: "slow(0.3, 0.4)" })
          .to(arr[i], {
            duration: d / 2,
            s: 0.15,
            repeat: 1,
            yoyo: true,
            ease: "power3.inOut"
          }, 0)
          .seek(Math.random() * d);
      }
      
      // Render - Using icy blue color
      ctx.fillStyle = "#9cdcfe";
      ctx.strokeStyle = "rgba(156, 220, 254, 0.05)";
      ctx.globalCompositeOperation = "lighter";
      
      gsap.ticker.add(render);
      
      function render() {
        ctx.clearRect(0, 0, cw, ch);
        arr.forEach(drawDot);
      }
      
      function drawDot(p) {
        const angle = p.prog * T;
        const vs = 0.2;
        const x = Math.cos(angle) * p.r + p.cx;
        const y = Math.sin(angle) * p.r * vs + p.cy;
        const d = Math.hypot(x - m.x, y - m.y);
        const ms = gsap.utils.clamp(0.07, 1, d / cw);
        
        ctx.beginPath();
        ctx.arc(x, y, (p.dot * p.s) / 2 / ms, 0, T);
        ctx.fill();
        ctx.lineWidth = (p.dot * p.s * 2) / ms;
        ctx.stroke();
      }
      
      // Intro animation
      gsap.from(arr, {
        duration: 1,
        dot: 0,
        ease: "back.out(9)",
        stagger: -0.0009
      });
      
      gsap.from(m, {
        duration: 1.5,
        y: ch * 1.2,
        ease: "power2.inOut"
      });
    })();
  </script>

  <!-- ============================================================================
       CHRISTMAS THEME INITIALIZATION & SNOW EFFECT
       ============================================================================ -->
  <script>
    /* ============================================================
       🎄 CHRISTMAS THEME INITIALIZATION
       ============================================================
       Check Supabase portal_settings and apply .christmas-theme class to body
       This controls visibility of: tree, snow, fonts, snowflakes
       ============================================================ */
    (async function() {
      try {
        // Initialize Supabase client for this script block
        const SUPABASE_URL = 'https://zlvnxvrzotamhpezqedr.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Inpsdm54dnJ6b3RhbWhwZXpxZWRyIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjI4MTEzMTcsImV4cCI6MjA3ODM4NzMxN30.-IoSqKhDrA9NuG4j3GufIbfmodWqCoppEklE1nTmw38';
        const supabaseClient = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
        
        // Fetch setting from Supabase
        const { data, error } = await supabaseClient
          .from('portal_settings')
          .select('setting_value')
          .eq('setting_key', 'christmas_theme')
          .single();
        
        if (error) {
          console.error('🎄 Error fetching Christmas theme:', error);
          return;
        }
        
        const christmasEnabled = data?.setting_value?.enabled === true;
        
        if (christmasEnabled) {
          document.body.classList.add('christmas-theme');
          
          // Update welcome message to Merry Christmas
          const welcomeMessage = document.getElementById('welcomeMessage');
          if (welcomeMessage && window.currentStudent) {
            welcomeMessage.innerHTML = `
              <span class="title-line">Merry Christmas,</span>
              <span class="name-line">Nurse ${window.currentStudent.name}</span>
            `;
          }
          
          // Initialize snow effect
          initializeSnowEffect();
        }
      } catch (err) {
        console.error('🎄 Failed to check Christmas theme:', err);
      }
    })();

    /* ============================================================
       ❄️ SNOW EFFECT INITIALIZATION
       ============================================================ */
    function initializeSnowEffect() {
      const canvas = document.querySelector('#snowCanvas');
      if (!canvas) return;
      
      const ctx = canvas.getContext('2d');
      const w = canvas.width = 4000;
      const h = canvas.height = 4000;
      
      const particles = [];
      const particleCount = 999;
      
      // Create particles
      for (let i = 0; i < particleCount; i++) {
        particles.push({
          x: Math.random() * w,
          y: Math.random() * h,
          radius: Math.random() * 4 + 1,
          density: Math.random() * particleCount
        });
      }
      
      // Animation loop
      function render() {
        ctx.clearRect(0, 0, w, h);
        ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
        ctx.beginPath();
        
        for (let i = 0; i < particleCount; i++) {
          const p = particles[i];
          ctx.moveTo(p.x, p.y);
          ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2, true);
        }
        
        ctx.fill();
        update();
      }
      
      // Update particle positions
      function update() {
        for (let i = 0; i < particleCount; i++) {
          const p = particles[i];
          p.y += (Math.cos(p.density) + 1 + p.radius / 2) * 0.5;
          p.x += Math.sin(0) * 2;
          
          if (p.y > h) {
            p.y = 0;
            p.x = Math.random() * w;
          }
        }
      }
      
      // Start animation with GSAP ticker
      gsap.ticker.add(render);
    }
  </script>

  <!-- ============================================================================
       CHRISTMAS TREE ANIMATION (Right Side)
       ============================================================================ -->
  <script>
    // Christmas tree is always in DOM but hidden by CSS
    // Only visible when body.christmas-theme class is present
  </script>

  <!-- ============================================================================
       FLOATING CHAT BUTTON (Bottom Right)
       ============================================================================ -->
  <style>
    /* Floating Chat Button */
    .chat-fab {
      position: fixed;
      right: calc(18px + env(safe-area-inset-right, 0px));
      bottom: calc(18px + env(safe-area-inset-bottom, 0px));
      width: 56px;
      height: 56px;
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,.18);
      background:
        radial-gradient(120% 120% at 20% 20%, rgba(34,211,238,.28), transparent 55%),
        radial-gradient(140% 140% at 80% 10%, rgba(167,139,250,.24), transparent 55%),
        linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.06));
      backdrop-filter: blur(14px);
      -webkit-backdrop-filter: blur(14px);
      box-shadow: 
        0 18px 55px rgba(0,0,0,.45),
        0 0 24px rgba(34,211,238,.35),
        0 0 28px rgba(167,139,250,.30);
      color: rgba(255,255,255,.92);
      cursor: pointer;
      display: grid;
      place-items: center;
      z-index: 99999;
      transition: transform .18s ease, box-shadow .18s ease, border-color .18s ease;
      user-select: none;
      text-decoration: none;
    }
    
    .chat-fab:hover {
      transform: translateY(-2px);
      border-color: rgba(255,255,255,.28);
    }
    
    .chat-fab:active {
      transform: translateY(0px) scale(.98);
    }

    .chat-fab svg {
      width: 22px;
      height: 22px;
      opacity: .95;
    }

    .chat-badge {
      position: absolute;
      top: -6px;
      right: -6px;
      min-width: 20px;
      height: 20px;
      padding: 0 6px;
      border-radius: 999px;
      background: linear-gradient(135deg, rgba(34,211,238,.95), rgba(167,139,250,.95));
      color: rgba(10,10,15,.95);
      font-weight: 800;
      font-size: 12px;
      display: none;
      align-items: center;
      justify-content: center;
      box-shadow: 0 10px 24px rgba(0,0,0,.35);
      border: 1px solid rgba(255,255,255,.22);
    }
    
    .chat-badge.show {
      display: flex;
    }

    #chatIframe {
      max-height: calc(100vh - 40px);
      max-height: calc(100dvh - 40px);
    }

    @media (max-width: 640px) {
      #chatIframe {
        left: 16px !important;
        right: 16px !important;
        width: auto !important;
        max-width: none !important;
        height: calc(100dvh - 80px) !important;
        max-height: calc(100dvh - 80px) !important;
        bottom: calc(16px + env(safe-area-inset-bottom, 0px)) !important;
      }
    }

    /* Admin message badge - red with blink */
    .chat-badge.admin-message {
      background: linear-gradient(135deg, rgba(239,68,68,.95), rgba(220,38,38,.95));
      color: white;
      animation: badgeBlink 1.5s ease-in-out infinite;
    }

    /* Mentioned badge - blue with blink */
    .chat-badge.mentioned {
      background: linear-gradient(135deg, rgba(59,130,246,.95), rgba(37,99,235,.95));
      color: white;
      animation: badgeBlink 1.5s ease-in-out infinite;
    }

    /* Student message badge - static blue */
    .chat-badge.student-message {
      background: linear-gradient(135deg, rgba(59,130,246,.95), rgba(37,99,235,.95));
      color: white;
    }

    @keyframes badgeBlink {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.6; transform: scale(0.95); }
    }

    /* Mobile adjustments */
    @media (max-width: 768px) {
      .chat-fab {
        right: calc(14px + env(safe-area-inset-right, 0px));
        bottom: calc(14px + env(safe-area-inset-bottom, 0px));
        width: 52px;
        height: 52px;
      }
    }
  </style>

  <!-- Chat FAB Button -->
  <a href="#" class="chat-fab" title="Student chat" id="chatFab">
    <span class="chat-badge" id="chatBadge">•</span>
    <svg viewBox="0 0 24 24" fill="none">
      <path d="M20 12c0 4.418-3.582 8-8 8a8.6 8.6 0 0 1-3.2-.6L4 20l.7-3.6A7.9 7.9 0 0 1 4 12c0-4.418 3.582-8 8-8s8 3.582 8 8Z"
        stroke="currentColor" stroke-width="1.8" stroke-linejoin="round"/>
      <path d="M8 12h.01M12 12h.01M16 12h.01" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
    </svg>
  </a>

  <!-- Chat Iframe Container -->
  <iframe id="chatIframe"
    title="Student Chat"
    style="position: fixed; 
      right: calc(20px + env(safe-area-inset-right, 0px)); 
      bottom: calc(20px + env(safe-area-inset-bottom, 0px)); 
           width: 400px; 
           height: 650px; 
           max-width: calc(100vw - 40px);
      max-height: calc(100vh - 40px);
      max-height: calc(100dvh - 40px);
           border: none; 
           pointer-events: none; 
           z-index: 99998; 
           background: transparent;
           display: none;">
  </iframe>

  <script>
    // Chat FAB and badge logic
    (function() {
      const chatFab = document.getElementById('chatFab');
      const chatBadge = document.getElementById('chatBadge');
      const chatIframe = document.getElementById('chatIframe');
      let chatOpen = false;
      
      // Handle chat FAB click - open chat in iframe
      chatFab.addEventListener('click', (e) => {
        e.preventDefault();
        
        if (window.currentStudent) {
          const studentId = window.currentStudent.id;
          const studentName = encodeURIComponent(window.currentStudent.name);
          const chatUrl = `Student-Chat.html?studentId=${studentId}&studentName=${studentName}`;
          
          if (!chatOpen) {
            chatIframe.src = chatUrl;
            chatIframe.style.display = 'block';
            chatIframe.style.pointerEvents = 'auto';
            chatOpen = true;
            chatFab.style.display = 'none'; // Hide FAB when chat is open
          }
        } else {
          alert('Please wait for the portal to load completely.');
        }
      });
      
      // Listen for messages from chat iframe (for close button)
      window.addEventListener('message', (event) => {
        if (event.data === 'closeChat') {
          chatIframe.style.display = 'none';
          chatIframe.style.pointerEvents = 'none';
          chatOpen = false;
          chatFab.style.display = 'grid'; // Show FAB when chat closes
        }
      });
      
      // Check if there are unread admin messages and handle auto-open
      async function checkUnreadMessages() {
        try {
          if (!window.currentStudent || !window.supabase) return;
          
          // Create supabase client instance
          const SUPABASE_URL = 'https://zlvnxvrzotamhpezqedr.supabase.co';
          const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Inpsdm54dnJ6b3RhbWhwZXpxZWRyIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjI4MTEzMTcsImV4cCI6MjA3ODM4NzMxN30.-IoSqKhDrA9NuG4j3GufIbfmodWqCoppEklE1nTmw38';
          const supabaseClient = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
          
          const studentId = window.currentStudent.id;
          const studentName = window.currentStudent.name.toLowerCase();
          
          // Get the last time the student opened chat
          const lastOpenKey = `arnoma:chat:lastOpen:${studentId}`;
          const lastOpenTime = localStorage.getItem(lastOpenKey) || new Date(0).toISOString();
          
          // Query for new messages since last open
          const { data: messages, error } = await supabaseClient
            .from('chat_messages')
            .select('*')
            .gt('created_at', lastOpenTime)
            .order('created_at', { ascending: false });
          
          if (error) {
            console.error('Error checking chat messages:', error);
            return;
          }
          
          if (!messages || messages.length === 0) {
            chatBadge.classList.remove('show', 'admin-message', 'mentioned', 'student-message');
            return;
          }
          
          // Check for admin messages (highest priority - auto-open)
          const adminMessages = messages.filter(m => 
            m.sender_type === 'admin' && (m.is_private === false || m.student_id === studentId)
          );
          
          if (adminMessages.length > 0) {
            chatBadge.textContent = adminMessages.length > 9 ? '9+' : adminMessages.length.toString();
            chatBadge.classList.remove('mentioned', 'student-message');
            chatBadge.classList.add('show', 'admin-message');
            
            // Auto-open chat if admin messaged
            if (!chatOpen) {
              setTimeout(() => {
                chatFab.click();
              }, 500);
            }
            return;
          }
          
          // Check for mentions (name in message text)
          const mentionMessages = messages.filter(m => 
            m.sender_type === 'student' && 
            m.student_id !== studentId &&
            m.is_private === false &&
            m.message && m.message.toLowerCase().includes(studentName)
          );
          
          if (mentionMessages.length > 0) {
            chatBadge.textContent = mentionMessages.length > 9 ? '9+' : mentionMessages.length.toString();
            chatBadge.classList.remove('admin-message', 'student-message');
            chatBadge.classList.add('show', 'mentioned');
            return;
          }
          
          // Check for other student messages (lowest priority)
          const studentMessages = messages.filter(m => 
            m.sender_type === 'student' && 
            m.student_id !== studentId &&
            m.is_private === false
          );
          
          if (studentMessages.length > 0) {
            chatBadge.textContent = studentMessages.length > 9 ? '9+' : studentMessages.length.toString();
            chatBadge.classList.remove('admin-message', 'mentioned');
            chatBadge.classList.add('show', 'student-message');
            return;
          }
          
          // No new messages
          chatBadge.classList.remove('show', 'admin-message', 'mentioned', 'student-message');
          
        } catch (e) {
          console.error('Chat badge error:', e);
        }
      }
      
      // Update last open time when chat opens
      chatFab.addEventListener('click', () => {
        if (window.currentStudent) {
          const lastOpenKey = `arnoma:chat:lastOpen:${window.currentStudent.id}`;
          localStorage.setItem(lastOpenKey, new Date().toISOString());
          chatBadge.classList.remove('show', 'admin-message', 'mentioned', 'student-message');
        }
      });
      
      // Listen for chat iframe to signal it's ready, then check messages
      window.addEventListener('message', (event) => {
        if (event.data === 'chatReady') {
          checkUnreadMessages();
        }
      });
      
      // Check on load (wait for currentStudent to be available)
      const checkInterval = setInterval(() => {
        if (window.currentStudent && window.supabase) {
          clearInterval(checkInterval);
          checkUnreadMessages();
        }
      }, 100);
      
      // Check periodically (every 30 seconds)
      setInterval(checkUnreadMessages, 30000);
    })();
  </script>
</body>
</html>
