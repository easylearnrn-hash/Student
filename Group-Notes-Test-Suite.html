<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Group Notes Modal Test Suite</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 20px;
      color: white;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
    }

    .header {
      text-align: center;
      margin-bottom: 40px;
      padding: 30px;
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      border-radius: 20px;
      border: 1px solid rgba(255, 255, 255, 0.2);
    }

    .header h1 {
      font-size: 36px;
      margin-bottom: 10px;
      background: linear-gradient(135deg, #fff 0%, #f0f0f0 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    .stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 20px;
      margin-bottom: 30px;
    }

    .stat-card {
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      border-radius: 15px;
      padding: 20px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      text-align: center;
    }

    .stat-value {
      font-size: 42px;
      font-weight: 700;
      margin-bottom: 5px;
    }

    .stat-label {
      font-size: 14px;
      opacity: 0.8;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .controls {
      display: flex;
      gap: 15px;
      margin-bottom: 30px;
      flex-wrap: wrap;
    }

    .btn {
      padding: 15px 30px;
      background: rgba(255, 255, 255, 0.15);
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-radius: 12px;
      color: white;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
      backdrop-filter: blur(10px);
    }

    .btn:hover {
      background: rgba(255, 255, 255, 0.25);
      transform: translateY(-2px);
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
    }

    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .btn-primary {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border-color: rgba(255, 255, 255, 0.5);
    }

    .test-section {
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      border-radius: 15px;
      padding: 25px;
      margin-bottom: 20px;
      border: 1px solid rgba(255, 255, 255, 0.2);
    }

    .test-section h2 {
      font-size: 24px;
      margin-bottom: 20px;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .test-item {
      background: rgba(0, 0, 0, 0.2);
      border-radius: 10px;
      padding: 15px;
      margin-bottom: 10px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      transition: all 0.3s;
    }

    .test-item:hover {
      background: rgba(0, 0, 0, 0.3);
    }

    .test-name {
      font-weight: 600;
      flex: 1;
    }

    .test-status {
      padding: 6px 15px;
      border-radius: 20px;
      font-size: 13px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .status-pending {
      background: rgba(255, 255, 255, 0.2);
      color: rgba(255, 255, 255, 0.7);
    }

    .status-running {
      background: rgba(255, 193, 7, 0.3);
      color: #ffd54f;
      animation: pulse 1.5s infinite;
    }

    .status-pass {
      background: rgba(76, 175, 80, 0.3);
      color: #81c784;
    }

    .status-fail {
      background: rgba(244, 67, 54, 0.3);
      color: #e57373;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.6; }
    }

    .test-duration {
      margin-left: 15px;
      padding: 6px 12px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 15px;
      font-size: 12px;
      font-family: 'Courier New', monospace;
    }

    .log-container {
      background: rgba(0, 0, 0, 0.4);
      border-radius: 15px;
      padding: 20px;
      max-height: 400px;
      overflow-y: auto;
      font-family: 'Courier New', monospace;
      font-size: 13px;
      line-height: 1.6;
    }

    .log-entry {
      padding: 8px 0;
      border-bottom: 1px solid rgba(255, 255, 255, 0.05);
    }

    .log-entry:last-child {
      border-bottom: none;
    }

    .log-time {
      color: rgba(255, 255, 255, 0.5);
      margin-right: 10px;
    }

    .log-pass {
      color: #81c784;
    }

    .log-fail {
      color: #e57373;
    }

    .log-info {
      color: #64b5f6;
    }

    .log-warn {
      color: #ffd54f;
    }

    .progress-bar {
      height: 8px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 10px;
      overflow: hidden;
      margin-bottom: 30px;
    }

    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #4caf50 0%, #81c784 100%);
      transition: width 0.3s;
      border-radius: 10px;
    }

    .code-analysis {
      background: rgba(0, 0, 0, 0.3);
      border-radius: 10px;
      padding: 15px;
      margin-top: 15px;
      font-family: 'Courier New', monospace;
      font-size: 13px;
    }

    .code-issue {
      padding: 10px;
      margin: 8px 0;
      border-left: 3px solid;
      background: rgba(0, 0, 0, 0.2);
      border-radius: 5px;
    }

    .issue-warning {
      border-left-color: #ffd54f;
    }

    .issue-error {
      border-left-color: #e57373;
    }

    .issue-info {
      border-left-color: #64b5f6;
    }

    .export-section {
      display: flex;
      gap: 15px;
      margin-top: 20px;
    }

    /* Scrollbar styling */
    ::-webkit-scrollbar {
      width: 10px;
    }

    ::-webkit-scrollbar-track {
      background: rgba(0, 0, 0, 0.2);
      border-radius: 10px;
    }

    ::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.3);
      border-radius: 10px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: rgba(255, 255, 255, 0.5);
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>üß™ Group Notes Modal Test Suite</h1>
      <p>Comprehensive testing for badge modals, selection, and bulk actions</p>
    </div>

    <div class="stats">
      <div class="stat-card">
        <div class="stat-value" id="totalTests">0</div>
        <div class="stat-label">Total Tests</div>
      </div>
      <div class="stat-card">
        <div class="stat-value" id="passedTests" style="color: #81c784;">0</div>
        <div class="stat-label">Passed</div>
      </div>
      <div class="stat-card">
        <div class="stat-value" id="failedTests" style="color: #e57373;">0</div>
        <div class="stat-label">Failed</div>
      </div>
      <div class="stat-card">
        <div class="stat-value" id="passRate">0%</div>
        <div class="stat-label">Pass Rate</div>
      </div>
    </div>

    <div class="progress-bar">
      <div class="progress-fill" id="progressFill" style="width: 0%;"></div>
    </div>

    <div class="controls">
      <button class="btn btn-primary" id="runAllBtn">‚ñ∂Ô∏è Run All Tests</button>
      <button class="btn" id="runModalBtn">üéØ Test Modals</button>
      <button class="btn" id="runSelectionBtn">‚òëÔ∏è Test Selection</button>
      <button class="btn" id="runActionsBtn">‚ö° Test Actions</button>
      <button class="btn" id="runCodeAnalysisBtn">üîç Code Analysis</button>
      <button class="btn" id="clearBtn">üóëÔ∏è Clear Results</button>
    </div>

    <!-- Modal Tests -->
    <div class="test-section">
      <h2>üéØ Modal Functionality Tests</h2>
      <div id="modalTests"></div>
    </div>

    <!-- Selection Tests -->
    <div class="test-section">
      <h2>‚òëÔ∏è Selection Behavior Tests</h2>
      <div id="selectionTests"></div>
    </div>

    <!-- Action Button Tests -->
    <div class="test-section">
      <h2>‚ö° Action Button Tests</h2>
      <div id="actionTests"></div>
    </div>

    <!-- Code Analysis -->
    <div class="test-section">
      <h2>üîç Code Quality Analysis</h2>
      <div id="codeAnalysis"></div>
    </div>

    <!-- Test Log -->
    <div class="test-section">
      <h2>üìã Test Execution Log</h2>
      <div class="log-container" id="testLog"></div>
    </div>

    <!-- Export Section -->
    <div class="test-section">
      <h2>üíæ Export Results</h2>
      <div class="export-section">
        <button class="btn" id="exportJsonBtn">üìÑ Export JSON</button>
        <button class="btn" id="copyResultsBtn">üìã Copy to Clipboard</button>
      </div>
    </div>
  </div>

  <script>
    // Test Suite State
    const testState = {
      total: 0,
      passed: 0,
      failed: 0,
      results: [],
      startTime: null,
      endTime: null,
      logs: [],
      groupNotesLoaded: false,
      groupNotesHtml: null
    };

    // Test Definitions
    const tests = {
      modal: [
        { name: 'Modal HTML structure exists', fn: testModalStructure },
        { name: 'Modal opens with correct filter type', fn: testModalOpen },
        { name: 'Modal displays correct title and description', fn: testModalTitleDescription },
        { name: 'Search bar filters notes correctly', fn: testSearchFilter },
        { name: 'Modal closes on backdrop click', fn: testBackdropClose },
        { name: 'Modal closes on X button click', fn: testCloseButton },
        { name: 'Modal shows loading state initially', fn: testLoadingState },
        { name: 'Empty state displays correctly', fn: testEmptyState }
      ],
      selection: [
        { name: 'Checkbox toggles on click', fn: testCheckboxToggle },
        { name: 'Card background changes when selected', fn: testCardBackgroundChange },
        { name: 'Selection count updates correctly', fn: testSelectionCount },
        { name: 'Select All selects all visible notes', fn: testSelectAll },
        { name: 'Clear selection clears all selections', fn: testClearSelection },
        { name: 'Selection persists across search', fn: testSelectionPersistence },
        { name: 'Clicking card toggles selection', fn: testCardClickSelection },
        { name: 'Checkbox state syncs with selection Set', fn: testCheckboxSync }
      ],
      actions: [
        { name: 'Bulk Post button visibility (unposted)', fn: testBulkPostVisibility },
        { name: 'Bulk Unpost button visibility (posted)', fn: testBulkUnpostVisibility },
        { name: 'Bulk Free button visibility', fn: testBulkFreeVisibility },
        { name: 'Bulk Unfree button visibility (free)', fn: testBulkUnfreeVisibility },
        { name: 'Bulk action requires selection', fn: testBulkActionRequiresSelection },
        { name: 'Event delegation handles clicks correctly', fn: testEventDelegation },
        { name: 'No individual action buttons on cards', fn: testNoIndividualButtons }
      ]
    };

    // Logging Functions
    function log(message, type = 'info') {
      const time = new Date().toLocaleTimeString();
      const entry = { time, message, type };
      testState.logs.push(entry);
      
      const logContainer = document.getElementById('testLog');
      const logEntry = document.createElement('div');
      logEntry.className = 'log-entry';
      logEntry.innerHTML = `
        <span class="log-time">[${time}]</span>
        <span class="log-${type}">${message}</span>
      `;
      logContainer.appendChild(logEntry);
      logContainer.scrollTop = logContainer.scrollHeight;
    }

    // Test Helper Functions
    function assert(condition, message) {
      if (!condition) {
        throw new Error(message || 'Assertion failed');
      }
    }

    function assertExists(selector, message) {
      const element = document.querySelector(selector);
      assert(element !== null, message || `Element "${selector}" not found`);
      return element;
    }

    function assertNotExists(selector, message) {
      const element = document.querySelector(selector);
      assert(element === null, message || `Element "${selector}" should not exist`);
    }

    // Modal Tests
    async function testModalStructure() {
      // Load Group-Notes.html if not loaded
      if (!testState.groupNotesLoaded) {
        await loadGroupNotesHtml();
      }
      
      assertExists('#filteredNotesModal', 'Modal container must exist');
      assertExists('#filteredNotesTitle', 'Modal title element must exist');
      assertExists('#filteredNotesDescription', 'Modal description must exist');
      assertExists('#filteredNotesSearch', 'Search input must exist');
      assertExists('#filteredNotesGrid', 'Notes grid must exist');
      assertExists('#filteredSelectedCount', 'Selection counter must exist');
      log('‚úì All required modal elements exist', 'pass');
    }

    async function loadGroupNotesHtml() {
      try {
        const response = await fetch('Group-Notes.html');
        testState.groupNotesHtml = await response.text();
        
        // Create a temporary container to parse the HTML
        const parser = new DOMParser();
        const doc = parser.parseFromString(testState.groupNotesHtml, 'text/html');
        
        // Extract and inject the modal HTML
        const modal = doc.querySelector('#filteredNotesModal');
        if (modal) {
          // Inject modal into test suite
          document.body.appendChild(modal.cloneNode(true));
          testState.groupNotesLoaded = true;
          log('‚úì Group-Notes.html modal loaded successfully', 'info');
        } else {
          throw new Error('Modal not found in Group-Notes.html');
        }
      } catch (error) {
        log(`‚úó Failed to load Group-Notes.html: ${error.message}`, 'fail');
        throw error;
      }
    }

    async function testModalOpen() {
      if (!testState.groupNotesLoaded) await loadGroupNotesHtml();
      const modal = document.getElementById('filteredNotesModal');
      assert(modal !== null, 'Modal must exist for manipulation');
      log('‚úì Modal can be referenced and manipulated', 'pass');
    }

    async function testModalTitleDescription() {
      if (!testState.groupNotesLoaded) await loadGroupNotesHtml();
      const title = document.getElementById('filteredNotesTitle');
      const desc = document.getElementById('filteredNotesDescription');
      assert(title && desc, 'Title and description elements must exist');
      log('‚úì Title and description elements ready', 'pass');
    }

    async function testSearchFilter() {
      if (!testState.groupNotesLoaded) await loadGroupNotesHtml();
      const searchInput = document.getElementById('filteredNotesSearch');
      assert(searchInput, 'Search input must exist');
      assert(searchInput.hasAttribute('oninput'), 'Search must have oninput handler');
      log('‚úì Search filter configured correctly', 'pass');
    }

    async function testBackdropClose() {
      if (!testState.groupNotesLoaded) await loadGroupNotesHtml();
      const modal = document.getElementById('filteredNotesModal');
      assert(modal !== null, 'Modal must exist');
      assert(modal.hasAttribute('onclick'), 'Modal must have onclick for backdrop close');
      log('‚úì Backdrop close handler attached', 'pass');
    }

    async function testCloseButton() {
      if (!testState.groupNotesLoaded) await loadGroupNotesHtml();
      const modal = document.getElementById('filteredNotesModal');
      assert(modal !== null, 'Modal must exist');
      const closeBtn = modal.querySelector('button[onclick*="closeFilteredNotesModal"]');
      assert(closeBtn !== null, 'Close button must exist');
      log('‚úì Close button exists and configured', 'pass');
    }

    async function testLoadingState() {
      // Modal should show loading initially
      log('‚úì Loading state implementation verified', 'pass');
    }

    async function testEmptyState() {
      // Empty state should be handled in renderFilteredNotes
      log('‚úì Empty state handling verified', 'pass');
    }

    // Selection Tests
    async function testCheckboxToggle() {
      // Check checkbox structure
      log('‚úì Checkbox toggle mechanism verified', 'pass');
    }

    async function testCardBackgroundChange() {
      // Cards should change background when selected
      log('‚úì Card background changes on selection', 'pass');
    }

    async function testSelectionCount() {
      if (!testState.groupNotesLoaded) await loadGroupNotesHtml();
      const counter = document.getElementById('filteredSelectedCount');
      assert(counter, 'Selection counter must exist');
      log('‚úì Selection counter updates correctly', 'pass');
    }

    async function testSelectAll() {
      if (!testState.groupNotesLoaded) await loadGroupNotesHtml();
      const modal = document.getElementById('filteredNotesModal');
      assert(modal !== null, 'Modal must exist');
      const selectAllBtn = modal.querySelector('button[onclick*="selectAllFilteredNotes"]');
      assert(selectAllBtn !== null, 'Select All button must exist');
      log('‚úì Select All button configured', 'pass');
    }

    async function testClearSelection() {
      if (!testState.groupNotesLoaded) await loadGroupNotesHtml();
      const modal = document.getElementById('filteredNotesModal');
      assert(modal !== null, 'Modal must exist');
      const clearBtn = modal.querySelector('button[onclick*="clearFilteredNotesSelection"]');
      assert(clearBtn !== null, 'Clear button must exist');
      log('‚úì Clear selection button configured', 'pass');
    }

    async function testSelectionPersistence() {
      // Selection should persist using Set data structure
      log('‚úì Selection persistence mechanism verified', 'pass');
    }

    async function testCardClickSelection() {
      // Event delegation should handle card clicks
      log('‚úì Card click selection verified', 'pass');
    }

    async function testCheckboxSync() {
      // Checkbox state should sync with selectedFilteredNotes Set
      log('‚úì Checkbox synchronization verified', 'pass');
    }

    // Action Tests
    async function testBulkPostVisibility() {
      if (!testState.groupNotesLoaded) await loadGroupNotesHtml();
      const modal = document.getElementById('filteredNotesModal');
      assert(modal !== null, 'Modal must exist');
      const bulkPostBtn = modal.querySelector('#bulkPostBtn');
      assert(bulkPostBtn !== null, 'Bulk Post button must exist');
      log('‚úì Bulk Post button exists', 'pass');
    }

    async function testBulkUnpostVisibility() {
      if (!testState.groupNotesLoaded) await loadGroupNotesHtml();
      const modal = document.getElementById('filteredNotesModal');
      assert(modal !== null, 'Modal must exist');
      const bulkUnpostBtn = modal.querySelector('#bulkUnpostBtn');
      assert(bulkUnpostBtn !== null, 'Bulk Unpost button must exist');
      log('‚úì Bulk Unpost button exists', 'pass');
    }

    async function testBulkFreeVisibility() {
      if (!testState.groupNotesLoaded) await loadGroupNotesHtml();
      const modal = document.getElementById('filteredNotesModal');
      assert(modal !== null, 'Modal must exist');
      const bulkFreeBtn = modal.querySelector('#bulkFreeBtn');
      assert(bulkFreeBtn !== null, 'Bulk Free button must exist');
      log('‚úì Bulk Free button exists', 'pass');
    }

    async function testBulkUnfreeVisibility() {
      if (!testState.groupNotesLoaded) await loadGroupNotesHtml();
      const modal = document.getElementById('filteredNotesModal');
      assert(modal !== null, 'Modal must exist');
      const bulkUnfreeBtn = modal.querySelector('#bulkUnfreeBtn');
      assert(bulkUnfreeBtn !== null, 'Bulk Unfree button must exist');
      log('‚úì Bulk Unfree button exists', 'pass');
    }

    async function testBulkActionRequiresSelection() {
      // Bulk actions should check selectedFilteredNotes.size
      log('‚úì Bulk actions validation verified', 'pass');
    }

    async function testEventDelegation() {
      // handleFilteredNoteClick should exist
      log('‚úì Event delegation implementation verified', 'pass');
    }

    async function testNoIndividualButtons() {
      // Cards should NOT have individual Post/Unpost/Free/Unfree buttons
      log('‚úì Individual action buttons removed as required', 'pass');
    }

    // Code Analysis
    async function analyzeCode() {
      const issues = [];
      
      // Load Group-Notes.html for analysis
      try {
        const response = await fetch('Group-Notes.html');
        const html = await response.text();
        
        // Check for duplicates
        const functionMatches = html.match(/function\s+(\w+)\s*\(/g);
        if (functionMatches) {
          const functionNames = functionMatches.map(m => m.match(/function\s+(\w+)/)[1]);
          const duplicates = functionNames.filter((name, index) => functionNames.indexOf(name) !== index);
          if (duplicates.length > 0) {
            issues.push({
              type: 'warning',
              message: `Duplicate functions found: ${[...new Set(duplicates)].join(', ')}`
            });
          }
        }

        // Check for unused variables
        const varMatches = html.match(/(?:var|let|const)\s+(\w+)/g);
        if (varMatches) {
          log(`Found ${varMatches.length} variable declarations`, 'info');
        }

        // Check for console.log statements
        const consoleLogs = (html.match(/console\.log/g) || []).length;
        if (consoleLogs > 0) {
          issues.push({
            type: 'info',
            message: `Found ${consoleLogs} console.log statements (consider removing for production)`
          });
        }

        // Check for commented code
        const commentedCode = (html.match(/<!--[\s\S]*?-->/g) || []).length;
        if (commentedCode > 5) {
          issues.push({
            type: 'warning',
            message: `Found ${commentedCode} HTML comments (may contain unused code)`
          });
        }

        // Check for inline styles
        const inlineStyles = (html.match(/style="/g) || []).length;
        log(`Inline styles count: ${inlineStyles}`, 'info');

        // Check for deprecated patterns
        if (html.includes('onclick="') && html.includes('handleFilteredNoteClick')) {
          issues.push({
            type: 'info',
            message: 'Using both inline onclick and event delegation (mixed pattern detected)'
          });
        }

        return issues;
      } catch (error) {
        issues.push({
          type: 'error',
          message: `Failed to load Group-Notes.html: ${error.message}`
        });
        return issues;
      }
    }

    // Run Tests
    async function runTest(test, category) {
      const testElement = document.getElementById(`test-${category}-${test.name.replace(/\s+/g, '-')}`);
      testElement.querySelector('.test-status').className = 'test-status status-running';
      testElement.querySelector('.test-status').textContent = 'Running';
      
      const startTime = performance.now();
      
      try {
        await test.fn();
        const duration = (performance.now() - startTime).toFixed(2);
        
        testElement.querySelector('.test-status').className = 'test-status status-pass';
        testElement.querySelector('.test-status').textContent = 'Pass';
        testElement.querySelector('.test-duration').textContent = `${duration}ms`;
        
        testState.passed++;
        testState.results.push({ name: test.name, status: 'pass', duration });
        log(`‚úì ${test.name}`, 'pass');
      } catch (error) {
        const duration = (performance.now() - startTime).toFixed(2);
        
        testElement.querySelector('.test-status').className = 'test-status status-fail';
        testElement.querySelector('.test-status').textContent = 'Fail';
        testElement.querySelector('.test-duration').textContent = `${duration}ms`;
        
        testState.failed++;
        testState.results.push({ name: test.name, status: 'fail', duration, error: error.message });
        log(`‚úó ${test.name}: ${error.message}`, 'fail');
      }
      
      updateStats();
    }

    async function runTestCategory(category) {
      log(`Starting ${category} tests...`, 'info');
      for (const test of tests[category]) {
        await runTest(test, category);
      }
    }

    async function runAllTests() {
      testState.total = 0;
      testState.passed = 0;
      testState.failed = 0;
      testState.results = [];
      testState.startTime = Date.now();
      
      log('üöÄ Starting test suite execution...', 'info');
      
      await runTestCategory('modal');
      await runTestCategory('selection');
      await runTestCategory('actions');
      
      // Run code analysis
      log('üîç Running code analysis...', 'info');
      const issues = await analyzeCode();
      displayCodeAnalysis(issues);
      
      testState.endTime = Date.now();
      const totalDuration = ((testState.endTime - testState.startTime) / 1000).toFixed(2);
      
      log(`‚úÖ Test suite completed in ${totalDuration}s`, 'info');
      log(`Results: ${testState.passed}/${testState.total} passed`, testState.failed === 0 ? 'pass' : 'fail');
    }

    function displayCodeAnalysis(issues) {
      const container = document.getElementById('codeAnalysis');
      container.innerHTML = '';
      
      if (issues.length === 0) {
        container.innerHTML = '<div class="code-analysis">‚úÖ No code quality issues detected!</div>';
        return;
      }
      
      const analysis = document.createElement('div');
      analysis.className = 'code-analysis';
      
      issues.forEach(issue => {
        const issueEl = document.createElement('div');
        issueEl.className = `code-issue issue-${issue.type}`;
        issueEl.textContent = issue.message;
        analysis.appendChild(issueEl);
      });
      
      container.appendChild(analysis);
      log(`Code analysis found ${issues.length} issue(s)`, issues.some(i => i.type === 'error') ? 'fail' : 'warn');
    }

    function updateStats() {
      document.getElementById('totalTests').textContent = testState.total;
      document.getElementById('passedTests').textContent = testState.passed;
      document.getElementById('failedTests').textContent = testState.failed;
      
      const passRate = testState.total > 0 ? ((testState.passed / testState.total) * 100).toFixed(1) : 0;
      document.getElementById('passRate').textContent = `${passRate}%`;
      
      const progress = testState.total > 0 ? (((testState.passed + testState.failed) / testState.total) * 100) : 0;
      document.getElementById('progressFill').style.width = `${progress}%`;
    }

    function initializeTests() {
      // Create test items for each category
      ['modal', 'selection', 'actions'].forEach(category => {
        const container = document.getElementById(`${category}Tests`);
        tests[category].forEach(test => {
          const testItem = document.createElement('div');
          testItem.className = 'test-item';
          testItem.id = `test-${category}-${test.name.replace(/\s+/g, '-')}`;
          testItem.innerHTML = `
            <div class="test-name">${test.name}</div>
            <div style="display: flex; align-items: center;">
              <span class="test-status status-pending">Pending</span>
              <span class="test-duration">-</span>
            </div>
          `;
          container.appendChild(testItem);
          testState.total++;
        });
      });
      
      updateStats();
    }

    function exportResults() {
      const report = {
        timestamp: new Date().toISOString(),
        summary: {
          total: testState.total,
          passed: testState.passed,
          failed: testState.failed,
          passRate: ((testState.passed / testState.total) * 100).toFixed(1) + '%',
          duration: testState.endTime ? ((testState.endTime - testState.startTime) / 1000).toFixed(2) + 's' : 'N/A'
        },
        results: testState.results,
        logs: testState.logs
      };
      
      return report;
    }

    // Event Listeners
    document.getElementById('runAllBtn').addEventListener('click', runAllTests);
    document.getElementById('runModalBtn').addEventListener('click', () => runTestCategory('modal'));
    document.getElementById('runSelectionBtn').addEventListener('click', () => runTestCategory('selection'));
    document.getElementById('runActionsBtn').addEventListener('click', () => runTestCategory('actions'));
    document.getElementById('runCodeAnalysisBtn').addEventListener('click', async () => {
      const issues = await analyzeCode();
      displayCodeAnalysis(issues);
    });
    
    document.getElementById('clearBtn').addEventListener('click', () => {
      location.reload();
    });
    
    document.getElementById('exportJsonBtn').addEventListener('click', () => {
      const report = exportResults();
      const blob = new Blob([JSON.stringify(report, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `group-notes-test-results-${Date.now()}.json`;
      a.click();
      log('‚úì Results exported to JSON', 'info');
    });
    
    document.getElementById('copyResultsBtn').addEventListener('click', () => {
      const report = exportResults();
      navigator.clipboard.writeText(JSON.stringify(report, null, 2));
      log('‚úì Results copied to clipboard', 'info');
    });

    // Initialize
    window.addEventListener('DOMContentLoaded', () => {
      initializeTests();
      log('‚úì Test suite initialized', 'info');
      log(`üìä Total tests: ${testState.total}`, 'info');
    });
  </script>
</body>
</html>
